module utils

imports
	
	include/QL

rules // language selection
	
	ql-or-qls(ql, qls) = if ?QLS(_, _) then qls else ql end

rules // set transitive closure
	
	transitive-closure(s) = transitive-closure(s|[])
	
	transitive-closure(s|accu): []		-> accu
	transitive-closure(s|accu): [h|t]	-> result
		where
			if <elem> (h, accu) then
				result := <transitive-closure(s|accu)> t
			else
				result := <conc; transitive-closure(s|[h|accu])> (<s> h, t)
			end
	
rules // lists & sets
	
	make-set(eq) = foldr(![], union(eq), ![<id>])
	
	hd-to-tl = <conc> (<Tl>, [<Hd>])
	
	duplicates(eq,swp) = ?[_];![] <+ qsort(swp); duplicates(eq)
	
	duplicates(eq) = ?[_];![] <+ <zip> (<id>, <hd-to-tl>); filter(eq)
	
rules
	
  force-origins(s) =
    ![<id>]; all(s); ?[<id>]

rules
	
	safe-thread-replacement(s) :
    (c#(ts){a*}, x) -> (c#(ts'){a*}, y)
    where <thread-map(s)> (ts, x) => (ts', y)

  safe-thread-alltd(s) = 
    rec x(s <+ safe-thread-replacement(x))
