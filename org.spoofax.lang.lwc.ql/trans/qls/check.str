module qls/check

imports
	include/QL
	qls/styles
	qls/types
	lib/editor-common.generated
	
rules // generic
	
	constraint-warning = fail
	
	constraint-note = fail

rules // style dependencies
	
	constraint-error:
		|[ define style sid { stydef* }]| -> (sid, $[Style [sid] has cyclic dependencies])
		where
			<qls-has-circular-dependency-style> sid

rules // widget types
	
	// typed widget declaration in style definition
	constraint-error =
		?|[type widget = widge ]|;
		<qls-type-error(elem)> (type, widge)

	// untyped widget in question styling
	constraint-error =
		?|[ qid { style* }]|;
		qls-type-of => q-type;
		<filter(?Widget(<id>))> style*;
		map(!(q-type, <id>));
		filter(qls-type-error(elem))

rules // temporaries, to show simplificated styles

	constraint-note:
		|[ define style sid { stydef* }]| -> (sid, $[Simplified style [<map(pp-ql-string);concat-strings> lin]])
		where
			<qls-make-all-concrete-style;qls-simplify-style> stydef* => lin

	constraint-note =
		?|[ qid { style* }]|;
		qls-type-of => q-type;
		<qls-make-all-concrete-style> style*;
		entype-widgets(|q-type);
		qls-simplify-style;
		map(pp-ql-string);
		concat-strings;
		!(qid, $[Simplified style [<id>]])

rules // type error reporter helper
	
	qls-type-error(s): 
		(type, widget) -> (widget, $[Widget ([pp-widget]) cannot be used for type [pp-type]])
		where
			<qls-type-of> widget => widget-ty;
			<not(s)> (type, widget-ty);
			<pp-ql-string> widget => pp-widget;
			<pp-ql-string> type => pp-type

