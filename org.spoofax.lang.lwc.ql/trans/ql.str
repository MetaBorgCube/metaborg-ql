module ql

imports
  names
  desugar
  check
  generate
	types
	dependencies
	sorting
	store
	
  qls/names-qls
  qls/styles
  qls/check
	qls/desugar
	qls/generate
	qls/store
	
rules // Analysis

  ql-or-qls(ql, qls) = if ?QLS(_, _) then qls else ql end
  
	// Analyzes the current program, returning a tuple with the analyzed AST, errors, warnings, notes and
	// files that should be re-analyzed.
  analyze:
    (ast, path, project-path) -> (ast4, errors, warnings, notes, filesToAnalyze')
    with
    	ast1 := <ql-or-qls(desugar-all, qls-desugar-all)> ast;
      (ast2, filesToAnalyze) := <analyze-top(|<language>)> (ast1, path, project-path);
      index-transaction(
      	<ql-or-qls(analyze-dependencies, where(qls-analyze-dependencies); where(qls-store-styles); where(qls-store-pages))> ast2;
	      errors   := <collect-all(constraint-error, conc)> ast2;
	      warnings := <collect-all(constraint-warning, conc)> ast2;
	      notes    := <collect-all(constraint-note, conc)> ast2;
	      ast3     := <ql-or-qls(where(store-all), qls-normalize)> ast2
      );
      ast4            := ast3;
      filesToAnalyze' := <index-filepairs-to-files> filesToAnalyze

rules // Compilation

  compile-to-webdsl-ast:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
    	index-setup(|<language>, [project-path], $[[project-path]/[path]]);
    	filename := <guarantee-extension(|"app")> path;
    	result   := <ql-or-qls(compile-ql, compile-qls)> selected
	
  compile-to-webdsl:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
    	index-setup(|<language>, [project-path], $[[project-path]/[path]]);
    	filename := <guarantee-extension(|"app")> path;
    	webdsl   := <ql-or-qls(compile-ql, compile-qls)> selected;
    	result   := <pp-webdsl-string> webdsl
    	
  pp-webdsl-string =
    ast2abox(|[<import-term(lib/webdsl/WebDSL.pp.af)>]);
    box2text-string(|120)