module generate

imports
	libstratego-lib
	libstratego-gpp
	libstratego-aterm
	lib/editor-common.generated
	lib/compilation-library.generated

	include/QL
	lib/webdsl/WebDSL
	
signature

	constructors
		
		String : STRING -> String
		Text   : STRING -> Text
	
rules // Incremental code generation
			
	index-compile-ast(|file, subfile):
		ast -> None()
		with
			webdsl     := <compile> ast;
			full-path  := <dirname> file;
			filename   := <guarantee-extension(|"app")> <base-filename> file;
			writePath  := $[[full-path]/];
			writeFile  :=	$[[writePath][filename]];
			try(<mkdir> writePath);
			<fclose> <fputs> (webdsl, <fopen> (writeFile, "w"))

rules // QL to WebDSL compilation
	
  compile: 
  	form@|[ form fid { question* } ]| -> 
	  |[ 
	  	module form 
	  	
	  	ent 
	  	
	  	var globalForm := x {}
	  	
	  	tdef 
	  ]|
	  where
	  	x    := fid;
	  	ent  := <compile-entity> form;
	  	tdef := <compile-template> form
	  	
rules // QL questions to WebDSL entity
	  
  compile-entity: 
  	|[ form fid { question* } ]| -> |[ entity x_formID { ebd* } ]|
  	where
  		x_formID := fid;
	  	ebd*     := <collect-all(compile-entity-part)> question*
	  	
  compile-entity-part: 
  	|[ qid : label t ]| -> |[ x_formID :: srt_type ]|
    where
  	  x_formID := qid;
  	  srt_type := <compile-type> t

rules // QL questions to WebDSL template
	
  compile-template: 
  	|[ form fid { question* } ]| -> 
	  tdef |[
	    define showForm(form : x_formID) {
	    	horizontalForm {
	  		  elem_group*
	  		  
			    formActions {
			      submitlink submit() [class="btn btn-primary"] { "Submit" } " "
			    }
			  }
			  
			  action submit() {
			    form.save();
			  }
	  	}
	  ]|
    where
    	x_formID    := fid;
    	elem_group* := <map(compile-template-part)> question*
  
  compile-template-part: 
  	|[ qid : label t ]| -> elem |[ controlGroup(e_label) { input(form.x_id) } ]|
  	where
  		x_id    := qid;
  		e_label := <compile-exp> label
  		
  compile-template-part: 
  	|[ qid : label t ( exp ) ]| -> elem |[ controlGroup(e_label) { output(e_typeExp) } ]|
  	where
  		e_label   := <compile-exp> label;
  		e_typeExp := <compile-exp> exp
  		
  compile-template-part: 
  	|[ if ( cond ) { q* } ]| -> elem |[ if (e_cond) { elem_question* } ]|
  	where
  		e_cond         := <compile-exp> cond;
  		elem_question* := <map(compile-template-part)> q*

rules // QL types to WebDSL types
  
  compile-type: ql |[ boolean ]| -> webdsl |[ Bool   ]|
  compile-type: ql |[ string  ]| -> webdsl |[ String ]|
  compile-type: ql |[ integer ]| -> webdsl |[ Int    ]|
  compile-type: ql |[ date    ]| -> webdsl |[ Date   ]|
  compile-type: ql |[ decimal ]| -> webdsl |[ Float  ]|
  compile-type: ql |[ money   ]| -> webdsl |[ Float  ]|
  
rules // QL expressions to WebDSL expressions
  
  compile-exp = bottomup(try(compile-exp-part))
  
  compile-exp-part: Label(s) -> String(<try(un-double-quote)> s)
  compile-exp-part: Ref(qid) -> |[ form.x ]| where x := qid
  
  compile-exp-part: ql |[    !e    ]| -> webdsl:e |[    !e    ]|
  compile-exp-part: ql |[ e1 && e2 ]| -> webdsl:e |[ e1 && e2 ]|
  compile-exp-part: ql |[ e1 || e2 ]| -> webdsl:e |[ e1 || e2 ]|
  compile-exp-part: ql |[ e1 <  e2 ]| -> webdsl:e |[ e1 <  e2 ]|
  compile-exp-part: ql |[ e1 <= e2 ]| -> webdsl:e |[ e1 <= e2 ]|
  compile-exp-part: ql |[ e1 >  e2 ]| -> webdsl:e |[ e1 >  e2 ]|
  compile-exp-part: ql |[ e1 >= e2 ]| -> webdsl:e |[ e1 >= e2 ]|
  compile-exp-part: ql |[ e1 == e2 ]| -> webdsl:e |[ e1 == e2 ]|
  compile-exp-part: ql |[ e1 +  e2 ]| -> webdsl:e |[ e1 +  e2 ]|
  compile-exp-part: ql |[ e1 -  e2 ]| -> webdsl:e |[ e1 -  e2 ]|
  compile-exp-part: ql |[ e1 *  e2 ]| -> webdsl:e |[ e1 *  e2 ]|
  compile-exp-part: ql |[ e1 /  e2 ]| -> webdsl:e |[ e1 /  e2 ]|
