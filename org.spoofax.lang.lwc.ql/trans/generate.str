module generate

imports
	libstratego-lib
	libstratego-gpp
	libstratego-aterm
	lib/editor-common.generated
	lib/compilation-library.generated

	include/QL
	lib/webdsl/WebDSL
	
signature

	constructors
		
		String : STRING -> String
		Text   : STRING -> Text
	
rules // Incremental code generation
			
	index-compile-ast(|file, subfile):
		ast -> None()
		with
			java := <compile> ast;
			full-path := <dirname> file;
			filename := <guarantee-extension(|"java")> <base-filename> file;
			writePath := $[[full-path]/];
			writeFile :=	$[[writePath][filename]];
			try(<mkdir> writePath);
			<fclose> <fputs> (java, <fopen> (writeFile, "w"))

rules // QL to WebDSL compilation
	
  compile: 
  	|[ form $fid { question* } ]| -> 
	  |[ 
	  	module form 
	  	
	  	var globalForm := Form {} 
	  	
	  	ent 
	  	tdef 
	  ]|
	  where
	  	ent  := <compile-entity>
	  where
	  	tdef := <compile-template>

rules // QL questions to WebDSL entity
	  
  compile-entity: 
  	|[ form fid { q* } ]| -> |[ entity Form { ebd* } ]|
  	where
	  	ebd* := <collect-all(compile-entity-part)> q*
	  	
  compile-entity-part: 
  	|[ qid : label t ]| -> |[ x :: srt ]|
    where
  	  x   := qid;
  	  srt := <compile-type> t

rules // QL questions to WebDSL template
  
  compile-template: 
  	|[ form fid { q* } ]| -> 
	  tdef |[
	    define showForm(form : Form) {
	    	horizontalForm("Form name") {
	  		  elem*
	  		  
			    formActions {
			      submitlink submit() [class="btn btn-primary"] { "Submit" } " "
			    }
			  }
			  
			  action submit() {
			    form.save();
			  }
	  	}
	  ]|
    where
    	elem* := <map(compile-template-part)> q*
  
  compile-template-part: 
  	|[ qid : label t ]| -> elem |[ controlGroup(e) { input(form.x) } ]|
  	where
  		x := qid;
  		e := <compile-exp> label
  		
  compile-template-part: 
  	|[ qid : label t ( exp ) ]| -> elem |[ controlGroup(e1) { output(e2) } ]|
  	where
  		x  := qid;
  		e1 := <compile-exp> label;
  		e2 := <compile-exp> exp
  		
  compile-template-part: 
  	|[ if ( cond ) { q* } ]| -> elem |[ if (e) { elem* } ]|
  	where
  		e     := <compile-exp> cond;
  		elem* := <map(compile-template-part)> q*

rules // QL types to WebDSL types
  
  compile-type: ql |[ boolean ]| -> webdsl |[ Bool   ]|
  compile-type: ql |[ string  ]| -> webdsl |[ String ]|
  compile-type: ql |[ integer ]| -> webdsl |[ Int    ]|
  compile-type: ql |[ date    ]| -> webdsl |[ Date   ]|
  compile-type: ql |[ decimal ]| -> webdsl |[ Float  ]|
  compile-type: ql |[ money   ]| -> webdsl |[ Float  ]|
  
rules // QL expressions to WebDSL expressions
  
  compile-exp: Label(s) -> String(<try(un-double-quote)> s)
  compile-exp: Ref(qid) -> |[ form.x ]| where x := qid
  
  compile-exp: |[     !exp     ]| -> |[    !e    ]| where   e := <compile-exp> exp
  compile-exp: |[ exp1 && exp2 ]| -> |[ e1 && e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 || exp2 ]| -> |[ e1 || e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 <  exp2 ]| -> |[ e1 <  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 <= exp2 ]| -> |[ e1 <= e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 >  exp2 ]| -> |[ e1 >  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 >= exp2 ]| -> |[ e1 >= e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 == exp2 ]| -> |[ e1 == e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 +  exp2 ]| -> |[ e1 +  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 -  exp2 ]| -> |[ e1 -  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 *  exp2 ]| -> |[ e1 *  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
  compile-exp: |[ exp1 /  exp2 ]| -> |[ e1 /  e2 ]| where  e1 := <compile-exp> exp1; e2 := <compile-exp> exp2
