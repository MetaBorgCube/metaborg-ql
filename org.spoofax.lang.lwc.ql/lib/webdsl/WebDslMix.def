definition
module DeriveMix

imports
  WebDSL-Derive

exports

  context-free syntax
    "derivebodyelem" "|[" DeriveBodyElement "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "bodyelem" [0-9]*           -> DeriveBodyElement {prefer}
    "bodyelem_"[A-Za-z0-9]+     -> DeriveBodyElement {prefer}
    "bodyelem" [0-9]* "*"       -> DeriveBodyElement* {prefer}
    "bodyelem_"[A-Za-z0-9]+ "*" -> DeriveBodyElement* {prefer}

module StylingMix

imports
  WebDSL-Styling

exports

  context-free syntax
    "stsec"   "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleSection "]|" 				-> E {cons("ToMetaExpr")}
    "stsec*"  "|[" StyleSection* "]|" 				-> E {cons("ToMetaExpr")}
    "stdef"   "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
        "|[" StyleDefinition "]|" 			-> E {cons("ToMetaExpr")}
    "stdef*"  "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
          "|[" StyleDefinition* "]|" 			-> E {cons("ToMetaExpr")}
    "ststat"  "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
              "|[" StyleStatement "]|" 				-> E {cons("ToMetaExpr")}
    "ststat*" "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
              "|[" StyleStatement* "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl"  "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%              "|[" StyleDeclaration "]|" 			-> E {cons("ToMetaExpr")}
%%    "stdecl*" "|[" StyleDeclaration* "]|" 			-> E {cons("ToMetaExpr")}

  variables
    "stsec"   [0-9]* 	 -> StyleSection  {prefer}
    "stsec*"  [0-9]* "*" -> StyleSection  {prefer}
    "stdef" [0-9]*     	 -> StyleDefinition  {prefer}
    "stdef" [0-9]* "*"   -> StyleDefinition* {prefer}
    "ststat"  [0-9]*     -> StyleStatement  {prefer}
    "ststat"  [0-9]* "*" -> StyleStatement* {prefer}
    "stdecl"  [0-9]*     -> StyleDeclaration  {prefer}
    "stdecl"  [0-9]* "*" -> StyleDeclaration* {prefer}
       
  context-free syntax
    "stsel" "|[" Selector "]|" -> E {cons("ToMetaExpr")}
    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
%%    "stssel" "|[" SimpleSelector "]|" -> E {cons("ToMetaExpr")}
    "stcomb" "|[" Combinator "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector)* "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute) "]|" -> E {cons("ToMetaExpr")}
             "|[" (Combinator SimpleSelector SelectorAttribute)* "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "stsel" [0-9]*  		-> Selector {prefer}
    "stssel" [0-9]*  		-> SimpleSelector {prefer}
    "stcomb" [0-9]*  		-> Combinator {prefer}
    "stcombsel" [0-9]*  		-> (Combinator SimpleSelector) {prefer}
    
    "stmargs" [0-9]*  		-> MatchDefinitionArgs {prefer}
    "stmid"[0-9]* 			-> MatchIdent {prefer}
    [abc]"_"[A-Za-z0-9]+ 	-> MatchIdent {prefer}    

  context-free syntax
    "stprop"  "|[" StyleProperty "]|" 			-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StyleProperty* "]|" 			-> E {cons("ToMetaExpr")}
    "stprop"  "|[" StylePropertyValue "]|" 		-> E {cons("ToMetaExpr")}
    "stprop*" "|[" StylePropertyValue* "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleExpression "]|" 		-> E {cons("ToMetaExpr")}
              "|[" StyleValueExtension "]|" 		-> E {cons("ToMetaExpr")}
    "stval"   "|[" StyleValue "]|" 				-> E {cons("ToMetaExpr")}
    "stval*"  "|[" StyleValue* "]|" 				-> E {cons("ToMetaExpr")}

  variables
    "stprop" [0-9]*  	-> StyleProperty {prefer}
    "stprop" [0-9]* "*"  -> StyleProperty* {prefer}
    "stprop" [0-9]*  	-> StylePropertyValue {prefer}
    "stprop" [0-9]* "*"  -> StylePropertyValue* {prefer}
    "stexpr" [0-9]       -> StyleExpression {prefer}
    "stvalex" [0-9]       -> StyleValueExtension {prefer}
    "stval"  [0-9]*  	-> StyleValue {prefer}
    "stval"  [0-9]* "*"  -> StyleValue* {prefer}

module AccessControlMix

imports
  WebDSL-AccessControl

exports

  context-free syntax
    "acrule" "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlRule "]|" -> E {cons("ToMetaExpr")}
    "acdef"  "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}
             "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}


  variables
    "acrule" [0-9]*     -> AccessControlRule  {prefer}
    "acrule" [0-9]* "*" -> AccessControlRule* {prefer}
    "acdef"  [0-9]*     -> AccessControlDefinition  {prefer}
    "acdef"  [0-9]* "*" -> AccessControlDefinition* {prefer}
       
  context-free syntax
    "margs" "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
            "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
             
  variables
    "margs" [0-9]*  -> MatchArgs {prefer}
    
  context-free syntax
    "pexp"  "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}
            "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}        
             
  variables
    "pexp" [0-9]*  -> PolicyExp {prefer}
    
  variables
    "mid"[0-9]* -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+ -> MatchId {prefer}

module WebDSL-Recommend

imports
    WebDSL-Lexical
  
exports
    sorts Definition Annotation
  
context-free syntax

%% Dynamic ordering for WebDSL developers
RecommendConfig -> Definition
"recommend" Id "{" RecommendArgument* "}" -> RecommendConfig{cons("RecommendConfig")}
RecommendKey "=" RecommendKeyValue	-> RecommendArgument {cons("RecommendArgument")}

%% Static order implementation for back-end implementation
RecommendConfigStaticOrder -> Definition
"recommenderStaticOrder" Id "{" RecommendUser RecommendItem RecommendValue RecommendAlgorithm RecommendNeighborAlg RecommendNeighborSize RecommendType RecommendSchedule "}" -> RecommendConfigStaticOrder{cons("RecommendConfigStaticOrder")}

%% Static Order implementation
Id -> RecommendUser{cons("RecommendUser")}
Id -> RecommendItem{cons("RecommendItem")}
Id -> RecommendValue{cons("RecommendValue")}
Id -> RecommendAlgorithm{cons("RecommendAlgorithm")}
Id -> RecommendNeighborAlg{cons("RecommendNeighborAlg")}
Id -> RecommendNeighborSize{cons("RecommendNeighborSize")}
Id -> RecommendType{cons("RecommendType")}
Id -> RecommendSchedule{cons("RecommendSchedule")}

lexical syntax
  
%% Dynamic ordering, match to key-value type
"schedule" -> RecommendKey
"type" -> RecommendKey
"neighborhoodalg" -> RecommendKey
"neighborhoodsize" -> RecommendKey
"algorithm" -> RecommendKey
"user" -> RecommendKey
"item" -> RecommendKey
"value" -> RecommendKey
context-free syntax
Id -> RecommendKeyValue
Int -> RecommendKeyValue
TimeInterval -> RecommendKeyValue

module WebDSL-Search

imports
    WebDSL-Lexical

exports
    sorts Definition Annotation Exp

    context-free syntax

    FullTextAnalyzer                                            -> Definition

    DEFAULT? "analyzer" Id "{" FullTextAnalyzerBody "}"         -> FullTextAnalyzer{cons("FullTextAnalyzer")}

    FullTextAnalyzerBodyDef                                     -> FullTextAnalyzerBody

    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"
    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}"                -> FullTextAnalyzerBody{cons("DualFullTextAnalyzerBodyDef")}
    CharFilter* Tokenizer TokenFilter*                          -> FullTextAnalyzerBodyDef{cons("FullTextAnalyzerBodyDef")}

    "char filter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter")}
    "char filter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs")}

    "tokenizer" "=" TOKENIZERNAME "(" {Argument ","}* ")"       -> Tokenizer{cons("Tokenizer")}
    "tokenizer" "=" TOKENIZERNAME                               -> Tokenizer{cons("TokenizerNoArgs")}

    "token filter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter")}
    "token filter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs")}

    Id "=" String                                               -> Argument{cons("Argument")}

    Id    -> CHARFILTERNAME
    Id    -> TOKENIZERNAME
    Id    -> TOKENFILTERNAME

  context-free syntax

    %%searchable without params is left as SimpleAnno, but desugared to SearchableAnno,
    %%because "searchable" won't get rejected as Id (sdf strangeness).
    "searchable"                               -> SearchableAnno         {cons("SearchableAnno"), prefer}
    "searchable" "(" {SA-Argument ","}* ")"    -> SearchableAnno         {cons("SearchableAnno")}
    "search" "namespace"                       -> SearchNamespaceAnno    {cons("SearchNamespaceAnno"), prefer}
    SearchableAnno    "^" Float                -> Annotation             {cons("SearchableAnnoBoost")}
    SearchableAnno                             -> Annotation
    SearchNamespaceAnno                        -> Annotation

    SA-Key "=" SA-Value                        -> SA-Argument            {cons("SA-Argument")}
    "autocomplete"                             -> SA-Argument            {cons("Autocomplete-Argument")}
    "spellcheck"                               -> SA-Argument            {cons("Spellcheck-Argument")}
    "numeric"                                  -> SA-Argument            {cons("Numeric-Argument")}
    "default"                                  -> SA-Argument            {cons("DefaultSF-Argument")}

  context-free syntax
    SearchMapping                                    -> Definition
    SearchMappingEmbedded                            -> EntityBodyDeclaration
    "search" "mapping" "{" SearchMappingContent* "}"    -> SearchMappingEmbedded     {cons("SearchMappingEmbedded")}
    "search" "mapping" Id "{" SearchMappingContent* "}" -> SearchMapping             {cons("SearchMapping")}

    "namespace" "by" Id                              -> SearchMappingContent      {cons("SearchNamespaceMapping"), prefer}
    "namespace" "by" Id    ";"                       -> SearchMappingContent      {cons("SearchNamespaceMapping")}

    DEFAULTSF? KW MappingPart*    ";"                -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*    ";"        -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language
    DEFAULTSF? KW MappingPart*                       -> SearchMappingContent      {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*               -> SearchMappingContent      {cons("SearchFieldMapping")} %% more natural language

    "as" Id                                          -> MappingPart               {cons("FieldName")}
    "using" Id                                       -> MappingPart               {cons("AnalyzerName")}
    "boosted" "to" Float                             -> MappingPart               {cons("Boost")}
    "for" "subclass" Id                              -> MappingPart               {cons("TargetEntity")}
    "^" Float                                        -> MappingPart               {cons("Boost")}
    "(" {SearchMappingAnnoKW ","}* ")"               -> MappingPart               {cons("SearchMappingAnno")}
    "depth" Int                                      -> MappingPart               {cons("EmbeddedDepth")}
    "with" "depth" Int                               -> MappingPart               {cons("EmbeddedDepth")} %% more natural language

    Id           -> KW
    "as"         -> KW {reject}
    "using"      -> KW {reject}
    "boosted"    -> KW {reject}
    "by"         -> KW {reject}
    "with"       -> KW {reject}
    "index"      -> KW {reject}
    "depth"      -> KW {reject}
    "for"        -> KW {reject}

  lexical syntax
    "analyzer"                   -> SA-Key
    "name"                       -> SA-Key
    "boost"                      -> SA-Key
    "subclass"                   -> SA-Key
    "depth"                      -> SA-Key
    "default"                    -> DEFAULT
    "default_builtin_analyzer"   -> DEFAULT
    "+"                          -> DEFAULTSF
    Id                           -> SA-Value
    Float                        -> SA-Value
    Int                          -> SA-Value
    "spellcheck"                 -> SearchMappingAnnoKW
    "autocomplete"               -> SearchMappingAnnoKW
    "index"                      -> INDEXORQUERY
    "query"                      -> INDEXORQUERY

  context-free syntax

    SearcherDef                                      -> Exp

    "search" ENTITY SearcherPart*                    -> SearcherDef         {cons("SearcherInit")}
    "~" Exp SearcherPart+                            -> SearcherDef         {cons("SearcherRefMod")}

    ConstraintFilter    -> SearcherPart
    QueryDef            -> SearcherPart
    Offset              -> SearcherPart
    MaxResults          -> SearcherPart
    SortBy              -> SearcherPart
    FacetDef            -> SearcherPart
    SearchAttributes    -> SearcherPart
    NamespaceConstraint -> SearcherPart

    "matching" MatchGroup*                           -> QueryDef            {cons("QueryDef"),prefer}
    "offset"    Exp                                  -> Offset              {cons("Start")}
    "limit"    Exp                                   -> MaxResults          {cons("MaxResults")}
    "order" "by" {(SortExp) ","}+                    -> SortBy              {cons("SortBy")}
    "with" "filter" {(FilterConstraint) ","}+        -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "filters" {(FilterConstraint) ","}+       -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "facet" {FacetExp ","}+                   -> FacetDef            {cons("FacetDef")}
    "with" "facets" {FacetExp ","}+                  -> FacetDef            {cons("FacetDef")}
    "[" {SearchAttribute ","}* "]"                   -> SearchAttributes    {cons("SearchAttributes")}
    "in" "namespace" Exp                             -> NamespaceConstraint {cons("NamespaceConstraint")}

    "no" "lucene"                                    -> SearchAttribute    {cons("NoLucene")}
    "lucene"                                         -> SearchAttribute    {cons("Lucene")}
    "strict" "matching"                              -> SearchAttribute    {cons("DefaultAnd")}
    "loose" "matching"                               -> SearchAttribute    {cons("DefaultOr")}

    "(" FIELD "," Exp ")"                            -> FacetExp           {cons("DiscreteFacetDef")}
    "(" FIELD ":" {Range ","}* ")"                   -> FacetExp           {cons("RangeFacetDef")}

    FIELD ":" Exp                                    -> FilterConstraint   {cons("FieldFilterConstraint")}
    %% Exp                                              -> FilterConstraint   {cons("FacetFilterConstraint")}

    {FIELD "," }+ ":"                                -> FieldsConstraint   {cons("FieldsConstraint")}
    {QueryExp ","}+                                  -> QueryConstraint    {cons("QueryConstraint"), avoid}

    BoolOp? "(" MatchGroup+ ")"                      -> MatchGroup          {cons("Clause"),avoid}
    FieldsConstraint? QueryConstraint                -> MatchGroup          {cons("Query"), avoid}

    BoolOp? "(" QueryExp+ ")"                        -> QueryExp           {cons("GroupDef"), prefer}
    BoolOp? QueryTerm Slop?                          -> QueryExp           {cons("TermDef"), avoid}
    BoolOp? Range                                    -> QueryExp           {cons("RangeDef")}
    "~" Exp                                          -> Slop               {cons("Slop")}
    RangeOpen Exp? "to" Exp? RangeClose              -> Range              {cons("Range")}
    RangeOpen Exp? "TO" Exp? RangeClose              -> Range              {cons("Range")}
    "{"                                              -> RangeOpen          {cons("ExcludingOpen")}
    "}"                                              -> RangeClose         {cons("ExcludingClose")}
    "["                                              -> RangeOpen          {cons("IncludingOpen")}
    "]"                                              -> RangeClose         {cons("IncludingClose")}

    "+"                                              -> BoolOp             {cons("Must")}
    "-"                                              -> BoolOp             {cons("MustNot")}

    Exp                                              -> QueryTerm

    FIELD Direction?                                 -> SortExp            {cons("SortDef")}
    "asc"                                            -> Direction          {cons("Ascending")}
    "ascending"                                      -> Direction          {cons("Ascending")}
    "desc"                                           -> Direction          {cons("Descending")}
    "descending"                                     -> Direction          {cons("Descending")}

    "highlight" Exp "for" Exp "on" FIELD
        "surround" "with" "(" Exp "," Exp ")"        -> RetrievalExp       {cons("HighlightTags")}
    "highlight" Exp "for" Exp "on" FIELD             -> RetrievalExp       {cons("Highlight")}
    "results" "from"  Exp                            -> RetrievalExp       {cons("SearchResults")}
    FIELD "facets" "from" Exp                        -> RetrievalExp       {cons("FacetResults")}
    "all" FIELD "facets" "from" Exp                  -> RetrievalExp       {cons("AllFacetResults")}
    "count" "from" Exp                               -> RetrievalExp       {cons("SearchResultsSize")}
    "searchtime" "from" Exp                          -> RetrievalExp       {cons("SearchTimeString")}
    "~" Exp                                          -> FIELD              {cons("SearchFieldRef")}
    ENTITY SuggestType SuggestionPart+               -> Exp                {cons("Suggest")}
    "completions"                                    -> SuggestType        {cons("AutoComplete")}
    "corrections"                                    -> SuggestType        {cons("SpellCheck")}
    RetrievalExp                                     -> Exp

    "similarity" Exp                 -> SuggestionPart {cons("Similarity")}
    "matching" FieldsConstraint Exp  -> SuggestionPart {cons("SuggestTerm")}
    NamespaceConstraint              -> SuggestionPart
    MaxResults                       -> SuggestionPart

    %% disambiguate over Var("") terms allowed by QueryTerm and SearcherPart keywords, dont allow keywords to be used as varref
    SearcherKW             -> QueryTerm {reject}
    SearcherKW "(" Exp ")" -> QueryTerm {reject}
    "[" {Exp ","}* "]"     -> QueryTerm {reject}

  context-free restrictions
    %% Don't treat -200 as 'must not match 200', but as int '-200' instead
    BoolOp  -/- [0-9]
    %% 'matching tags.name: +tag.replace(" ","\\ ")' , interpret as method call, not as field/prop access followed by a new clause
    QueryTerm -/- [\(]

  context-free priorities
    %% search User matching credit: -(-200) //interpret as 'must not match -200'
    Exp -> QueryTerm
    >
    "(" Exp ")"  -> Exp

  context-free priorities
  %% search Movie matching +"hello" -"goodbye" //Dont treat this as sub
  %% search Movie matching +book.title  //Dont treat '.title' as method-call/property access for whole searcher exp, but restrict to inner exp 'book'.
    {QueryExp ","}+ -> QueryConstraint
    >
    {
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
      Exp "." Id "(" {Exp ","}* ")"  -> Exp
      Exp "." Id                     -> Exp
    }
    >
    {
    RetrievalExp -> Exp
    SearcherDef -> Exp
    }

  lexical syntax
    Id             -> FIELD
    Id "." FIELD   -> FIELD
    Id             -> ENTITY
    Id             -> SEARCHERREF
    "limit"            -> SearcherKW
    "offset"           -> SearcherKW
    "with"             -> SearcherKW
    "order"            -> SearcherKW
    "in"               -> SearcherKW
    "matching"         -> SearcherKW

 context-free restrictions
    "as" "asc" "ascending" "analyzer" "autocomplete" "boost" "boosted" "by"           -/- [a-zA-Z0-9]
    "desc" "descending" "default" "default_builtin_analyzer" "depth" "extend" "for"   -/- [a-zA-Z0-9]
    "facet" "facets" "from" "get" "highlight" "index" "limit"                         -/- [a-zA-Z0-9]
    "matching" "name" "namespace" "nolucene" "on" "query"                             -/- [a-zA-Z0-9]
    "results" "search" "sort" "spellcheck" "start" "subclass"                         -/- [a-zA-Z0-9]
    "using" "with" "where"                                                            -/- [a-zA-Z0-9]


%% DEPRECATED:
  context-free syntax
    "searchmapping" "{" SearchMappingContent* "}"               -> SearchMappingEmbedded{cons("SearchMappingEmbedded"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "searchmapping" Id "{" SearchMappingContent* "}"            -> SearchMapping{cons("SearchMapping"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "charfilter" "=" CHARFILTERNAME "(" {Argument ","}* ")"     -> CharFilter{cons("CharFilter"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "charfilter" "=" CHARFILTERNAME                             -> CharFilter{cons("CharFilterNoArgs"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "tokenfilter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"   -> TokenFilter{cons("TokenFilter"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "tokenfilter" "=" TOKENFILTERNAME                           -> TokenFilter{cons("TokenFilterNoArgs"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}

module WebDSL-Service

exports

  context-free syntax

     "service" Id "(" {FormalArg ","}* ")" 
        Block                                      -> Definition {cons("ServiceFunction")}

module WebDSL-TimeInterval

imports
  WebDSL-Lexical
  WebDSL-Action

exports

  context-free syntax
    Exp "weeks"        -> TimeIntervalPart {cons("Weeks")}
    Exp "days"         -> TimeIntervalPart {cons("Days")}
    Exp "hours"        -> TimeIntervalPart {cons("Hours")}
    Exp "minutes"      -> TimeIntervalPart {cons("Minutes")}
    Exp "seconds"      -> TimeIntervalPart {cons("Seconds")}
    Exp "milliseconds" -> TimeIntervalPart {cons("Milliseconds")}
    TimeIntervalPart*  -> TimeInterval {cons("TimeInterval")}

  context-free syntax
    "invoke" Exp "every" TimeInterval  -> Definition {cons("InvokeEvery")}

module WebDSL-Test

exports

context-free syntax

  "test" Id Block -> Definition {cons("Test")}
  "test" Block -> Definition {ast("Test(\"\",<1>)")}

module WebDSL-Type

exports

  context-free syntax
  
    %%  Construct for creating custom value types, and altering the existing value types.
    %%
    %%  example: 
    %%    type String { validate(this.length() <= 255 , "input too long (max 255 characters)") }
    %%    type USDate : Date { format = "MM/dd/yyyy" }
    %% 
    %%  Will also need to cope with input/output decode/encode.
    %%

    "type" Id "{" TypeProperty* "}" -> Definition {cons("TypeDef")}
    
    Annotation -> TypeProperty {cons("TypeDefAnno")}
    
    NativeClassFunction -> TypeProperty
    %%solve ambiguities
    "static" -> TypeProperty {reject}
    
    QId "as" NativeClassFunction -> TypeProperty{cons("NativeClassFunctionFromStatic")}

module WebDSL-Exception

exports

  context-free syntax
  
    %%
    %%  Exceptions, for supporting data validation
    %%
    %%  example: 
    %%  entity ValidationException{message:String}
    %%  throw ValidationException{ message := "error" }
    %%  try{}catch(ve : ValidationException){}
    %%  throw ValidationException{ message := "error1" }, ValidationException{ message := "error2" }
    %%  try{}catch(l : List<ValidationException>)

    "throw" {Exp ","}+ ";" -> Statement {cons("ThrowStatement"), prefer}
    "throw" {Exp ","}+     -> TemplateCall {cons("ThrowTemplate"), prefer}
    
    "try" Block Catch+ -> Statement {cons("TryStatement"), prefer}
    "try" Block Catch+ -> TemplateCall {cons("TryTemplate"), prefer}
    
    "catch" "(" Id ":" Sort ")" Block -> Catch {cons("Catch")}

module WebDSL-Dispatch

exports

  sorts DispatchEntry DispatchBody DispatchArg

  context-free syntax

    "dispatch" "{" DispatchEntry* DispatchEntryDefault "}" -> TemplateElement {cons("Dispatch")}

    "dispatch" "{" TemplateElement* "}" -> TemplateCall {reject}

    
    
    Id "(" {FormalArg ","}* ")" "{" TemplateElement* "}" -> DispatchEntry {cons("DispatchEntry")}
    Id "{" TemplateElement* "}" -> DispatchEntry {cons("DispatchEntryNoArg")}
    
    Id ":" Sort "{" TemplateElement* "}" -> DispatchEntry {cons("DispatchEntity")}
     
    "default" "{" TemplateElement* "}" -> DispatchEntryDefault {cons("DispatchDefault")}
    -> DispatchEntryDefault {cons("None")}
  
    "default" "(" {FormalArg ","}* ")" "{" TemplateElement* "}" -> DispatchEntry {reject}
    "default" "{" TemplateElement* "}" -> DispatchEntry {reject}
    
    
    %%dispatch {
    %%  create            { createJournal() }
    %%  journal : Journal { thejournal(journal) }
    %%  default           { "unknown journal" }
    %%}
    
    
    
    "navigate" "(" {DispatchNavigateCall "/"}+ ")" "{" TemplateElement* "}" -> DispatchNavigate {cons("DispatchNavigate")}
    "navigate" "(" Exp "," {DispatchNavigateCall "/"}+ ")" -> DispatchNavigateButton {cons("DispatchNavigateButton")}
    DispatchNavigate -> TemplateElement
    DispatchNavigateButton -> TemplateElement    
    %% should be at least two arguments, otherwise dispatch has no function, reject rules below prevent one argument from being becoming a DispatchNavigate
    "navigate" "(" Id "(" {Exp ","}* ")" ")" "{" TemplateElement* "}"      -> DispatchNavigate {reject}
    "navigate" "(" Exp "," Id "(" {Exp ","}* ")" ")" "{" TemplateElement* "}"      -> DispatchNavigateButton {reject}
    %%can also be parsed as a division of the results of functions calls, needs reject
    "navigate" "(" Exp "/" Exp ")" TemplateBody -> TemplateCall {reject}
    "navigate" "(" Exp "," Exp "/" Exp ")" TemplateBody -> TemplateCall {reject}
    
    Id "(" {Exp ","}* ")" -> DispatchNavigateCall {cons("DispatchNavigateCall")}
    Id  -> DispatchNavigateCall {cons("DispatchNavigateCallNoArg")}

module WebDSL-Native

imports
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "native" "function" Id "(" {FormalArg ","}* ")" ":" Sort ";" -> NativeFunctionDeclaration {cons("NativeFunction")}

context-free syntax

  "native" "class" QId NativeClassAlias NativeClassSuper "{" NativeClassElement* "}" -> NativeClassDeclaration {cons("NativeClass")}
  
  "as" Id -> NativeClassAlias{cons("NativeClassAlias"),prefer}
  -> NativeClassAlias{cons("None")}
  
  ":" Id -> NativeClassSuper{cons("NativeClassSuper"),prefer}
  -> NativeClassSuper{cons("None")}
  
context-free syntax %%properties
  
  Id ":" NativeType -> NativeClassElement{cons("NativeClassProperty")}
  
context-free syntax %%functions  
  
  NativeClassFunction -> NativeClassElement
  
  NativeClassFunctionStatic Id "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassFunction{cons("NativeClassFunction")}
  "constructor" "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassElement{reject}

  ":" NativeType ->  NativeClassFunctionReturn{cons("NativeClassFunctionReturn"),prefer}
  ->  NativeClassFunctionReturn{cons("None")}
  
  "static" ->  NativeClassFunctionStatic{cons("NativeClassFunctionStatic"),prefer}
  ->  NativeClassFunctionStatic{cons("None")}
      
  QId "as" NativeClassFunction -> NativeClassElement{cons("NativeClassFunctionFromStatic")}

  "constructor" "(" {NativeType ","}* ")" -> NativeClassElement{cons("NativeClassConstructor")}
  
  Id "<" {NativeType ","}* ">" -> NativeType{cons("NativeGenericType")}
  Id -> NativeType{cons("NativeSimpleType")}

module WebDSL-ValidationAnnos

exports
  sorts Annotation PatternFlag

  context-free syntax
	%%string
    "length" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoLength"),prefer}
    "minlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMinLength"),prefer}   
    "maxlength" "(" Int ")"                   -> Annotation {cons("ValidationAnnoMaxLength"),prefer}    
 	"notempty"                                -> Annotation {cons("ValidationAnnoNotEmpty"),prefer}  
  	"email"                                   -> Annotation {cons("ValidationAnnoEmail"),prefer} 	 
  	"creditcardnumber"                        -> Annotation {cons("ValidationAnnoCreditCardNumber"),prefer} 	
 	"EAN"                                     -> Annotation {cons("ValidationAnnoEAN"),prefer} 
  	"pattern" "(" String ")"                  -> Annotation {cons("ValidationAnnoPattern"),prefer}   
  	"pattern" "(" String "," PatternFlag* ")" -> Annotation {cons("ValidationAnnoPatternWithFlags"),prefer}
  	
  	"canonicalequivalence"                    -> PatternFlag {cons("FlagCanonEq")} %% CANON_EQ Enables canonical equivalence.    
	"caseinsensitive"                         -> PatternFlag {cons("FlagCaseInsensitive")} %% CASE_INSENSITIVE Enables case-insensitive matching.
 	"comments"                                -> PatternFlag {cons("FlagComments")} %% COMMENTS Permits whitespace and comments in pattern.
 	"dotall"                                  -> PatternFlag {cons("FlagDotAll")} %% DOTALL Enables dotall mode.
 	"literal"                                 -> PatternFlag {cons("FlagLiteral")} %% LITERAL Enables literal parsing of the pattern.
 	"multiline"                               -> PatternFlag {cons("FlagMultiline")} %% MULTILINE Enables multiline mode.
 	"unicodecase"                             -> PatternFlag {cons("FlagUnicodeCase")} %% UNICODE_CASE Enables Unicode-aware case folding.
 	"unixlines"                               -> PatternFlag {cons("FlagUnixLines")} %% UNIX_LINES Enables Unix lines mode.
                 
	%%numeric or string representation of numeric
	"max" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMax"),prefer} 
	"min" "(" Int ")"                         -> Annotation {cons("ValidationAnnoMin"),prefer}
    "range" "(" Int "," Int ")"               -> Annotation {cons("ValidationAnnoRange"),prefer}
    "minrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMinRange"),prefer}   
    "maxrange" "(" Int ")"                    -> Annotation {cons("ValidationAnnoMaxRange"),prefer} 
    "digits" "(" Int "," Int ")"              -> Annotation {cons("ValidationAnnoDigits"),prefer}  
     
	%%date/calendar
	"past"                                    -> Annotation {cons("ValidationAnnoPast"),prefer} 
	"future"                                  -> Annotation {cons("ValidationAnnoFuture"),prefer} 	
	
	%%array, collection, map	
    "size" "(" Int "," Int ")"                -> Annotation {cons("ValidationAnnoSize"),prefer}
    "minsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMinSize"),prefer}   
    "maxsize" "(" Int ")"                     -> Annotation {cons("ValidationAnnoMaxSize"),prefer} 
    
	%%object
  	"notnull"                                 -> Annotation {cons("ValidationAnnoNotNull"),prefer }
  	"asserttrue"                              -> Annotation {cons("ValidationAnnoAssertTrue"),prefer} 
  	"assertfalse"                             -> Annotation {cons("ValidationAnnoAssertFalse"),prefer} 
   	"valid"                                   -> Annotation {cons("ValidationAnnoValid"),prefer}

module WebDSL-Procedures

imports
  WebDSL-AccessControl
  WebDSL-UI
  WebDSL-DataModel
  WebDSL-Action
  WebDSL-Lexical

exports
  sorts Section Definition

  context-free syntax

	"procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("Procedure")}

	"auto" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Procedure {cons("AutoProcedure")}

  "extend" "procedure" Id "(" FormalArg ")" "{"
	   ProcedureElement* 
	"}"                             -> Definition {cons("ExtendProcedure")}

  Procedure                       -> Definition

	"who" "{" Exp "}"               -> ProcedureElement {cons("ProcedureWho")}
	"when" "{" Exp "}"					    -> ProcedureElement {cons("ProcedureWhen")}
	"do" Block							        -> ProcedureElement {cons("ProcedureDo")}
	"done" Block							      -> ProcedureElement {cons("ProcedureDone")}
	"enabled" Block							    -> ProcedureElement {cons("ProcedureEnabled")}
	"disabled" Block						    -> ProcedureElement {cons("ProcedureDisabled")}
	"view" "{" TemplateElement* "}" -> ProcedureElement {cons("ProcedureView")}
	
	"process" "{" ProcessExp "}"    -> ProcedureElement {cons("ProcedureProcess")}
	"processed" Block							  -> ProcedureElement {cons("ProcedureProcessed")}
	
  sorts ProcessExp
  
context-free syntax
    
    Id "(" Exp ")"                -> CallProcessExp {cons("ProcCall")} 
    CallProcessExp                -> ProcessExp                        
    ProcessExp ";" ProcessExp     -> ProcessExp {cons("ProcSeq"), left}
    
    "while" "(" Exp ")" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcWhile")}
    
    "repeat" "{" 
      ProcessExp 
    "}" "until" CallProcessExp    -> ProcessExp {cons("ProcRepeatUntil")}

    "if" "(" Exp ")" "{" 
      ProcessExp 
     "}"                          -> ProcessExp {cons("ProcIfNoElse")}
    
    "if" "(" Exp ")" "{" 
      ProcessExp 
    "}" "else" "{" 
      ProcessExp 
    "}"                           -> ProcessExp {cons("ProcIf")}
    
    ProcessExp "xor" ProcessExp   -> ProcessExp {cons("ProcXor"), left}
    ProcessExp "and" ProcessExp   -> ProcessExp {cons("ProcAnd"), left}
    
    ProcessExp "+" ProcessExp     -> ProcessExp {cons("ProcPlus"), left}
    
    "(" ProcessExp ")"            -> ProcessExp {bracket}
  
  context-free priorities  
      {left:
        ProcessExp "and" ProcessExp  -> ProcessExp}
    > {left:
        ProcessExp "xor" ProcessExp  -> ProcessExp
        ProcessExp "+"   ProcessExp  -> ProcessExp }
    > {left:
        ProcessExp ";"   ProcessExp  -> ProcessExp {cons("ProcSeq"), left}}

module WebDSL-Derive

imports
  WebDSL-UI
  WebDSL-Lexical

exports

  sorts Derive DeriveType DeriveProperty

context-free syntax

  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")"                               -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp            -> TemplateElement {cons("Derive"), prefer}
  %%"derive" Id                       -> TemplateElement {cons("Derive"), prefer}
  %% Disabled this one for now because it is causing ambiguities, have a look at this Ruben!
  
  "derive" Id "from" Exp "for" "(" 
    {DeriveProperty ","}* 
  ")" DeriveBody                    -> TemplateElement {cons("Derive"), prefer}
  "derive" Id "from" Exp DeriveBody -> TemplateElement {cons("Derive"), prefer}
  "derive" Id DeriveBody            -> TemplateElement {cons("Derive"), prefer}
  
  Id                                -> DeriveProperty {cons("DeriveDefault")}
  Id "(" Id ")"                     -> DeriveProperty {cons("DeriveMode")}
  
  "{" DeriveBodyElement* "}"        -> DeriveBody {cons("DeriveBody")}
  
  Id "{" TemplateElement* "}"       -> DeriveBodyElement {cons("DeriveBodyElement")}
  
  "derive"                          -> TemplateCall {reject}
    
  "derive" "crud" Id -> Definition {cons("DeriveCrud")}
  "derive" "CRUD" Id -> Definition {cons("DeriveCrud")}

module WebDSL-PagedFor

imports
  WebDSL-UI

exports
  sorts TemplateElement

  context-free syntax

    "for" "(" Id ":" Sort Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAll")}

    "for" "(" Id ":" Sort "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForAllNoFilter")}

    "for" "(" Id ":" Sort "in" Exp Filter "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedFor")}

    "for" "(" Id ":" Sort "in" Exp "per" Exp ")"
       "{" TemplateElement* "}"                             -> TemplateElement {cons("PagedForNoFilter")}

module WebDSL-Styling

%% syntax for styling of WebDSL applications
imports
  WebDSL-UI
  WebDSL-Lexical

exports

  sorts
    Name StNum String UnaryOperator

  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_\-]*			-> Identifier
    [a-zA-Z][a-zA-Z\-\_]+          		-> ValueName
    [a-z][a-z\-]+           	   		-> Value
    [a-f0-9][a-f0-9][a-f0-9][a-f0-9]* 		-> Hex
    [a-z\%]+                       		-> Unit
%%    [0-9]+                			-> StNum
%%    [0-9]* "." [0-9]+     			-> StNum
    "'" ~[\"\n]* "'"               		-> String
%%    [\-\+] StNum				-> StNumber

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*		 -> MatchIdent
%%    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchIdent
%%    [\*]                        -> MatchIdent
%%    [\*]                        -> StWildCardArg 

  lexical restrictions
    ValueName 	-/- [a-zA-Z\-\_]
    Value 	-/- [a-z\-]
    Unit 	-/- [a-z\%]
    Hex 	-/- [a-f0-9]

exports

  sorts
     StNumber

  lexical syntax
    Float		      -> StNum
    SignedInteger	      -> StNum
    StNum                     -> StNumber
    StNum "%"                 -> Percentage {prefer}
    StNum "em"                -> Ems {prefer}
    StNum "ex"                -> Exs {prefer}
    StNum "px"                -> Length {prefer}
    StNum "cm"                -> Length {prefer}
    StNum "mm"                -> Length {prefer}
    StNum "in"                -> Length {prefer}
    StNum "pt"                -> Length {prefer}
    StNum "pc"                -> Length {prefer}
    StNum "deg"               -> Angle {prefer}
    StNum "rad"               -> Angle {prefer}
    StNum "grad"              -> Angle {prefer}
    StNum "ms"                -> Time {prefer}
    StNum "s"                 -> Time {prefer}
    StNum "hz"                -> Freq {prefer}
    StNum "khz"               -> Freq {prefer}
%%    StNum Id                  -> Dimension {prefer}

context-free syntax

  "theme" Modifier Id "(" ")" "{" StyleDeclaration* "}" -> Definition {cons("ThemeDefinition"), prefer}

context-free syntax %% Styling syntax

  "style" Id StyleDefinition*        -> Section {cons("StyleSection"), prefer}

  Selector "{" StyleStatement* "}"   -> StyleDefinition {cons("StyleDefinition")}

context-free syntax %% selectors

  SimpleSelector
    (Combinator SimpleSelector SelectorAttribute?)* -> Selector {cons("Selector")}

  Id MatchDefinition 			-> SimpleSelector {cons("SimpleSelector")}
  "#" Identifier			-> SimpleSelector {cons("IdSimpleSelector")}
  Id					-> SimpleSelector {cons("ElemSimpleSelector")}
  Id SelectorAttribute+		-> SimpleSelector {cons("ElemSimpleAttrSelector"), prefer}
  Id "." Identifier	SelectorAttribute+		-> SimpleSelector {cons("ElemClassAttrSelector"), prefer}
  "." Identifier 			-> SimpleSelector {cons("ClassSimpleSelector")}  
  MatchDefinition       		-> SimpleSelector {cons("SimpleSelector")}
  "*"			        	-> SimpleSelector {cons("UniversalSimpleSelector")}
  
  ":" ValueName				-> SelectorAttribute {cons("SelectorAttribute")}
  
  ">"                   		-> Combinator {cons("ChildCombinator")}
  ">>"                   		-> Combinator {cons("DescendantCombinator"), prefer}

  MatchIdent "(" MatchDefinitionArgs ")"		-> MatchDefinition {cons("MatchDefinition")}
  {FormalArg ","}*                                      -> MatchDefinitionArgs

  "const" Id ":" StyleSort ";" 				-> StyleVarDecl {cons("StyleVarDecl")}
  "const" Id ":" StyleSort ":=" StyleExpression ";" 	-> StyleVarDecl {cons("StyleVarDeclInit")}
  
  StyleVarDecl						-> StyleDefinition
  
  StyleProperty ":=" StyleExpression ";"      	        -> StyleStatement {cons("StyleDeclaration")}
%%  StylePropertyLocal ":=" StyleProperty ";"    	-> StyleStatement {cons("StyleDeclaration")}

  ValueName						-> StyleProperty {cons("StyleProperty")}

  MatchDefinition "." StyleProperty			-> StyleExpression {cons("StylePropertyValue")}

  Id 							-> StyleExpression {cons("StyleVar")}

  StyleValue 						-> StyleExpression
%%  StyleValues -> StyleExpression

  "(" Selector ")" "." StyleProperty 			-> StyleExpression {cons("StyleValueExpression")}

  StyleExpression "+" StyleExpression 			-> StyleExpression {cons("StyleAdd"),assoc}
  StyleExpression "-" StyleExpression 			-> StyleExpression {cons("StyleSub"),assoc}
  StyleExpression "*" StyleExpression 			-> StyleExpression {cons("StyleMul"),assoc}
  StyleExpression "/" StyleExpression 			-> StyleExpression {cons("StyleDiv"),assoc}

  StNumber Unit 					-> StyleValue {cons("StyleValue")}
  StNumber 						-> StyleValue {cons("StyleValue")}
  StyleSort StyleValueExtension+			-> StyleValue {cons("StyleValue")}
  Uri 							-> StyleValue {cons("StyleValue")}
  Hash 							-> StyleValue {cons("StyleValue")}
  Value		 					-> StyleValue {cons("StyleValue"), prefer}
  String	 					-> StyleValue {cons("StyleValue")}
  
  "." ValueName						-> StyleValueExtension {cons("StyleValueExtension") }

%%  {StyleValue "|"}* -> StyleValue {cons("StyleValueOptions") }

  Id Unit 						-> StyleSort {cons("StyleSort")}
  Id							-> StyleSort {cons("StyleSort")}

  "url" "(" String ")"    				-> Uri {cons("Uri")}
  "#" Hex                 				-> Hash {cons("Hash")}

  "const" 	-> Id {reject}  
%%  "layout" 	-> Id {reject}
%%  "style" 	-> Id {reject}
%%  "theme" 	-> Id {reject}

context-free priorities
  
  {left:
       StyleExpression "*" StyleExpression -> StyleExpression
       StyleExpression "/" StyleExpression -> StyleExpression }
  > {left:
       StyleExpression "+" StyleExpression -> StyleExpression
       StyleExpression "-" StyleExpression -> StyleExpression}

context-free syntax %% Layout syntax

  "layout" LayoutDefinition* 				-> Section {cons("LayoutSection"), prefer}

  Id MatchDefinition "{" LayoutStatement* "}"   	-> LayoutDefinition {cons("LayoutDefinition")}
  MatchDefinition "{" LayoutStatement* "}"   		-> LayoutDefinition {cons("LayoutDefinition")}
  
  StyleDefinition					-> LayoutDefinition
%%  StyleStatement					-> LayoutStatement
  
  "float" "{" MatchDefinition* "}" ";"			-> LayoutStatement {cons("FloatStatement")}
  
  LayoutExpression ";"                                  -> LayoutStatement {cons("LayoutStatement")}
  Id ":" "[" LayoutExpressions "]"     		        -> LayoutExpression {cons("NamedLayoutExpression")}
  {LayoutExpression "|"}+				-> LayoutExpressions
  Id			 				-> LayoutExpression {cons("LayoutExpression")}
  MatchDefinition 					-> LayoutExpression {cons("LayoutExpression")}

module WebDSL-Enums

imports
  WebDSL-DataModel
  WebDSL-Lexical

exports
  sorts Defintion EnumValue

  context-free syntax

  "enum" Id "{" {EnumValue ","}* "}"                    -> Definition {cons("Enum")}

  Id "(" String ")"                               -> EnumValue {cons("EnumValue")}

module WebDSL-Regex


exports
%%d  context-free start-symbols
%%d    PatternDecl Pattern
  sorts Pattern PatternDecl Exp
  context-free syntax
    RegexExp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")} %% always used with a call, regex directly as exp results in ambiguity with xml embedding

    "/" Pattern "/"            -> RegexExp { cons("RegexPattern") }
    Branche                    -> Pattern {cons("SingleBranch")}
    Pattern "|" Pattern        -> Pattern {cons("TupleBranch"), right, prefer}


  sorts Branche
  context-free syntax
    Piece+                     -> Branche {cons("Pieces")}

  sorts Piece
  context-free syntax
    Atom                       -> Piece {cons("SingleAtom")}
    Atom Quantifier            -> Piece {cons("QuantifiedAtom")}

  sorts Quantifier
  context-free syntax
   "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
   "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
   "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
   "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
   "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
   "+"                          -> Quantifier {cons("GreedyOneOrMore")}
   "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
   "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
   "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
   "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
   "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
   "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}  
   "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
   "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
   "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
   "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
   "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
   "++"                         -> Quantifier {cons("PossessiveOneOrMore")}   

  sorts Atom
  context-free syntax
    "("   Pattern ")"          -> Atom {cons("Capture")}
    "(?:" Pattern ")"          -> Atom {cons("NonCapture")}
    "(?=" Pattern ")"          -> Atom {cons("PositiveLookahead")}
    "(?!" Pattern ")"          -> Atom {cons("NegativeLookahead")}
    "(?<=" Pattern ")"         -> Atom {cons("PositiveLookbehind")}
    "(?<!" Pattern ")"         -> Atom {cons("NegativeLookbehind")}
    "(?P<" RegexId ">" Pattern ")"  -> Atom {cons("PythonCapture")}
    "(" Pattern ")@{" RegexId "}"   -> Atom {cons("RegexCapture")}
    "()"                       -> Atom {cons("Empty")}
    "."                        -> Atom {cons("SingleCharacter")}
    "^"                        -> Atom {cons("LineStart")}
    "$"                        -> Atom {cons("LineEnd")}
    CharacterClass             -> Atom {cons("CharacterClass")}
    AtomLiteral                -> Atom {cons("AtomLiteral")}
    AtomCharacter              -> Atom {cons("AtomCharacter")}
    "\\Q" AllChars "\\E"       -> Atom {cons("QuotedAtom")}    
    
  sorts CharacterClass BracketItem
  context-free syntax
    "[" BracketItem+ "]"       -> CharacterClass {cons("BracketList")}
    "[^" BracketItem+ "]"      -> CharacterClass {cons("NegatedBracketList")}
%%d "\\p\{" ClassKeyword "\}"   -> CharacterClass {cons("PredefineClass")}
%%d "\\P\{" ClassKeyword "\}"   -> CharacterClass {cons("NegatedPredefineClass")}
   

    (BracketLiteral | BracketCharacter)
     "-" 
    (BracketLiteral | BracketCharacter)   -> BracketItem {cons("Range")}
    CharacterClass                        -> BracketItem {cons("Union")}
%%d "\&\&" CharacterClass                 -> BracketItem {cons("Intersection")}
    BracketLiteral                        -> BracketItem {cons("BracketLiteral")}
    BracketCharacter                      -> BracketItem {cons("BracketCharacter")}
   

%%
 %%   Defining characterclasses
  %% 
sorts ClassKeyword
  context-free syntax    
    "Lower"                    -> ClassKeyword {cons("LowerClass")}
    "Upper"                    -> ClassKeyword {cons("UpperClass")}
    "ASCII"                    -> ClassKeyword {cons("ASCIIClass")}
    "Alpha"                    -> ClassKeyword {cons("AlphaClass")}
    "Digit"                    -> ClassKeyword {cons("DigitClass")}
    "Alnum"                    -> ClassKeyword {cons("AlnumClass")}
    "Punct"                    -> ClassKeyword {cons("PunctClass")}
    "Graph"                    -> ClassKeyword {cons("GraphClass")}
    "Print"                    -> ClassKeyword {cons("PrintClass")}
    "Blank"                    -> ClassKeyword {cons("BlankClass")}
    "Cntrl"                    -> ClassKeyword {cons("CntrlClass")}
    "XDigit"                   -> ClassKeyword {cons("XDigitClass")}
    "Space"                    -> ClassKeyword {cons("WhiteSpace")}
    "javaLowerCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaUpperCase"            -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaWhitespace"           -> ClassKeyword {cons("JavaIsWhitespace")}
    "javaMirrored"             -> ClassKeyword {cons("JavaIsMirrored")}
    "InGreek"                  -> ClassKeyword {cons("GreekBlock")}
    "Lu"                       -> ClassKeyword {cons("UppercaseLetter")}
    "Sc"                       -> ClassKeyword {cons("CurrencySymbol")}

%%
 %%   Defining the Character -> Characters that appear as Atom and in Brackets  
  %%   

%%  ASCII characters:  
%%  $*+?.{}()                             %% OnlyBranchSpecial
%%  &]-                                   %% OnlyClassSpecial
%%  [^\                                   %% AlwaysSpecial
%%  !"#%',/:;<=>@_`~                      %% NeverSpecialCharacter
%%  ABCDEFGHIJKLMNOPQRSTUVWXYZ            %% Character
%%  abcdefghijklmnopqrstuvwxyz            %% Charater
%%  0123456789                            %% Charater
%%  <tab> <newline> <return> <form-feed>  %% SpecialEscapeCharacter


  sorts BracketLiteral AtomLiteral AllChars
  lexical syntax
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]
                                                  -> BracketLiteral
    "/"                                           -> BracketLiteral 
    [\&\]\-]                                      -> BracketLiteral {reject}
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]
                                                  -> AtomLiteral
    "/"                                           -> AtomLiteral 
    [\}\)\|\[]                                    -> AtomLiteral {reject}
    
    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]*              
          -> AllChars
    "/"   -> AllChars
    "\""  -> AllChars {cons("DoubleQuote") } 
      
  sorts BracketCharacter AtomCharacter
  context-free syntax
%%d    "\{"                -> BracketCharacter {cons("CurlyBraceOpen") }
%%d    "\{"                -> AtomCharacter    {cons("CurlyBraceOpen"), avoid}
    "\""                -> BracketCharacter {cons("DoubleQuote") }
    "\""                -> AtomCharacter    {cons("DoubleQuote") }
%%d    "\)"                -> BracketCharacter {cons("BraceClose"), avoid }
%%d    "\)"                -> AtomCharacter    {cons("BraceClose") }


%%
 %%   Escaping with a '\' to express a special character
  %%
  context-free syntax
    "\\0" OctalValue       -> BracketCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> BracketCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> BracketCharacter {cons("DecHexChar")}
    "\\t"                  -> BracketCharacter {cons("Tab")}
    "\\n"                  -> BracketCharacter {cons("Newline")}
    "\\r"                  -> BracketCharacter {cons("Return")}
    "\\f"                  -> BracketCharacter {cons("Formfeed")}
    "\\a"                  -> BracketCharacter {cons("Alarm")}
    "\\e"                  -> BracketCharacter {cons("Escape")}
    "\\w"                  -> BracketCharacter {cons("WordChar")}
    "\\W"                  -> BracketCharacter {cons("NonWordChar")}
    "\\s"                  -> BracketCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> BracketCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> BracketCharacter {cons("DigitChar")}
    "\\D"                  -> BracketCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> BracketCharacter {cons("ControlCharacter")}
    "\\b"                  -> BracketCharacter {cons("WordBoundry")}
    "\\B"                  -> BracketCharacter {cons("NonWordBoundry")}
    "\\A"                  -> BracketCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> BracketCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> BracketCharacter {cons("EndInputBoundry")}
    "\\z"                  -> BracketCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> BracketCharacter {cons("BackReference")}
    "\\ "                  -> BracketCharacter {cons("Space")}
    "\\\t"                 -> BracketCharacter {cons("Tab")}
%%d    "\\\r"                 -> BracketCharacter {cons("Return")}
    "\\\n"                 -> BracketCharacter {cons("Newline")}
    
    "\\0" OctalValue       -> AtomCharacter {cons("OctalChar")}
    "\\x" TwoHexValue      -> AtomCharacter {cons("HexHexChar")}
    "\\u" FourHexValue     -> AtomCharacter {cons("DecHexChar")}
    "\\t"                  -> AtomCharacter {cons("Tab")}
    "\\n"                  -> AtomCharacter {cons("Newline")}
    "\\r"                  -> AtomCharacter {cons("Return")}
    "\\f"                  -> AtomCharacter {cons("Formfeed")}
    "\\a"                  -> AtomCharacter {cons("Alarm")}
    "\\e"                  -> AtomCharacter {cons("Escape")}
    "\\w"                  -> AtomCharacter {cons("WordChar")}
    "\\W"                  -> AtomCharacter {cons("NonWordChar")}
    "\\s"                  -> AtomCharacter {cons("WhiteSpaceChar")}
    "\\S"                  -> AtomCharacter {cons("NonWhiteSpaceChar")}
    "\\d"                  -> AtomCharacter {cons("DigitChar")}
    "\\D"                  -> AtomCharacter {cons("NonDigitChar")}
    "\\c" ControlValue     -> AtomCharacter {cons("ControlCharacter")}
    "\\b"                  -> AtomCharacter {cons("WordBoundry")}
    "\\B"                  -> AtomCharacter {cons("NonWordBoundry")}
    "\\A"                  -> AtomCharacter {cons("InputBeginBoundry")}
    "\\G"                  -> AtomCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"                  -> AtomCharacter {cons("EndInputBoundry")}
    "\\z"                  -> AtomCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference     -> AtomCharacter {cons("BackReference")}
    "\\ "                  -> AtomCharacter {cons("Space")}
    "\\\t"                 -> AtomCharacter {cons("Tab")}
%%d    "\\\r"                 -> AtomCharacter {cons("Return")}
    "\\\n"                 -> AtomCharacter {cons("Newline")}
    
%%
 %%   Quoting of symbols is always allowed to express that symbol
  %%
  sorts QuotablePatternSymbol
  context-free syntax
    "\\" QuotablePatternSymbol            -> AtomCharacter {cons("Quoted")}
    "\\" QuotablePatternSymbol            -> BracketCharacter {cons("Quoted")}    
  lexical syntax
    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/]
                                   -> QuotablePatternSymbol
  context-free syntax
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }
    "\""                -> QuotablePatternSymbol {cons("DoubleQuote") }    
%%
 %%   Defining integers and number values
  %% 
  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue
  lexical syntax      
    [0-9]+                                       -> Integer
    [1-9] [0-9]*                                 -> BackReference
    [0-7]                                        -> OctalValue
    [0-7][0-7]                                   -> OctalValue
    [0-3][0-7][0-7]                              -> OctalValue
    [0-9A-Fa-f][0-9A-Fa-f]                       -> TwoHexValue
    [0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f][0-9A-Fa-f] -> FourHexValue
    [0-9]                                        -> ControlValue
    [0-9][0-9]                                   -> ControlValue

%%d  lexical restrictions
%%d    "/"  -/- [\]]
%%d    "\\" -/- [\ \t\12\n\r]   
    
    
exports
  sorts
    RegexId
    RegexID

  context-free syntax
    RegexID -> RegexId {cons("RegexId")}

  lexical syntax
    [A-Za-z\_\$][A-Za-z0-9\_\$]* -> RegexID
    
    "true"  -> RegexID {reject}
    "false" -> RegexID {reject}
    "null"  -> RegexID {reject}

  lexical restrictions
    RegexID -/- [a-zA-Z0-9\_\$]

module WebDSL-JavaScript
  
exports 
  sorts TemplateElement
  context-free syntax
    "<" "script" Attribute* ">" 
    %%todo: should be javascript embedding
    JSPart*
    "</" "script" ">"
    -> TemplateElement { cons("JSElement"), prefer}
  
  JSString -> JSPart{cons("JSString")}
  "~" Exp -> JSPart{cons("JSExp"), prefer}
  "\\~" -> JSPart{cons("JSTilde"), prefer}

  sorts JSChar JSString
  lexical syntax
  JSChar+ -> JSString
  ~[\<\~]                        -> JSChar
  SmallerThan                  -> JSChar
  [\<]                         -> SmallerThan

  lexical restrictions
    SmallerThan   -/- [\/]
    JSString -/- [\ \t\n\r]
    JSString -/- ~[\<\~]

module WebDSL-XML
  
exports
  context-free syntax
  
    "<" QualName Attribute* "/>" -> TemplateElement {cons("XMLEmptyElement")}
    
    "<" QualName Attribute* ">"
      TemplateElement*
      "</" QualName ">" -> TemplateElement {cons("XMLElement")}

  context-free syntax %% if(){} and if(){}else{} inside an XML element containing a list of attributes

    "if" "(" Exp ")" "{" Attribute* "}"		          -> Attribute {cons("XMLAttributesIf")}
    "if" "(" Exp ")" "{" Attribute* "}" "else" "{" Attribute* "}" -> Attribute {cons("XMLAttributesIfElse")}

  context-free syntax

    QualName "=" Exp -> Attribute {cons("Attribute")}
    
    %%easy injection of attributes from template call
    CommonAttribute -> Attribute
    "all attributes"  -> CommonAttribute {cons("AllAttributes")}
    "all attributes except" Exp        -> CommonAttribute {cons("AllAttributeExceptExp")}
    "attributes" Exp        -> CommonAttribute {cons("AttributesExp")}
    
    "attributes" -> KEYWORD
    
exports

  lexical syntax
    Qualifier? NCName -> QualName    
    NCName ":"        -> Qualifier

  
    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName

  lexical restrictions
    NCName -/- [A-Za-z0-9\.\-\_]

module WebDSL-AccessControl

imports
  WebDSL-UI
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-Lexical

%% syntax for access control  
exports

  sorts MatchId

  lexical syntax
    [a-zA-Z][a-zA-Z0-9\_]*[\*]? -> MatchId
    [\*]                        -> MatchId
    [\*]                        -> WildCardArg 

context-free syntax

  "access" "control" "rules" Id? AccessControlDefinition*  -> Section {cons("AccessControlDefinition")}
  %%deprecated: 
  "access" "control" "rules" "{" Id? AccessControlDefinition* "}"  -> Section {cons("AccessControlDefinition")}
  
  "principal" "is" Id "with" "credentials" {Id ","}+            -> Definition {cons("AccessControlPrincipal")} 
  "principal" "is" Id "with" "credentials" {Id ","}+            -> AccessControlDefinition {cons("AccessControlPrincipal")} 
  
  AccessControlRule                                             -> AccessControlDefinition
 
  "rule" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}
  %%deprecated:
  "rules" Id MatchId "(" MatchArgs ")"
  "{" AccessControlCheck AccessControlRule* "}"                 -> AccessControlRule {cons("AccessControlRule")}

  {FormalArg ","}* WildCardArg?                                 -> MatchArgs {cons("MatchArgs"),prefer}
  {Exp ","}* WildCardArg?                                       -> MatchArgs {cons("MatchArgs")}

  %% to prevent an AccessControlRule becoming an AccessControlCheck
  "rules"                                                       -> Exp {reject}

  Exp                                                           -> AccessControlCheck
  
  %% special rules, e.g. to protect ?logsql
  "rule" Id "{" AccessControlCheck "}"                 -> AccessControlRule {cons("SpecialAccessControlRule")}  
  
  %% pagecheck
  %%"pagecheck" "<" Id "," Exp ">"  -> TemplateElement {cons("PageCheck"),prefer}
  %%"pagecheck" "(" Id "," Exp ")"  -> TemplateCall {reject}
  %%"pagecheck" "(" {Exp ","}* ")"                          -> TemplateCall {reject}
  
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}" -> Definition {cons("Predicate")}
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}" -> AccessControlDefinition {cons("Predicate")}
  "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}" -> EntityBodyDeclaration {cons("PredicateInEntity")}
  
  Id MatchId "(" {Id ","}* WildCardArg? ")"                     -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
  
  "pointcut" Id "(" {FormalArg ","}* ")"
    "{" {AccessControlPointcutElement ","}* "}"                 -> AccessControlPointcut {cons("AccessControlPointcut")}
  
  AccessControlPointcut                                         -> AccessControlDefinition
  
  %%construct to import checks of another page or template, necessary for easily applying ac rules to lifted templates
  "apply ac rules" Id "(" {AccessControlImportRulesArg ","}* ")" -> TemplateElement {cons("AccessControlImportRules"), prefer}
  Id -> AccessControlImportRulesArg {cons("Var")} %%only vars supported, enough for current usage, see languages/access-control/access-control.str
  
context-free syntax  
  
  "access" "control" "policy" PolicyExp                         -> Section {cons("ACPolicy")}
  
  Id                                 -> PolicyExp {cons("Name")}
  "(" PolicyExp ")"                  -> PolicyExp {bracket}
  PolicyExp "AND" PolicyExp          -> PolicyExp {cons("PolicyAnd"), assoc}
  PolicyExp "OR" PolicyExp           -> PolicyExp {cons("PolicyOr"), assoc}
  
  
  %% hack for allowing multiple function checks to be added in different stages to a function call
  %%"acfunctioncheck" "(" Id "," Exp ")" Exp -> Exp {cons("ACFunctionCheck"), prefer}
  
context-free priorities
  {left:
       PolicyExp "AND" PolicyExp -> PolicyExp}
  > {left:
       PolicyExp "OR" PolicyExp -> PolicyExp}

context-free priorities
    Exp "in" Exp  -> Exp
  > Exp -> AccessControlCheck

context-free syntax
  
  "ignore-access-control" -> Modifier {cons("IgnoreAccessControl")}

module WebDSL-DataValidation

exports

  context-free syntax

    "validatecreate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateCreateAnno"),prefer}
    "validateupdate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateUpdateAnno"),prefer}
    "validatedelete" "(" Exp "," Exp ")" -> Annotation {cons("ValidateDeleteAnno"),prefer}
    "validate" "(" Exp "," Exp ")" -> Annotation {cons("ValidateAnno"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" -> Annotation {cons("NamedValidateAnno"),prefer}
    
    ValidateEntity -> EntityBodyDeclaration
    "validate" "(" Exp "," Exp ")" -> ValidateEntity {cons("ValidateEntity"),prefer}
    
    "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("ValidateStatement"),prefer}
    Id ":" "validate" "(" Exp "," Exp ")" ";" -> Statement {cons("NamedValidateStatement"),prefer}
    
    "validationErrors" "(" Id ")" -> TemplateCall {cons("ValidationErrors"),prefer}
    "validationErrors" "(" ")" -> TemplateCall {cons("ValidationErrors"),prefer}
    
    
    "validationContext" "{" TemplateElement* "}" -> TemplateCall {cons("ValidationContext"),prefer}
    "validationContext" "{" TemplateElement* "}" -> TemplateCall {reject}

module WebDSL-DataModel

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  context-free syntax

    "globals" "{" GlobalsDef* "}"                        -> Definition {prefer,cons("GlobalsDefinition"),deprecated("'globals{ }' block is no longer necessary around global variables and functions")}

    "entity" Id ":" Id "{" EntityBodyDeclaration* "}"       -> Entity {cons("Entity")}
    "entity" Id "{" EntityBodyDeclaration* "}"              -> Entity {cons("EntityNoSuper")}
    "session" Id "{" EntityBodyDeclaration* "}"             -> Entity {cons("SessionEntity")}
    Property -> EntityBodyDeclaration
    Function -> EntityBodyDeclaration
    StaticEntityFunction -> EntityBodyDeclaration
    "cache" -> EntityBodyDeclaration {cons("CachedEntity")}

    Entity                                   		     -> Definition

    "extend" "entity" Id "{" EntityBodyDeclaration* "}"	 -> Definition {cons("ExtendEntity")}
    "extend" "session" Id "{" EntityBodyDeclaration* "}"   -> Definition {cons("ExtendSessionEntity")}

  context-free restrictions
    "cache" -/- [a-zA-Z0-9\_] %% prevent ambiguity between CachedEntity and a property id beginning with cache

exports

  sorts Entity Property Sort Annotation

  context-free syntax

    "request" VarDecl -> Definition {cons("RequestScope")}
    VarDecl                                              -> GlobalsDef
    %% still allow ";" behind global var for backwards comp., remove VarDeclStat-> GlobalsDef to disallow
    VarDeclStat                                          -> GlobalsDef
    Function                                             -> GlobalsDef
    GlobalsDef                                           -> Definition
    InitAction                                           -> Definition

exports

  sorts Property Annotation

  context-free syntax

    Id PropKind Sort "(" {Annotation ","}* ")" -> Property {cons("Property")}
    Id PropKind Sort                           -> Property {cons("PropertyNoAnno")}

    Id PropKind Sort "(" {Annotation ","}* ")" ":=" Exp -> Property {cons("DerivedProperty")}
    Id PropKind Sort ":=" Exp                           -> Property {cons("DerivedPropertyNoAnno")}


    "::" -> PropKind {cons("Simple")}
    "->" -> PropKind {cons("Ref")}
    "<>" -> PropKind {cons("Comp")}

  sorts Sort

  context-free syntax

%% explicit syntax makes the annotations highlighted as keyword in the editor
%% removed generic SingleParamAnno due to http://yellowgrass.org/issue/StrategoXT/825

    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    %%fallback for code completion:
    "inverse" "=" Id             -> Annotation {cons("IncompleteInverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
    "not null"                   -> Annotation {cons("NotNullAnno")}
    "not empty"                  -> Annotation {cons("NotEmptyAnno")}
    "allowed" "=" Exp            -> Annotation {cons("AllowedAnno")}
    "default" "=" Exp            -> Annotation {cons("DefaultAnno")}
    "length" "=" Int             -> Annotation {cons("LengthAnno")}
    "format" "=" String          -> Annotation {cons("FormatAnno")}
    "index" "(" ")"              -> Annotation {cons("IndexAnno")}
    "index" "(" Int ")"          -> Annotation {cons("IndexAnno")}
    "collation" "(" Id ")"       -> Annotation {cons("CollationAnno")}
    "iderror" "=" String         -> Annotation {cons("IdErrorAnno")}
    "idemptyerror" "=" String    -> Annotation {cons("IdEmptyErrorAnno")}

module HQL

hiddens
  context-free start-symbols QueryRule Statement
  
exports
  lexical syntax
    [a-zA-Z\_][a-zA-Z0-9\_]* -> Identifier
  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    "from" -/- [a-zA-Z0-9\_]
    "select" -/- [a-zA-Z0-9\_]
    
  context-free syntax
   
    "from" | "select" | "by" | "order" -> Identifier {reject}
    
exports

  sorts Statement UpdateStatement DeleteStatement SelectStatement InsertStatement
  
  context-free syntax

    "delete" FromClause WhereClause? -> DeleteStatement {cons("DeleteStatement")}
    
    SelectStatement -> Statement

    QueryRule -> SelectStatement

    QueryRule "union" QueryRule -> Union {cons("QueryUnion")}

    SelectFrom WhereClause? GroupByClause? OrderByClause? -> QueryRule {cons("QueryRule")}
    
    SelectClause? FromClause -> SelectFrom {cons("SelectFrom")}
    
    "select" Distinct? Selection -> SelectClause {cons("Select")}

    "distinct"                   -> Distinct {cons("Distinct")}
    
    SelectedPropertiesList -> Selection
    NewExpression          -> Selection
    SelectObject           -> Selection

    QueryRule              -> Expression {avoid}
    
  "new" Path "(" SelectedPropertiesList ")" -> NewExpression {cons("NewExpression")}
  
  "object" "(" Identifier ")" -> SelectObject {cons("SelectObject")}
  
    "from" {FromRangeJoin ","}+ -> FromClause {cons("FromClause")}
    
    FromRange FromJoin* -> FromRangeJoin {cons("FromRangeJoin")}
    
    "left"          -> JoinType {cons("LeftJoin")}
    "right"         -> JoinType {cons("RightJoin")}
    "left"  "outer" -> JoinType {cons("LeftOuterJoin")}
    "right" "outer" -> JoinType {cons("RightOuterJoin")}
    "full"          -> JoinType {cons("FullJoin")}
    "inner"         -> JoinType {cons("InnerJoin")}
    
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin {cons("FromJoin")}
    
    "fetch" -> Fetch {cons("Fetch")}
        
  "with" Expression -> WithClause {cons("WithClause")}
  
    FromClassOrOuterQueryPath       -> FromRange
    InClassDeclaration              -> FromRange
    InCollectionDeclaration         -> FromRange
    InCollectionElementsDeclaration -> FromRange
    
    Path AsAlias? PropertyFetch? -> FromClassOrOuterQueryPath {cons("FromClass")}
    
    Alias "in" "class" Path -> InClassDeclaration {cons("InClassDeclaration")}
    
    "in" "(" Path ")" Alias -> InCollectionDeclaration {cons("InCollection")}
    
    Alias "in" "elements" "(" Path ")" -> InCollectionElementsDeclaration {cons("InCollectionElements")}

    "as" Alias -> AsAlias {cons("AsAlias")}
  
    Identifier -> Alias {cons("Alias")}
  
  
    "fetch" "all" "properties" -> PropertyFetch {cons("PropertyFetch")}
    
    "group" "by" {Expression ","}+ HavingClause? -> GroupByClause {cons("GroupBy")}
    
    "order" "by" {OrderElement ","}+ -> OrderByClause {cons("OrderByClause")}
    
    Expression AscendingOrDescending? -> OrderElement {cons("OrderElement")}
    
   "asc"       -> AscendingOrDescending {cons("Ascending")}
   "ascending" -> AscendingOrDescending {cons("Ascending")}
   
   "desc"      -> AscendingOrDescending {cons("Descending")}
   "descending" -> AscendingOrDescending {cons("Descending")}
   
    "having" Expression -> HavingClause {cons("HavingClause")}
    
    "where" Expression -> WhereClause {cons("WhereClause")}
    
    { AliasedExpression ","}+ -> SelectedPropertiesList {cons("SelectedPropertiesList")}
    
    %%QuotedAliasedExpression -> OptionallyQuotedAliasedExpression
    %%AliasedExpression       -> OptionallyQuotedAliasedExpression
    
    "'" Expression AsAlias? "'" -> QuotedAliasedExpression {cons("QuotedAliasedExpression")}
    Expression AsAlias? -> AliasedExpression {cons("AliasedExpression")}
    
   Expression "or" Expression -> Expression {cons("QueryOr")}
   
    Expression "and" Expression -> Expression {cons("QueryAnd")}
    
    "not" Expression -> Expression {cons("QueryNot")}
    
    Expression "=" Expression -> Expression {cons("EQ")}
    Expression "is" Expression -> Expression {cons("IS")}
    Expression "!=" Expression -> Expression {cons("NE")}
    Expression "<>" Expression -> Expression {cons("SQLNE")}
    Expression "like" Expression -> Expression {cons("LIKE")}
    Expression "not" "like" Expression -> Expression {cons("NOTLIKE")}

    Expression "<" Expression -> Expression {cons("LT")}
    Expression "<=" Expression -> Expression {cons("LE")}
    Expression ">" Expression -> Expression {cons("GT")}
    Expression ">=" Expression -> Expression {cons("GE")}
    
    Expression "in" Expression -> Expression {cons("In")}
    Expression "not" "in" Expression -> Expression {cons("NotIn")}
    
    Expression "member" "of" Expression -> Expression {cons("MemberOf")}
    Expression "not" "member" "of" Expression -> Expression {cons("NotMemberOf")}
  
    Expression "||" Expression -> Expression {cons("Concat")}
    
    Expression "+" Expression -> Expression {cons("Plus")}
    Expression "-" Expression -> Expression {cons("Minus")}

    Expression "*" Expression -> Expression {cons("Multiply")}
    Expression "/" Expression -> Expression {cons("Divide")}
    Expression "%" Expression -> Expression {cons("Modulo")}
    
    "-" Expression -> Expression {cons("UMinus")}
    
    %% current_date(), current_time(), and current_timestamp()
    "current_date" "(" ")" -> Expression {cons("HQLFunCurDate")}
    "current_time" "(" ")" -> Expression {cons("HQLFunCurTime")}
    "current_timestamp" "(" ")" -> Expression {cons("HQLFunCurTimestamp")}
    %% second(...), minute(...), hour(...), day(...), month(...), and year(...)
    "second" "(" Expression ")" -> Expression {cons("HQLFunSecond")} 
    "minute" "(" Expression ")" -> Expression {cons("HQLFunMinute")} 
    "hour" "(" Expression ")" -> Expression {cons("HQLFunHour")} 
    "day" "(" Expression ")" -> Expression {cons("HQLFunDay")} 
    "month" "(" Expression ")" -> Expression {cons("HQLFunMonth")} 
    "year" "(" Expression ")" -> Expression {cons("HQLFunYear")} 
    
   lexical syntax 
     ":" Identifier -> IdParameter 
     "?" NumInt     -> NumParameter
   context-free syntax
     IdParameter -> Expression {cons("IdParam")}
     NumParameter -> Expression {cons("NumParam")}
   
    "avg" "(" Expression ")" -> Expression {cons("Avg")}
    "sum" "(" Expression ")" -> Expression {cons("Sum")}
    "min" "(" Expression ")" -> Expression {cons("Min")}
    "max" "(" Expression ")" -> Expression {cons("Max")}
    "count" "(" "*" ")" -> Expression {cons("CountStar")}
    "count" "(" Expression ")" -> Expression {cons("Count")}
    
     "elements" "(" Path ")" -> Expression {cons("Elements")}
     "indices" "(" Path ")" -> Expression {cons("Indices")}
                     
     Path                      -> Expression
     "(" {Expression ","}+ ")" -> Expression {cons("Paren")}
     "(" QueryRule ")"         -> Expression {cons("Paren"), prefer}
     
    Constant -> Expression
    
    "true" -> Constant {cons("True")}
    "false" -> Constant {cons("False")}
    "empty" -> Constant {cons("Empty")}
    "null" -> Constant {cons("Null")}

    "true" -> Identifier {reject}
    "false" -> Identifier {reject}
    "empty" -> Identifier {reject}
    "null"  -> Identifier {reject}
    
    {Identifier "."}+ -> Path {cons("Path")} 
    
  context-free syntax
    QuotedString -> Constant {cons("String")}
    
  lexical syntax
    "'" (~[\'] | "\\'")* "'" -> QuotedString
     
  lexical syntax
    [0-9]+ -> NumInt
  context-free syntax
    NumInt -> Constant
  
context-free priorities
  {
    {Identifier "."}+ -> Path
    "(" {Expression ","}+ ")" -> Expression
    "avg" "(" Expression ")" -> Expression
    "sum" "(" Expression ")" -> Expression
    "min" "(" Expression ")" -> Expression
    "max" "(" Expression ")" -> Expression
    "count" "(" "*" ")" -> Expression
    "count" "(" Expression ")" -> Expression
    "elements" "(" Path ")" -> Expression
    "indices" "(" Path ")" -> Expression
    "-" Expression -> Expression
  }
  > {left:
    Expression "*" Expression -> Expression
    Expression "/" Expression -> Expression
    Expression "%" Expression -> Expression
    Expression "||" Expression -> Expression
  }
  > {left:
    Expression "+" Expression -> Expression
    Expression "-" Expression -> Expression
  }
  > {left:
    Expression "<" Expression -> Expression
    Expression "<=" Expression -> Expression
    Expression ">" Expression -> Expression
    Expression ">=" Expression -> Expression
    Expression "like" Expression -> Expression 
    Expression "not" "like" Expression -> Expression
    Expression "in" Expression -> Expression
    Expression "not" "in" Expression -> Expression
    Expression "member" "of" Expression -> Expression
    Expression "not" "member" "of" Expression -> Expression
    }
  > {left:
    Expression "=" Expression -> Expression
    Expression "is" Expression -> Expression
    Expression "!=" Expression -> Expression
    Expression "<>" Expression -> Expression
    }
  > "not" Expression -> Expression
  > {left: Expression "and" Expression -> Expression}
  > {left: Expression "or" Expression -> Expression }

module MixHQL[Ctx0]
imports 
        HQL
          [ Constant                        => Constant[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            QuotedAliasedExpression         => QuotedAliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            DeleteStatement                 => DeleteStatement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]]
            Path                            => Path[[Ctx0]]
            Expression                      => Expression[[Ctx0]] ]


module WebDSL-Action

imports
  WebDSL-Lexical
  MixHQL[HQL]

exports

  context-free syntax
  
    "function" -> Keyword
    "return"   -> Keyword

  context-free syntax %% Functions

    "function" Id "(" {FormalArg ","}* ")" FunctionReturn Block -> Function {cons("Function")}
        
    -> FunctionReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionReturn {ast("<1>")}

    "extend" Function -> Function {cons("ExtendFunction")}
    
  %% static entity function

    "static" "function" Id "(" {FormalArg ","}* ")" ReturnType Block -> StaticEntityFunction {cons("StaticEntityFunction")}
  
    ":" Sort -> ReturnType{cons("ReturnType")}
    -> ReturnType {ast("ReturnType(SimpleSort(\"Void\"))")}
  
  context-free syntax %% inline anonymous functions/closures
    
    FunctionExp -> Exp
    "function" FunctionExpParams FunctionReturn Block -> FunctionExp {cons("FunctionExp")}
    -> FunctionExpParams {ast("[]")}
    "(" {FormalArg ","}* ")" -> FunctionExpParams {ast("<1>")}
    
    %% reference to a function, something to help desugar lifted function exp
    FunctionRef -> Exp
    "function." Id "(" {Sort ","}* ")" FunctionReturn -> FunctionRef {cons("FunctionRef")}
    
    
    FunctionRef "(" {Exp ","}* ")" -> Exp {cons("FunctionRefCall")}
    FunctionRef "(" "*" "," {Exp ","}* ")" -> Exp {cons("FunctionRefCallPartial")}
   
  context-free syntax
    "{" Statements "}" 		-> Block {cons("Block")}
    Block              		-> Statement
    %%Assignment ";"	   	-> Statement {cons("Assign")}
    Exp ";"		       		-> Statement {cons("Stat")}

    "return" Exp ";"     	-> Statement {cons("Return")}
    
    "return" ";"         	-> Statement {cons("ReturnEmpty")}
    
    "goto" PageCall ";"       	-> Statement {cons("GoTo"),prefer}
    "goto" "(" PageCall ")" ";"         -> Statement {cons("GoTo"),prefer}
    "goto" -> TemplateCallId {reject}

    "schedule" Exp "for" Exp ";" -> Statement {cons("Schedule")}
    "schedule" Exp ";"           -> Statement {cons("ScheduleNoFor")}

  context-free syntax

    "var" Id ":" Sort ";" 	-> VarDeclStat {cons("VarDecl")}
    "var" Id ":" Sort 		-> VarDecl {cons("VarDecl")}

    "var" Id ":" Sort ":=" Exp ";" -> VarDeclStat {cons("VarDeclInit")}
    "var" Id ":=" Exp ";"          -> VarDeclStat {cons("VarDeclInitInferred")}
    "var" Id ":" Sort ":=" Exp     -> VarDecl {cons("VarDeclInit")}
    "var" Id ":=" Exp              -> VarDecl {cons("VarDeclInitInferred")}

    VarDeclStat -> Statement

  context-free syntax

    "if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}

    "if" "(" Exp ")" Block 		-> Statement {cons("IfNoElse")}

    "case" "(" Exp ")" "{" Case* "}" 	-> Statement {cons("Case")}
    ConstValue Block                 	-> Case {cons("CaseAlt")}
    "default"  Block                 	-> Case {cons("CaseDefault")}

  context-free syntax %% if in expression:  if(e) e1 else e2

    "if" "(" Exp ")" Exp "else" Exp -> Exp {cons("IfExp")}

  context-free syntax

    "for" "(" Id ":" Sort "in" Exp Filter ")"
      Block 				-> Statement {cons("ForStmt")}

    "for" "(" Id ":" Sort "in" Exp ")"
      Block 				-> Statement {cons("ForStmtNoFilter")}

    "for" "(" Id ":" Sort Filter ")"
      Block 				-> Statement {cons("ForAllStmt")}

    "for" "(" Id ":" Sort ")"
      Block 				-> Statement {cons("ForAllStmtNoFilter")}

    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}

    "while" "(" Exp ")" Block -> Statement {cons("WhileStmt")}

exports %% Expression language

  sorts ConstValue Exp

  context-free syntax
    Int                    -> ConstValue {cons("Int")}
    Long                   -> ConstValue {cons("Long")}
    Float                  -> ConstValue {cons("Float")}
    String                 -> ConstValue {cons("String")}

    ConstValue                  -> Exp

    Id			   -> Exp {cons("Var")}
    "in"                   -> Exp {reject}
        
    %% to be able to refer to page or template farg/var from actions when names clashing with farg/var in action
    "externalscope" "." Id -> Exp {cons("ExternalScopeVar")}
    "global" "." Id -> Exp {cons("GlobalVar")}
    "global" -> Id {reject}

    Exp "." Id             -> Exp {cons("FieldAccess"),prefer}
    
    Exp "[" Exp "]"        -> Exp {cons("CollectionIndex"),prefer}

    Sort "{" ObjectPropertyAssignment* "}"         -> ObjectCreation {cons("ObjectCreation")}
    Sort "{" { ObjectPropertyAssignment "," }* "}" -> ObjectCreation {cons("ObjectCreation"), prefer}
    ObjectCreation -> Exp

    Id ":=" Exp           -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}
    %% fallback for code completion:
    Id -> ObjectPropertyAssignment {cons("IncompleteObjectPropertyAssignment")}

    Exp ":=" Exp             -> Assignment {cons("Assignment")}
    Assignment				-> Exp

    "[" Mapping* "]"       -> Exp {cons("MapCreation"), avoid} %%avoid to prevent ambiguity between with empty untyped list creation and empty map creation
    Exp "->" Exp           -> Mapping {cons("Mapping")}

    "[" {Exp ","}* "]"     -> Exp {cons("ListCreation")}

    "{" {Exp ","}* "}"     -> Exp {cons("SetCreation")}

    "List" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedListCreation"), prefer}
    "Set" "<" Sort ">" "(" {Exp ","}* ")" -> Exp {cons("TypedSetCreation"), prefer}

    Id "(" {Exp ","}* ")"  -> Exp {cons("ThisCall")}
    "!" "(" {Exp ","}* ")"  -> Exp {reject}

    Exp "." Id "(" {Exp ","}* ")"  -> Exp {cons("Call")}

    Exp "is" "a" Sort      -> Exp {cons("IsA")}
    Exp "as" Sort          -> Exp {cons("Cast"), avoid} %% avoid, to give hql query AsAlias more priority, 'from Page as p' should make the 'as p' part of the query
    "as"   -> Keyword
  
  context-free restrictions
    "as" -/- [a-zA-Z0-9\_] %% prevent ambiguity between as and asc (used in for-filters)
 
  context-free syntax
    Exp "in" Exp           -> Exp {non-assoc, cons("InColl")}
  context-free restrictions
    "in" -/- [a-zA-Z0-9\_] %% there must be whitespace after the 'in' keyword for collection test

  context-free syntax
    Exp "==" Exp           -> Exp {cons("Eq")}
    Exp "!=" Exp           -> Exp {cons("NotEq")}
    Exp ">" Exp           -> Exp {cons("LargerThan")}
    Exp ">=" Exp           -> Exp {cons("LargerThanOrEqual")}
    Exp "<" Exp           -> Exp {cons("SmallerThan")}
    Exp "<=" Exp           -> Exp {cons("SmallerThanOrEqual")}

    "true"                 -> Exp {prefer,cons("True")}
    "false"                -> Exp {prefer,cons("False")}

    "null"                 -> Exp {prefer,cons("Null")}

    Exp "&&" Exp          -> Exp {cons("And"), assoc}
    Exp "||" Exp           -> Exp {cons("Or"), assoc}
    "!" Exp              -> Exp {cons("Not")}

    "(" Exp ")"            -> Exp {bracket}


    "[" Exp "for" "(" Id ":" Sort "in" Exp Filter ")" "]" -> ForExp {cons("ForExp")}
    "[" Exp "for" "(" Id ":" Sort "in" Exp ")" "]"        -> ForExp {cons("ForExpNoFilter")}
    "[" Exp "|" Id ":" Sort "in" Exp Filter "]"           -> ForExp {cons("ForExp")}
    "[" Exp "|" Id ":" Sort "in" Exp "]"                  -> ForExp {cons("ForExpNoFilter")}
    ForExp                                                -> Exp

    "And" ForExp                                          -> Exp {cons("AndForExp")}
    "Or"  ForExp                                          -> Exp {cons("OrForExp")}


    Exp "*" Exp  -> Exp {cons("Mul"),assoc}
    Exp "/" Exp  -> Exp {cons("Div"),assoc}
    Exp "%" Exp  -> Exp {cons("Mod"),assoc}
    Exp "+" Exp  -> Exp {cons("Add"),assoc}
    Exp "-" Exp  -> Exp {cons("Sub"),assoc}

context-free priorities
  {left:
    Exp "." Id "(" {Exp ","}* ")"  -> Exp
    Exp "." Id  -> Exp
    Exp "[" Exp "]"  -> Exp }
  > {non-assoc: 
       Exp "is" "a" Sort -> Exp 
       Exp "as" Sort     -> Exp
    }
  > "!" Exp -> Exp
  > {left:
       Exp "*" Exp -> Exp
       Exp "%" Exp -> Exp
       Exp "/" Exp -> Exp }
  > {left:
       Exp "+" Exp -> Exp
       Exp "-" Exp -> Exp }
  > Exp "in" Exp -> Exp
  > {left:
       Exp "==" Exp -> Exp
       Exp "!=" Exp -> Exp
       Exp ">" Exp -> Exp
       Exp ">=" Exp -> Exp
       Exp "<" Exp -> Exp
       Exp "<=" Exp -> Exp }
  > {left:
       Exp "&&" Exp -> Exp }
  > {left:
       Exp "||" Exp -> Exp }
  > Assignment -> Exp
  > HqlExp -> Exp
  > "if" "(" Exp ")" Exp "else" Exp -> Exp


exports

  context-free syntax

    QueryRule[[HQL]]                     -> HqlExp {cons("HqlQuery")}
    QueryRule[[HQL]] "limit" LimitValueExp         -> HqlExp {cons("HqlQueryLimit")}
    QueryRule[[HQL]] "limit" LimitValueExp "," LimitValueExp -> HqlExp {cons("HqlQueryLimitOffset")}

    %%although limit is not part of HQL, it has been added in WebDSL so it should support the ~var style of injecting values into HQL
    Exp -> LimitValueExp
    DslExp -> LimitValueExp

    DslExp -> Expression[[HQL]]
    "~" Exp -> DslExp {cons("DslExp")}

    DeleteStatement[[HQL]] ";" -> Statement {cons("HqlStatement")}

  context-free syntax

    QueryRule[[HQL]] "." Id -> Exp {reject}

context-free syntax %% email functions

  Id "(" {Exp ","}* ")" -> EmailCall {cons("EmailCall")}
  
  "renderemail" "(" EmailCall ")" -> Exp {cons("RenderEmailFunctionCall"),prefer}
  "email" "(" EmailCall ")" -> Exp {cons("EmailFunctionCall"),prefer}
  "email" EmailCall -> Exp {cons("EmailFunctionCall"),prefer}
  "sendemail" "(" EmailCall ")" -> Exp {cons("SendEmailFunctionCall"),prefer}
  
context-free syntax %% function to execute a particular template phase
  
  "rendertemplate" "(" TemplateCall ")" -> Exp {cons("RenderTemplateFunctionCall"),prefer} 
  "validatetemplate" "(" TemplateCall ")" -> Exp {cons("ValidateTemplateFunctionCall"),prefer}

module WebDSL-Ajax

exports

  sorts Statement Exp InlineTemplate AjaxStatement
  context-free syntax

    "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> Exp {cons("EventCall")}
    "event" "(" Id "," "[" { EventArg "," }* "]" ")" -> TemplateElement {cons("EventCallElement")}

    Id ":=" Exp -> EventArg {cons("EventArg")}
  
%%  	replace <element_id> << <templatecall>(<argumenten>);
%%	append  <element_id> << <templatecall>(<argumenten>);
%%	visibility <element_id> << < "show" | "hide" | "toggle">;
%%	relocate this << <pagecall>(<argumenten>);
%%	restyle <element_id> << "<css classname>";
%%	clear <element_id> << "<niet terzake doende string>"

  AjaxStatement ";" -> Statement {cons("AjaxStatement"), prefer}   
    "replace" "(" Id "," TemplateCall ")" -> AjaxStatement {cons("AjaxReplace"), prefer}
    "replace" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxReplace")}    
    %%"replace" "(" Id "," InlineTemplate ")" -> AjaxStatement {cons("AjaxReplace"), prefer}  	

    "append" "(" Id "," TemplateCall ")" -> AjaxStatement {cons("AjaxAppend"), prefer}
    "append" "(" Exp "," TemplateCall ")" -> AjaxStatement {cons("AjaxAppend")}
    %%"append" "(" Id "," InlineTemplate ")" -> AjaxStatement {cons("AjaxAppend"), prefer}  	

    "visibility" "(" Id "," AjaxVisibility ")" -> AjaxStatement {cons("AjaxVisibility"), prefer}
    "visibility" "(" Exp "," AjaxVisibility ")" -> AjaxStatement {cons("AjaxVisibility")}
    "show" -> AjaxVisibility{cons("Show")}
    "toggle" -> AjaxVisibility{cons("Toggle")}
    "hide" -> AjaxVisibility{cons("Hide")}        
    
    "relocate" "(" PageCall ")" -> AjaxStatement { cons("AjaxRelocate") }
    
    "restyle" "(" Id "," Exp ")" -> AjaxStatement { cons("AjaxRestyle"), prefer}
    "restyle" "(" Exp "," Exp ")" -> AjaxStatement { cons("AjaxRestyle") }
    
    "clear" "(" Id ")" -> AjaxStatement{cons("AjaxClear"), prefer}
    "clear" "(" Exp ")" -> AjaxStatement{cons("AjaxClear")}
    
    "refresh" "(" ")" -> AjaxStatement{cons("AjaxRefresh")}
    
    "runscript" "(" Exp ")" -> AjaxStatement { cons("AjaxRunScript"), prefer }
    
%%    Id Id "<<" Id  ";" 	 -> Statement {cons("AjaxActionIdParam"),prefer}
%%    Id Id "<<" ";"		-> Statement {cons("AjaxActionNoParam")}
%%    Id "<<" Exp ";"	 	-> Statement {cons("AjaxActionNoTarget")}
%%    Id Id "<<" Exp ";"   	-> Statement {cons("AjaxAction")}
  
    "placeholder" Id "{" TemplateElement* "}" -> TemplateElement{cons("Placeholder"), prefer}
    "placeholder" Exp "{" TemplateElement* "}"-> TemplateElement{cons("Placeholder")}
    "placeholder" Id TemplateCall -> TemplateElement{cons("PlaceholderWithAjaxCall"), prefer}
    "placeholder" PHExp TemplateCall -> TemplateElement{cons("PlaceholderWithAjaxCall")}
    "placeholder" -> TemplateCallId {reject}
    
    %% issue http://yellowgrass.org/issue/Spoofax/331
    %% workaround:
    Id "(" {Exp ","}* ")"  -> PHExp {cons("ThisCall")}
    Exp "." Id "(" {Exp ","}* ")"  -> PHExp {cons("Call")}
    Exp "." Id             -> PHExp {cons("FieldAccess"),prefer} 
    Exp "[" Exp "]"        -> PHExp {cons("CollectionIndex"),prefer}
    Exp "+" Exp  -> PHExp {cons("Add")}
    ConstValue -> PHExp
    %%
    %% more general implementation, currently broken in java back-end: 
    %% "placeholder" Exp TemplateCall -> TemplateElement{cons("PlaceholderWithAjaxCall")}
    %% reject ambiguous placeholder target{} next{} where target{} is parsed as object creation, 
    %% which is never the case since the expression must produce a String
    %% "placeholder" ObjectCreation TemplateCall   -> TemplateElement {reject} 


module WebDSL-UI

imports
  WebDSL-Action
  WebDSL-Lexical

exports

  sorts TemplateDefinition Modifier Exp

  context-free syntax
    
    "define" -> Keyword
  %%"action" -> Keyword
    "for"    -> Keyword

  context-free syntax

    TemplateDefinition -> Definition

    "define" Modifier*
       Id "(" {FormalArg ","}* ")"
       TemplateArgs
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "requires" {TemplateArg "," }*			-> TemplateArgs{cons("TemplateArgs"), prefer}
    Id "(" {Sort ","}* ")"                  -> TemplateArg {cons("TemplateArg")}
    
      -> TemplateArgs{cons("None")}
      
    "define" Modifier* Id "(" {FormalArg ","}* ")" "=" Id OptLocalRedefineArgs -> TemplateDefinition {cons("LocalRedefine")}
    -> OptLocalRedefineArgs {cons("None")}
    "(" "*" "," {LocalRedefineArg ","}+ ")" -> OptLocalRedefineArgs {cons("LocalRedefineArgs")}
    Id -> LocalRedefineArg{cons("Var")}
    
    %% new page syntax
    Modifier* "page"
       Id "(" {FormalArg ","}* ")"
       TemplateArgs
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("DefinePage")}
    %% new template syntax
     Modifier* "template"
       Id "(" {FormalArg ","}* ")"
       TemplateArgs
       "{" TemplateElement* "}"             -> TemplateDefinition {cons("DefineTemplate")}
          
    %%"define" Modifier*
    %%   Id UNDEFINED*
    %%   "{" TemplateElement* "}"             -> TemplateDefinition {cons("Define")}

    "page"                                  -> Modifier {cons("Page")}
    "email"                                 -> Modifier {cons("Email")}
    "ajax"                                  -> Modifier {cons("AjaxTemplate")}
    "template"                              -> Modifier {cons("Template")}
    "feed"                                  -> Modifier {cons("Feed")}
    "local"                                 -> Modifier {cons("Local")}
    "no-span"                								-> Modifier {cons("NoSpan")}    
    "span"  							                	-> Modifier {cons("TemplateModSpan")}    
    "inline"  								              -> Modifier {cons("TemplateModInline")}    
    "secure"                             	  -> Modifier {cons("TempateModSecure")}    
    "not-secure"                          	-> Modifier {cons("TemplateModNotSecure")}    
    "override"                            	-> Modifier {cons("TemplateModOverride")}    
    "deprecated"                          	-> Modifier {cons("TemplateDeprecated")}    

    InitAction                              -> TemplateElement
    Action                                  -> TemplateElement
    VarDecl                                 -> TemplateElement
    %% still allow ";" behind page var for backwards comp., remove VarDeclStat-> TemplateElement to disallow
    VarDeclStat                             -> TemplateElement
    "request" VarDecl                       -> TemplateElement {cons("RequestScopeTemplate")}
    "request"                               -> TemplateCallId {reject} %% reject TemplateCallNoArgs("request")
    "local" VarDecl                         -> TemplateElement {cons("LocalScopeTemplate")}
    "local"                                 -> TemplateCallId {reject} %% reject TemplateCallNoArgs("local")
    TemplateDefinition                      -> TemplateElement
    TemplateCall                            -> TemplateElement {avoid}
    String                                  -> TemplateElement {cons("Text")}


    "where" Exp                              -> Filter {cons("FilterNoOrderByNoLimit")}
    "order" "by" OrderExp                    -> Filter {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" OrderExp        -> Filter {cons("FilterNoLimit")}
    "where" Exp Limit                        -> Filter {cons("FilterNoOrderBy")}
    "order" "by" OrderExp Limit              -> Filter {cons("FilterNoWhere")}
    Limit                                    -> Filter {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" OrderExp Limit  -> Filter {cons("Filter")}
    Exp                                      -> OrderExp {cons("OrderNonSpecific")}
    Exp "asc"                                -> OrderExp {cons("OrderAscending")}
    Exp "desc"                               -> OrderExp {cons("OrderDescending")}
    "limit" Exp "offset" Exp                 -> Limit {cons("Limit")}
    "limit" Exp                              -> Limit {cons("LimitNoOffset")}
    "offset" Exp                             -> Limit {cons("LimitNoLimit")}


    "for" "(" Id ":" Sort "in" Exp Filter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("For")}
    
    %% Reject
   %%"for" "(" Id ":" Sort "in" HqlExp Filter ")" "{" TemplateElement* "}" -> TemplateElement {reject}
    
    "for" "(" Id ":" Sort "in" Exp ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForNoFilter"), prefer}

    "for" "(" Id ":" Sort Filter ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForAll")}

    "for" "(" Id ":" Sort ")"
       "{" TemplateElement* "}" ForSeparator       -> TemplateElement {cons("ForAllNoFilter")}
    
    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" 
      "{" TemplateElement* "}" ForSeparator        -> TemplateElement {cons("ForCount")}
    
    "separated-by" "{" TemplateElement* "}" -> ForSeparator{cons("ForSeparator")}
    -> ForSeparator{cons("None")}

    %%

    "select" "(" Exp "from" Exp ")" -> TemplateElement {cons("SelectFromListNoPropsNoElems")}
    "select" "(" Exp "from" Exp ")" "[" {PropertyAssignment ","}* "]" -> TemplateElement {cons("SelectFromListNoElems")}
    "select" "(" Exp "from" Exp ")" "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("SelectFromList")}
    "select" "(" Exp "from" Exp ")" "{" TemplateElement* "}" -> TemplateElement {cons("SelectFromListNoProps")}

    "if" "(" Exp ")" "{" TemplateElement* "}" "else" "{" TemplateElement* "}" -> TemplateElement {cons("IfTempl"),prefer}
    "if" "(" Exp ")" "{" TemplateElement* "}"                                 -> TemplateElement {cons("IfNoElseTempl")}


    "if" "(" Exp ")" "{" TemplateElement* "}" ElseIfTempl+ ElseTempl? -> TemplateElement {cons("IfElseIfTempl"),prefer}
    "else" "if" "(" Exp ")" "{" TemplateElement* "}"                  -> ElseIfTempl {cons("ElseIfTempl"),prefer}
    "else" "{" TemplateElement* "}"                                   -> ElseTempl  {cons("ElseTempl"),prefer}


    "case" "(" {Exp ","}* ")" "{" TemplateCaseAlt* "}" 	-> TemplateElement {cons("TemplateCase")}
    {ConstValue ","}* "{" TemplateElement* "}"          -> TemplateCaseAlt {cons("TemplateCaseAlt")}
    "default"  "{" TemplateElement* "}"                 -> TemplateCaseAlt {cons("TemplateCaseAltDefault")}

  %%
    TemplateCallId "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" TemplateBody -> TemplateCall {cons("TemplateCall")}

    TemplateCallNoArgs -> TemplateCall
    TemplateCallNoBody -> TemplateCall
    TemplateCallNoAssigns -> TemplateCall
    TemplateCallPropsNoBody -> TemplateCall
    TemplateCallProps -> TemplateCall
    TemplateCallPropsNoArgs -> TemplateCall
    TemplateCallBody -> TemplateCall
    TemplateCallId                                             -> TemplateCallNoArgs {cons("TemplateCallNoArgs")}
    TemplateCallId "(" {Exp ","}* ")"                          -> TemplateCallNoBody {cons("TemplateCallNoBody")}
    TemplateCallId "(" {Exp ","}* ")" TemplateBody -> TemplateCallNoAssigns {cons("TemplateCallNoAssigns")}
    TemplateCallId "(" {Exp ","}* ")" "[" {PropertyAssignment ","}*"]" -> TemplateCallPropsNoBody {cons("TemplateCallPropsNoBody")}
    TemplateCallId "[" {PropertyAssignment ","}*"]" -> TemplateCallProps {cons("TemplateCallProps")}
    TemplateCallId "[" {PropertyAssignment ","}*"]" TemplateBody -> TemplateCallPropsNoArgs {cons("TemplateCallPropsNoArgs")}
    TemplateCallId  TemplateBody -> TemplateCallBody {cons("TemplateCallBody")}
    
    "{" TemplateElement* "}" -> TemplateBody {cons("TemplateBody")}
    "with" "{" ArgDefine* "}" -> TemplateBody {cons("TemplateWith")}
    TemplateCallId "(" {FormalArg ","}* ")"
      "{" TemplateElement* "}" -> ArgDefine {cons("ArgDefine")}

    "with" "{" TemplateElement* "}"                -> TemplateCall {reject}
    
    %%disambiguate
    "define"                        -> TemplateCallId {reject}
    "for"                        -> TemplateCallId {reject}
    "placeholder"                        -> TemplateCallId {reject}
    
  %%
  
    %% deprecated
    "navigate" "(" PageCall ")" UNDEFINED* "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), prefer}
    "navigate" "(" PageCall ")" "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), prefer}

    "navigate" PageCall UNDEFINED* "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), prefer}
    "navigate" PageCall "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("NavigateCall"), prefer}

    Id "(" {Exp ","}* ")"  -> PageCall {cons("PageCall")}

    %%disambiguate
    "navigate" -> TemplateCallId {reject}
    
  %%

    %% deprecated
    "action" "(" Exp "," ActionCallOrInline ")" UNDEFINED* -> TemplateElement {cons("Submit"), prefer}
    "action" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]" -> TemplateElement {cons("Submit"), prefer}
    "actionLink" "(" Exp "," ActionCallOrInline ")" UNDEFINED* -> TemplateElement {cons("SubmitLink"), prefer}
    "actionLink" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]" -> TemplateElement {cons("SubmitLink"), prefer}

    "submit" "(" Exp "," ActionCallOrInline ")" UNDEFINED* -> TemplateElement {cons("Submit"), prefer}
    "submit" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]" -> TemplateElement {cons("Submit"), prefer}
    "submitlink" "(" Exp "," ActionCallOrInline ")" UNDEFINED* -> TemplateElement {cons("SubmitLink"), prefer}
    "submitlink" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]" -> TemplateElement {cons("SubmitLink"), prefer}

    "submit"     ActionCallOrInline UNDEFINED*                        "{" TemplateElement* "}" -> TemplateElement {cons("SubmitElem"), prefer}
    "submit"     ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("SubmitElem"), prefer}
    "submitlink" ActionCallOrInline UNDEFINED*                        "{" TemplateElement* "}" -> TemplateElement {cons("SubmitLinkElem"), prefer}
    "submitlink" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("SubmitLinkElem"), prefer}
    
    "downloadlink" ActionCallOrInline UNDEFINED*                        "{" TemplateElement* "}" -> TemplateElement {cons("DownloadLink"), prefer}
    "downloadlink" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("DownloadLink"), prefer}
    "outputimage" ActionCallOrInline UNDEFINED*                        "{" TemplateElement* "}" -> TemplateElement {cons("OutputImage"), prefer}
    "outputimage" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement {cons("OutputImage"), prefer}
    
    ActionCall -> ActionCallOrInline
    InlineAction -> ActionCallOrInline

    Id "(" {Exp ","}* ")"  -> ActionCall {cons("ActionCall")}
    
    %%disambiguate
    "action"                       -> TemplateCallId {reject}
    "actionLink"                   -> TemplateCallId {reject}
    "submit"                       -> TemplateCallId {reject}
    "submitlink"                   -> TemplateCallId {reject}
    "downloadlink"                 -> TemplateCallId {reject}
    "outputimage"                  -> TemplateCallId {reject}
  %%
   
    "action" Block -> InlineAction {cons("InlineAction")}
    %% reject ambiguous ObjectCreation(SimpleSort("action"), [])
    "action" -> Sort {reject}
    %%"template" "{" TemplateElement* "}" -> InlineTemplate {cons("InlineTemplateCall")}    
    %% "template"               -> Id {reject}
   
    %% Template call without braces must be disambiguated in some cases
    "action" -> TemplateCall {reject}  %%this is an action definiton, not a templatecall without params
    "action" -> Exp {reject}		   %%this is an inline action, not a variable
    "action" -> PropertyValue {reject} %%this is an inline action, not an id
    
  %%

    %% preferably have the symbol options in one production, unfortunately then it ends up in ast, can use ast instead of cons...
    %% SubmitProp PropertyAssignSymbol ActionCallOrInline -> PropertyAssignment {ast("PropertySubmit(<1>,<3>)"),prefer}
    %% however, in this case the constructors are not automatically generated for stratego
    %% 
%%  lexical syntax %% different opinions about nice syntax here, something to discuss (leaning towards "=")
%%    ":"  -> PropertyAssignSymbol %% same as type declaration
%%    ":=" -> PropertyAssignSymbol %% same as assignment
%%    "="  -> PropertyAssignSymbol %% same as html and data model property annotations  
    SubmitProp ":" ActionCallOrInline  -> PropertyAssignment {cons("PropertySubmit"),prefer}
    SubmitProp ":=" ActionCallOrInline -> PropertyAssignment {cons("PropertySubmit"),prefer}
    SubmitProp "=" ActionCallOrInline  -> PropertyAssignment {cons("PropertySubmit"),prefer}
    Id ":" PropertyValue		       -> PropertyAssignment {cons("PropertyAssignment")}
    Id ":=" PropertyValue		       -> PropertyAssignment {cons("PropertyAssignment")}
    Id "=" PropertyValue		       -> PropertyAssignment {cons("PropertyAssignment")}
    Exp								        	   -> PropertyValue
    "ajax"                                         -> PropertyAssignment {cons("TemplateCallPropertyAjax"),prefer}
    "secure"                                       -> PropertyAssignment {cons("TemplateCallPropertySecure"),prefer} %% for navigates and submits
    "ignore-validation"                            -> PropertyAssignment {cons("TemplateCallPropertyIgnoreValidation"),prefer}
    "not-secure"                                   -> PropertyAssignment {cons("TemplateCallPropertyNotSecure"),prefer} %% for navigates and submits
    "not null"                                     -> PropertyAssignment {cons("TemplateCallPropertyNotNull"),prefer}
    CommonAttribute -> PropertyAssignment
       
       
  lexical syntax
    "onabort" -> SubmitProp
    "onblur"  -> SubmitProp
    "onchange"  -> SubmitProp
    "onclick"  -> SubmitProp
    "ondblclick" -> SubmitProp
    
    "onerror"  -> SubmitProp
    "onfocus"  -> SubmitProp
    "onkeydown"  -> SubmitProp
    "onkeypress" -> SubmitProp
    "onkeyup" -> SubmitProp
    
    "onload" -> SubmitProp 
    "onmousedown" -> SubmitProp
    "onmousemove" -> SubmitProp
    "onmouseout" -> SubmitProp
    "onmouseover" -> SubmitProp
    
    "onmouseup" -> SubmitProp
    "onreset" -> SubmitProp
    "onresize" -> SubmitProp
    "onselect" -> SubmitProp
    "onsubmit" -> SubmitProp
    
    "onunload" -> SubmitProp
    
  context-free syntax
  %%
    
    "if" "(" Exp ")" "{" TemplateElement* "}"      -> TemplateCall {reject}
    "else" "{" TemplateElement* "}"                -> TemplateCall {reject}
    "separated-by" "{" TemplateElement* "}"        -> TemplateCall {reject}

    "init" Block  		-> InitAction {cons("InitAction"),prefer}
    "init"              -> TemplateCallId {reject}
    "databind" Block    -> TemplateElement {cons("DataBindAction"),prefer}
    "databind"          -> TemplateCallId {reject}
    "render" Block    -> TemplateElement {cons("RenderAction"),prefer}
    "validate" Block    -> TemplateElement {cons("ValidateAction"),prefer}
    
    "action" ActionModifier* Id "(" {FormalArg ","}* ")" Block -> Action {cons("Action")}
    "ignore-validation" -> ActionModifier{cons("ActionModifierIgnoreValidation")}

  context-free syntax
    
    Id ".elements" -> TemplateCallId {cons("QualifiedElementsCall"),prefer}

module WebDSL-Lexical

exports

  lexical syntax
    Id -> TemplateCallId %% hook for reject rules on templatecall names
    [a-zA-Z][a-zA-Z0-9\_]* -> Id
    [a-zA-Z0-9\-\_\.]+       -> FileName
    {FileName "/"}+        -> ModuleName
    ~[\n\r]*               -> SectionName

  lexical restrictions
    Id         -/- [a-zA-Z0-9\_]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+            -> Int
    "-"? [0-9]+ "L"        -> Long

  lexical syntax
    "-"? FloatDigits
     ExponentPart? [fFdD]? -> Float
    [0-9]* "." [0-9]*      -> FloatDigits
    [0-9]+                 -> FloatDigits
    [eE] SignedInteger     -> ExponentPart
    [\+\-]? [0-9]+         -> SignedInteger

    "-"? [0-9]+            -> Float {reject}
    "."                    -> FloatDigits  {reject}

  lexical restrictions
    Int           -/- [0-9]
    FloatDigits   -/- [0-9]
    SignedInteger -/- [0-9]

  lexical syntax
    "\"" StringChar* "\""        -> String
    ~[\"\n]                      -> StringChar
    "\\\""                       -> StringChar

  lexical syntax
    [\ \t\n\r]                   -> LAYOUT
    "//" ~[\n\r]* ([\n\r] | Eof) -> LAYOUT
    "/*" CommentChar* "*/"       -> LAYOUT
                                 -> Eof
    ~[\*]                        -> CommentChar
    Asterisk                     -> CommentChar
    [\*]                         -> Asterisk

  lexical restrictions
    Asterisk   -/- [\/]
    Eof        -/- ~[]

  context-free restrictions
    LAYOUT?     -/- [\ \t\n\r]
    LAYOUT?     -/- [\/].[\/]
    LAYOUT?     -/- [\/].[\*]
    SectionName -/- ~[\n\r]

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word
  lexical restrictions
     Word -/- ~[\ \t\n\r\}]

  context-free restrictions
    "page" "local" "email" "feed" "template" "schedule" -/- [a-zA-Z0-9]

module WebDSL

imports
  WebDSL-Lexical
  WebDSL-UI
  WebDSL-Ajax
  WebDSL-Action
  WebDSL-DataModel
  WebDSL-DataValidation
  WebDSL-AccessControl
  WebDSL-XML
  WebDSL-JavaScript
  WebDSL-Regex
  WebDSL-Enums
  WebDSL-Styling
  WebDSL-PagedFor
  WebDSL-Derive
  WebDSL-Procedures
  WebDSL-ValidationAnnos
  WebDSL-Native
  WebDSL-Dispatch
  WebDSL-Exception
  WebDSL-Type
  WebDSL-Test
  WebDSL-TimeInterval
  WebDSL-Service
  WebDSL-Search
  WebDSL-Recommend

hiddens
  context-free start-symbols
    Unit

exports

  sorts
    Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
    SignedInteger String UNDEFINED Eof


  context-free syntax
    Id         -> QId
    QId "." Id -> QId {cons("Qualified")}
    Keyword    -> Id {reject} %% (not rejected as HQL or styling keyword)

  context-free syntax %% Types
    SimpleSort -> Sort
    GenericSort -> Sort
    RefSort -> Sort
    FunctionSort -> Sort
    
    Id                     -> SimpleSort {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">" -> GenericSort {cons("GenericSort")}
    "Ref" "<" Sort ">" -> RefSort {cons("RefSort")}
    "Ref" "<" Sort ">" -> GenericSort {reject}
  
    %% function type; optionally specify (named) args and return type
    "function" FunctionSortParams FunctionSortReturn -> FunctionSort {cons("FunctionSort")}
    -> FunctionSortParams {ast("[]")}
    "(" {FunctionSortParam ","}* ")" -> FunctionSortParams {ast("<1>")}
    Sort -> FunctionSortParam {cons("UnnamedArg")}
    Id ":" Sort -> FunctionSortParam {cons("Arg")}
    -> FunctionSortReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort -> FunctionSortReturn {ast("<1>")}
     "function" -> SimpleSort {reject}


    Id ":" Sort            -> FormalArg {cons("Arg")}

exports

  sorts Application Module Unit
  
  syntax

    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax

    "application" QId Definition+ Section* -> Application {cons("ApplicationDefs")}
    "application" QId Section*      -> Application {cons("Application")}

    "description" "{" Word* "}"     -> Description {cons("Description")}

    "note" "{" Word* "}"            -> Description {cons("Note")}

    Description                   -> Definition
    %%Description                   -> Definition {prefer}

    "module" ModuleName Section*  -> Module {cons("Module")}
    "module" ModuleName Definition+ Section*  -> Module {cons("ModuleDefs")}

    "imports" ModuleName          -> Definition {cons("Imports")}
    
    Application                   -> Unit
    Module                        -> Unit

exports

  sorts Action Statements Statement Exp

  context-free syntax

    Action		       	        -> Definition
    Statement*		   	        -> Statements
    NativeFunctionDeclaration   -> Definition
    NativeClassDeclaration      -> Definition



module WebDslMix[E]

imports
  WebDSL
  AccessControlMix
  StylingMix
  DeriveMix

exports

  lexical syntax

    [0-9]* -> MetaVarSuffix
    "_" [A-Za-z0-9\_\-]+ -> MetaVarSuffix

  context-free syntax
    "webdsl"  "|[" Application      "]|" -> E {cons("ToMetaExpr")}
              "|[" Application      "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section          "]|" -> E {cons("ToMetaExpr")}
              "|[" Section          "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
              "|[" Section*         "]|" -> E {cons("ToMetaExpr")}
    "webdsl"  "|[" TemplateElement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl*" "|[" TemplateElement* "]|" -> E {cons("ToMetaExpr")}

    "def"   "|[" Definition  "]|" -> E {cons("ToMetaExpr")}
    "def*"  "|[" Definition* "]|" -> E {cons("ToMetaExpr")}
    "fun"   "|[" Function  "]|"   -> E {cons("ToMetaExpr")}
    "fun*"  "|[" Function* "]|"   -> E {cons("ToMetaExpr")}
    "sdef"  "|["  SecurityDefinition   "]|" -> E {cons("ToMetaExpr")}
    "sdef*" "|["  SecurityDefinition*  "]|" -> E {cons("ToMetaExpr")}

    "webdsl" "|[" Description "]|" -> E {cons("ToMetaExpr")}
             "|[" Description "]|" -> E {cons("ToMetaExpr")}

  variables

    "app" [0-9]*                -> Application {prefer}
    "sec" [0-9]*                -> Section     {prefer}
    "sec" [0-9]* "*"            -> Section*    {prefer}
    "def" [0-9]*                -> Definition  {prefer}
    "def" [0-9]* "*"            -> Definition* {prefer}
    "procelem" [0-9]*           -> ProcedureElement  {prefer}
    "procelem" [0-9]* "*"       -> ProcedureElement* {prefer}
    "procelem_"[A-Za-z0-9]+     -> ProcedureElement  {prefer}
    "procelem_"[A-Za-z0-9]+ "*" -> ProcedureElement* {prefer}
    "processexp" [0-9]*         -> ProcessExp  {prefer}
    "processexp" [0-9]* "*"     -> ProcessExp* {prefer}
    "desc"[0-9]*                -> Description {prefer}
    "mod" [0-9]*                -> Modifier    {prefer}
    "mod" [0-9]* "*"            -> Modifier*   {prefer}

  context-free syntax

    "webdsl" "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
             "|[" Entity            "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration  "]|" -> E {cons("ToMetaExpr")}
             "|[" EntityBodyDeclaration  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
             "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
             "|[" Sort              "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
             "|[" {Sort ","}*       "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
             "|[" Annotation        "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}
             "|[" {Annotation ","}* "]|" -> E {cons("ToMetaExpr")}

  variables
    "ent" [0-9]*     -> Entity            {prefer}
    "prop"[0-9]*     -> Property          {prefer}
    "prop"[0-9]* "*" -> Property*         {prefer} %% doesn't seem to work, use ebd* instead
    "srt" MetaVarSuffix     -> Sort              {prefer}
    "srt" MetaVarSuffix "*" -> {Sort ","}*       {prefer}
    "ann" [0-9]*     -> Annotation        {prefer}
    "ann" [0-9]* "*" -> {Annotation ","}* {prefer}
    "k"   [0-9]*     -> PropKind          {prefer}
    
    "dprop"[0-9]*     -> DeriveProperty   {prefer}
    "dprop"[0-9]* "*" -> {DeriveProperty ","}*  {prefer}

  context-free syntax
    "tdef"      "|[" TemplateDefinition  "]|" -> E {cons("ToMetaExpr")}
    "farg"      "|[" FormalArg           "]|" -> E {cons("ToMetaExpr")}
    "farg*"     "|[" {FormalArg ","}*    "]|" -> E {cons("ToMetaExpr")}
    "procelem"  "|[" ProcedureElement    "]|" -> E {cons("ToMetaExpr")}
    "procelem*" "|[" ProcedureElement*   "]|" -> E {cons("ToMetaExpr")}
    "elem"      "|[" TemplateElement     "]|" -> E {cons("ToMetaExpr")}
    "elem*"     "|[" TemplateElement*    "]|" -> E {cons("ToMetaExpr")}
    "call"      "|[" TemplateCall        "]|" -> E {cons("ToMetaExpr")}
    "call*"     "|[" TemplateCall*       "]|" -> E {cons("ToMetaExpr")}
    "exp"       "|[" Exp                 "]|" -> E {cons("ToMetaExpr")}
    "passign"   "|[" PropertyAssignment  "]|" -> E {cons("ToMetaExpr")}
    "passign*"  "|[" PropertyAssignment* "]|" -> E {cons("ToMetaExpr")}

  variables
    "tdef"[0-9]*                -> TemplateDefinition {prefer}
    "farg"[0-9]*                -> FormalArg          {prefer}
    "farg" MetaVarSuffix "*"    -> {FormalArg ","}*   {prefer}
    "elem"[0-9]+                -> TemplateElement    {prefer} %%[0-9]+ instead of [0-9]*, otherwise elements() is split into elem-ents()
    "elem"[0-9]* "*"            -> TemplateElement*   {prefer}
    "elem_"[A-Za-z0-9]+         -> TemplateElement    {prefer}
    "elem_"[A-Za-z0-9]+ "*"     -> TemplateElement*   {prefer}
    "call"[0-9]*                -> TemplateCall       {prefer}
    "call"[0-9]* "*"            -> TemplateCall*      {prefer}
    "passign" MetaVarSuffix     -> PropertyAssignment          {prefer}
    "passign" MetaVarSuffix "*" -> {PropertyAssignment ","}*   {prefer}
%%    "req" MetaVarSuffix     -> TemplateArg          {prefer}
%%    "req" MetaVarSuffix "*" -> {TemplateArg ","}*   {prefer}
    "req" MetaVarSuffix "*"   -> TemplateArgs {prefer}
    "template-body" MetaVarSuffix -> TemplateBody{prefer}
    "withblock" MetaVarSuffix   -> TemplateWith       {prefer}
    "withdef" MetaVarSuffix     -> ArgDefine          {prefer}
    "withdef" MetaVarSuffix "*"     -> {ArgDefine ","}* {prefer}
 
    "talt"[0-9]*            -> TemplateCaseAlt {prefer}
    "talt"[0-9]* "*"        -> TemplateCaseAlt* {prefer}

  context-free syntax
    "webdsl" "|[" Action     "]|" -> E {cons("ToMetaExpr")}
             "|[" Action     "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "stat"   "|[" Statement  "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
             "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Case       "]|" -> E {cons("ToMetaExpr")}
             "|[" Case       "]|" -> E {cons("ToMetaExpr")}

  variables

    "_act" [0-9]*          -> Action     {prefer}
    "stat" [0-9]*          -> Statement  {prefer}
    "stat" [0-9]* "*"      -> Statement* {prefer}
    "stat_"[A-Za-z0-9]*    -> Statement  {prefer}
    "stat_"[A-Za-z0-9]*"*" -> Statement* {prefer}
    "block"[0-9]*          -> Block      {prefer}

    "alt"[0-9]*            -> Case {prefer}
    "alt"[0-9]* "*"        -> Case* {prefer}

  context-free syntax
    "webdsl:e" "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Exp         "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment  "]|" -> E {cons("ToMetaExpr")}
    "|[" Assignment* "]|" -> E {cons("ToMetaExpr")}

  variables

    "e"   [0-9\']*           -> Exp         {prefer}
    "e_"  [A-Za-z0-9\']+     -> Exp         {prefer}
    "e"   [0-9\']* "*"       -> {Exp ","}*  {prefer}
    "e_"  [A-Za-z0-9\']+ "*" -> {Exp ","}*  {prefer}
    "fltr"[0-9]*             -> Filter      {prefer}
    "asgn"[0-9]*             -> Assignment  {prefer}
    "asgn"[0-9]* "*"         -> Assignment* {prefer}
    "fun"[0-9]*              -> Function    {prefer}
    "fun"[0-9]* "*"          -> Function*   {prefer}
    "ebd"[0-9]*              -> EntityBodyDeclaration    {prefer}
    "ebd"[0-9]* "*"          -> EntityBodyDeclaration*   {prefer}

  variables

    "qid"[0-9]*                -> QId     {prefer}
    [xyz][0-9]*                -> Id      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> Id      {prefer}
    [xyz][0-9]*                -> TemplateCallId      {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> TemplateCallId      {prefer}
    [xyz] MetaVarSuffix        -> Identifier[[HQL]] {prefer} %%hql identifier
    %%[xyz]"_"[A-Za-z0-9\']+ "*" -> Id*     {prefer}
    [xyz][0-9]*                -> MatchId {prefer}
    [xyz]"_"[A-Za-z0-9]+       -> MatchId {prefer}
    "str"[0-9]*                -> String  {prefer}

    "const"[0-9]*              -> ConstValue {prefer}

  lexical syntax

    [\$][A-Za-z0-9]* -> IdVar
    [\$][A-Za-z0-9]* -> Id[[StrategoHost]]

  lexical restrictions

    IdVar -/- [A-Za-z0-9]

  variables

    IdVar -> Id {prefer}