definition

module DeriveMix
imports WebDSL-Derive

exports
  sorts WATER WATERTOKEN WATERTOKENSTART WATERTOKENSEPARATOR WATERTOKENSTAR

  lexical syntax
    [A-Za-z0-9\_]                        -> WATERTOKENSTART                 {recover, avoid}
    WATERTOKENSTART [A-Za-z0-9\_]*       -> WATERTOKEN                      
    ~[A-Za-z0-9\_\ \t\12\r\n\*]          -> WATERTOKENSEPARATOR             {recover, avoid}
    "*"                                  -> WATERTOKENSTAR                  {recover, avoid}
    WATERTOKEN                           -> WATER                           
    WATERTOKENSEPARATOR                  -> WATER                           
    WATERTOKENSTAR                       -> WATER                           
                                         -> WATEREOF                        
    "completion123"                      -> COMPLETIONPREFIX                {completion}
    "|#WATERTOKENSTAR|"                  -> WATERTOKENSTAR                  {completion}
    "|#RecommendConfig|"                 -> RecommendConfig                 {completion}
    "|#RecommendArgument|"               -> RecommendArgument               {completion}
    "|#RecommendConfigStaticOrder|"      -> RecommendConfigStaticOrder      {completion}
    "|#RecommendKey|"                    -> RecommendKey                    {completion}
    "|#FullTextAnalyzer|"                -> FullTextAnalyzer                {completion}
    "|#FullTextAnalyzerBody|"            -> FullTextAnalyzerBody            {completion}
    "|#Tokenizer|"                       -> Tokenizer                       {completion}
    "|#Argument|"                        -> Argument                        {completion}
    "|#SearchableAnno|"                  -> SearchableAnno                  {completion}
    "|#SearchNamespaceAnno|"             -> SearchNamespaceAnno             {completion}
    "|#SA-Argument|"                     -> SA-Argument                     {completion}
    "|#SearchMappingContent|"            -> SearchMappingContent            {completion}
    "|#MappingPart|"                     -> MappingPart                     {completion}
    "|#KW|"                              -> KW                              {completion}
    "|#SA-Key|"                          -> SA-Key                          {completion}
    "|#DEFAULT|"                         -> DEFAULT                         {completion}
    "|#DEFAULTSF|"                       -> DEFAULTSF                       {completion}
    "|#SearchMappingAnnoKW|"             -> SearchMappingAnnoKW             {completion}
    "|#INDEXORQUERY|"                    -> INDEXORQUERY                    {completion}
    "|#SearcherDef|"                     -> SearcherDef                     {completion}
    "|#QueryDef|"                        -> QueryDef                        {completion}
    "|#Offset|"                          -> Offset                          {completion}
    "|#MaxResults|"                      -> MaxResults                      {completion}
    "|#SortBy|"                          -> SortBy                          {completion}
    "|#ConstraintFilter|"                -> ConstraintFilter                {completion}
    "|#FacetDef|"                        -> FacetDef                        {completion}
    "|#SearchAttributes|"                -> SearchAttributes                {completion}
    "|#NamespaceConstraint|"             -> NamespaceConstraint             {completion}
    "|#SearchAttribute|"                 -> SearchAttribute                 {completion}
    "|#FacetExp|"                        -> FacetExp                        {completion}
    "|#FilterConstraint|"                -> FilterConstraint                {completion}
    "|#FieldsConstraint|"                -> FieldsConstraint                {completion}
    "|#QueryConstraint|"                 -> QueryConstraint                 {completion}
    "|#MatchGroup|"                      -> MatchGroup                      {completion}
    "|#QueryExp|"                        -> QueryExp                        {completion}
    "|#Slop|"                            -> Slop                            {completion}
    "|#Range|"                           -> Range                           {completion}
    "|#RangeOpen|"                       -> RangeOpen                       {completion}
    "|#RangeClose|"                      -> RangeClose                      {completion}
    "|#BoolOp|"                          -> BoolOp                          {completion}
    "|#Direction|"                       -> Direction                       {completion}
    "|#RetrievalExp|"                    -> RetrievalExp                    {completion}
    "|#SuggestType|"                     -> SuggestType                     {completion}
    "|#SuggestionPart|"                  -> SuggestionPart                  {completion}
    "|#QueryTerm|"                       -> QueryTerm                       {completion}
    "|#FIELD|"                           -> FIELD                           {completion}
    "|#SearcherKW|"                      -> SearcherKW                      {completion}
    "|#SearchMappingEmbedded|"           -> SearchMappingEmbedded           {completion}
    "|#SearchMapping|"                   -> SearchMapping                   {completion}
    "|#CharFilter|"                      -> CharFilter                      {completion}
    "|#TokenFilter|"                     -> TokenFilter                     {completion}
    "|#TimeIntervalPart|"                -> TimeIntervalPart                {completion}
    "|#TypeProperty|"                    -> TypeProperty                    {completion}
    "|#Catch|"                           -> Catch                           {completion}
    "|#DispatchEntryDefault|"            -> DispatchEntryDefault            {completion}
    "|#DispatchEntry|"                   -> DispatchEntry                   {completion}
    "|#DispatchNavigate|"                -> DispatchNavigate                {completion}
    "|#DispatchNavigateButton|"          -> DispatchNavigateButton          {completion}
    "|#DispatchNavigateCall|"            -> DispatchNavigateCall            {completion}
    "|#NativeFunctionDeclaration|"       -> NativeFunctionDeclaration       {completion}
    "|#NativeClassDeclaration|"          -> NativeClassDeclaration          {completion}
    "|#NativeClassAlias|"                -> NativeClassAlias                {completion}
    "|#NativeClassSuper|"                -> NativeClassSuper                {completion}
    "|#NativeClassFunction|"             -> NativeClassFunction             {completion}
    "|#NativeClassFunctionReturn|"       -> NativeClassFunctionReturn       {completion}
    "|#NativeClassFunctionStatic|"       -> NativeClassFunctionStatic       {completion}
    "|#NativeClassElement|"              -> NativeClassElement              {completion}
    "|#NativeType|"                      -> NativeType                      {completion}
    "|#PatternFlag|"                     -> PatternFlag                     {completion}
    "|#Procedure|"                       -> Procedure                       {completion}
    "|#ProcedureElement|"                -> ProcedureElement                {completion}
    "|#CallProcessExp|"                  -> CallProcessExp                  {completion}
    "|#ProcessExp|"                      -> ProcessExp                      {completion}
    "|#DeriveProperty|"                  -> DeriveProperty                  {completion}
    "|#DeriveBody|"                      -> DeriveBody                      {completion}
    "|#DeriveBodyElement|"               -> DeriveBodyElement               {completion}
    "|#Percentage|"                      -> Percentage                      {completion}
    "|#Ems|"                             -> Ems                             {completion}
    "|#Exs|"                             -> Exs                             {completion}
    "|#Length|"                          -> Length                          {completion}
    "|#Angle|"                           -> Angle                           {completion}
    "|#Time|"                            -> Time                            {completion}
    "|#Freq|"                            -> Freq                            {completion}
    "|#StyleDefinition|"                 -> StyleDefinition                 {completion}
    "|#SimpleSelector|"                  -> SimpleSelector                  {completion}
    "|#SelectorAttribute|"               -> SelectorAttribute               {completion}
    "|#Combinator|"                      -> Combinator                      {completion}
    "|#MatchDefinition|"                 -> MatchDefinition                 {completion}
    "|#MatchDefinitionArgs|"             -> MatchDefinitionArgs             {completion}
    "|#StyleVarDecl|"                    -> StyleVarDecl                    {completion}
    "|#StyleStatement|"                  -> StyleStatement                  {completion}
    "|#StyleExpression|"                 -> StyleExpression                 {completion}
    "|#StyleValueExtension|"             -> StyleValueExtension             {completion}
    "|#Uri|"                             -> Uri                             {completion}
    "|#Hash|"                            -> Hash                            {completion}
    "|#LayoutDefinition|"                -> LayoutDefinition                {completion}
    "|#LayoutStatement|"                 -> LayoutStatement                 {completion}
    "|#LayoutExpression|"                -> LayoutExpression                {completion}
    "|#LayoutExpressions|"               -> LayoutExpressions               {completion}
    "|#EnumValue|"                       -> EnumValue                       {completion}
    "|#RegexExp|"                        -> RegexExp                        {completion}
    "|#Pattern|"                         -> Pattern                         {completion}
    "|#Quantifier|"                      -> Quantifier                      {completion}
    "|#Atom|"                            -> Atom                            {completion}
    "|#CharacterClass|"                  -> CharacterClass                  {completion}
    "|#BracketItem|"                     -> BracketItem                     {completion}
    "|#ClassKeyword|"                    -> ClassKeyword                    {completion}
    "|#BracketLiteral|"                  -> BracketLiteral                  {completion}
    "|#AtomLiteral|"                     -> AtomLiteral                     {completion}
    "|#AllChars|"                        -> AllChars                        {completion}
    "|#AtomCharacter|"                   -> AtomCharacter                   {completion}
    "|#BracketCharacter|"                -> BracketCharacter                {completion}
    "|#QuotablePatternSymbol|"           -> QuotablePatternSymbol           {completion}
    "|#RegexID|"                         -> RegexID                         {completion}
    "|#JSPart|"                          -> JSPart                          {completion}
    "|#Attribute|"                       -> Attribute                       {completion}
    "|#CommonAttribute|"                 -> CommonAttribute                 {completion}
    "|#KEYWORD|"                         -> KEYWORD                         {completion}
    "|#Qualifier|"                       -> Qualifier                       {completion}
    "|#MatchArgs|"                       -> MatchArgs                       {completion}
    "|#AccessControlRule|"               -> AccessControlRule               {completion}
    "|#AccessControlDefinition|"         -> AccessControlDefinition         {completion}
    "|#AccessControlPointcutElement|"    -> AccessControlPointcutElement    {completion}
    "|#AccessControlPointcut|"           -> AccessControlPointcut           {completion}
    "|#PolicyExp|"                       -> PolicyExp                       {completion}
    "|#ValidateEntity|"                  -> ValidateEntity                  {completion}
    "|#Entity|"                          -> Entity                          {completion}
    "|#EntityBodyDeclaration|"           -> EntityBodyDeclaration           {completion}
    "|#Property|"                        -> Property                        {completion}
    "|#PropKind|"                        -> PropKind                        {completion}
    "|#Annotation|"                      -> Annotation                      {completion}
    "|#DeleteStatement|"                 -> DeleteStatement                 {completion}
    "|#Union|"                           -> Union                           {completion}
    "|#SelectClause|"                    -> SelectClause                    {completion}
    "|#Distinct|"                        -> Distinct                        {completion}
    "|#NewExpression|"                   -> NewExpression                   {completion}
    "|#SelectObject|"                    -> SelectObject                    {completion}
    "|#FromClause|"                      -> FromClause                      {completion}
    "|#JoinType|"                        -> JoinType                        {completion}
    "|#FromJoin|"                        -> FromJoin                        {completion}
    "|#Fetch|"                           -> Fetch                           {completion}
    "|#WithClause|"                      -> WithClause                      {completion}
    "|#InClassDeclaration|"              -> InClassDeclaration              {completion}
    "|#InCollectionDeclaration|"         -> InCollectionDeclaration         {completion}
    "|#InCollectionElementsDeclaration|" -> InCollectionElementsDeclaration {completion}
    "|#AsAlias|"                         -> AsAlias                         {completion}
    "|#PropertyFetch|"                   -> PropertyFetch                   {completion}
    "|#GroupByClause|"                   -> GroupByClause                   {completion}
    "|#OrderByClause|"                   -> OrderByClause                   {completion}
    "|#AscendingOrDescending|"           -> AscendingOrDescending           {completion}
    "|#HavingClause|"                    -> HavingClause                    {completion}
    "|#WhereClause|"                     -> WhereClause                     {completion}
    "|#SelectedPropertiesList|"          -> SelectedPropertiesList          {completion}
    "|#QuotedAliasedExpression|"         -> QuotedAliasedExpression         {completion}
    "|#IdParameter|"                     -> IdParameter                     {completion}
    "|#NumParameter|"                    -> NumParameter                    {completion}
    "|#Expression|"                      -> Expression                      {completion}
    "|#Constant|"                        -> Constant                        {completion}
    "|#Identifier|"                      -> Identifier                      {completion}
    "|#Path|"                            -> Path                            {completion}
    "|#QuotedString|"                    -> QuotedString                    {completion}
    "|#FunctionReturn|"                  -> FunctionReturn                  {completion}
    "|#Function|"                        -> Function                        {completion}
    "|#StaticEntityFunction|"            -> StaticEntityFunction            {completion}
    "|#ReturnType|"                      -> ReturnType                      {completion}
    "|#FunctionExp|"                     -> FunctionExp                     {completion}
    "|#FunctionExpParams|"               -> FunctionExpParams               {completion}
    "|#FunctionRef|"                     -> FunctionRef                     {completion}
    "|#Block|"                           -> Block                           {completion}
    "|#VarDeclStat|"                     -> VarDeclStat                     {completion}
    "|#VarDecl|"                         -> VarDecl                         {completion}
    "|#Case|"                            -> Case                            {completion}
    "|#ObjectCreation|"                  -> ObjectCreation                  {completion}
    "|#ObjectPropertyAssignment|"        -> ObjectPropertyAssignment        {completion}
    "|#Assignment|"                      -> Assignment                      {completion}
    "|#Mapping|"                         -> Mapping                         {completion}
    "|#ForExp|"                          -> ForExp                          {completion}
    "|#HqlExp|"                          -> HqlExp                          {completion}
    "|#DslExp|"                          -> DslExp                          {completion}
    "|#EmailCall|"                       -> EmailCall                       {completion}
    "|#EventArg|"                        -> EventArg                        {completion}
    "|#Statement|"                       -> Statement                       {completion}
    "|#AjaxVisibility|"                  -> AjaxVisibility                  {completion}
    "|#AjaxStatement|"                   -> AjaxStatement                   {completion}
    "|#PHExp|"                           -> PHExp                           {completion}
    "|#TemplateArgs|"                    -> TemplateArgs                    {completion}
    "|#TemplateArg|"                     -> TemplateArg                     {completion}
    "|#OptLocalRedefineArgs|"            -> OptLocalRedefineArgs            {completion}
    "|#TemplateDefinition|"              -> TemplateDefinition              {completion}
    "|#Modifier|"                        -> Modifier                        {completion}
    "|#Filter|"                          -> Filter                          {completion}
    "|#OrderExp|"                        -> OrderExp                        {completion}
    "|#Limit|"                           -> Limit                           {completion}
    "|#ForSeparator|"                    -> ForSeparator                    {completion}
    "|#ElseIfTempl|"                     -> ElseIfTempl                     {completion}
    "|#ElseTempl|"                       -> ElseTempl                       {completion}
    "|#TemplateCaseAlt|"                 -> TemplateCaseAlt                 {completion}
    "|#TemplateCallNoBody|"              -> TemplateCallNoBody              {completion}
    "|#TemplateCallNoAssigns|"           -> TemplateCallNoAssigns           {completion}
    "|#TemplateCallPropsNoBody|"         -> TemplateCallPropsNoBody         {completion}
    "|#TemplateCallProps|"               -> TemplateCallProps               {completion}
    "|#TemplateCallPropsNoArgs|"         -> TemplateCallPropsNoArgs         {completion}
    "|#TemplateBody|"                    -> TemplateBody                    {completion}
    "|#ArgDefine|"                       -> ArgDefine                       {completion}
    "|#PageCall|"                        -> PageCall                        {completion}
    "|#ActionCall|"                      -> ActionCall                      {completion}
    "|#InlineAction|"                    -> InlineAction                    {completion}
    "|#Exp|"                             -> Exp                             {completion}
    "|#PropertyValue|"                   -> PropertyValue                   {completion}
    "|#PropertyAssignment|"              -> PropertyAssignment              {completion}
    "|#SubmitProp|"                      -> SubmitProp                      {completion}
    "|#TemplateCall|"                    -> TemplateCall                    {completion}
    "|#InitAction|"                      -> InitAction                      {completion}
    "|#TemplateElement|"                 -> TemplateElement                 {completion}
    "|#Action|"                          -> Action                          {completion}
    "|#ActionModifier|"                  -> ActionModifier                  {completion}
    "|#TemplateCallId|"                  -> TemplateCallId                  {completion}
    "|#ModuleName|"                      -> ModuleName                      {completion}
    "|#Long|"                            -> Long                            {completion}
    "|#FloatDigits|"                     -> FloatDigits                     {completion}
    "|#StringChar|"                      -> StringChar                      {completion}
    "|#QId|"                             -> QId                             {completion}
    "|#RefSort|"                         -> RefSort                         {completion}
    "|#GenericSort|"                     -> GenericSort                     {completion}
    "|#FunctionSort|"                    -> FunctionSort                    {completion}
    "|#FunctionSortParams|"              -> FunctionSortParams              {completion}
    "|#FunctionSortParam|"               -> FunctionSortParam               {completion}
    "|#FunctionSortReturn|"              -> FunctionSortReturn              {completion}
    "|#SimpleSort|"                      -> SimpleSort                      {completion}
    "|#FormalArg|"                       -> FormalArg                       {completion}
    "|#Section|"                         -> Section                         {completion}
    "|#Application|"                     -> Application                     {completion}
    "|#Description|"                     -> Description                     {completion}
    "|#Definition|"                      -> Definition                      {completion}
    "|#MetaVarSuffix|"                   -> MetaVarSuffix                   {completion}
    "|#E|"                               -> E                               {completion}
    "|#Overlay|"                         -> Overlay                         {completion}
    "|#ScopeLabels|"                     -> ScopeLabels                     {completion}
    "|#DynRuleDef|"                      -> DynRuleDef                      {completion}
    "|#DynRuleId|"                       -> DynRuleId                       {completion}
    "|#DynRuleScopeId|"                  -> DynRuleScopeId                  {completion}
    "|#RuleDec|"                         -> RuleDec                         {completion}
    "|#RuleNames|"                       -> RuleNames                       {completion}
    "|#RuleDef|"                         -> RuleDef                         {completion}
    "|#Rule|"                            -> Rule                            {completion}
    "|#RuleCond|"                        -> RuleCond                        {completion}
    "|#StrategyAngle|"                   -> StrategyAngle                   {completion}
    "|#StrategyCurly|"                   -> StrategyCurly                   {completion}
    "|#SwitchCase|"                      -> SwitchCase                      {completion}
    "|#Kind|"                            -> Kind                            {completion}
    "|#Sdecl|"                           -> Sdecl                           {completion}
    "|#Sort|"                            -> Sort                            {completion}
    "|#Opdecl|"                          -> Opdecl                          {completion}
    "|#FunType|"                         -> FunType                         {completion}
    "|#ArgType|"                         -> ArgType                         {completion}
    "|#Wld|"                             -> Wld                             {completion}
    "|#Term|"                            -> Term                            {completion}
    "|#PreTerm|"                         -> PreTerm                         {completion}
    "|#StrategyDef|"                     -> StrategyDef                     {completion}
    "|#Anno|"                            -> Anno                            {completion}
    "|#Typedid|"                         -> Typedid                         {completion}
    "|#StrategyParen|"                   -> StrategyParen                   {completion}
    "|#Strategy|"                        -> Strategy                        {completion}
    "|#Module|"                          -> Module                          {completion}
    "|#ImportModName|"                   -> ImportModName                   {completion}
    "|#Decl|"                            -> Decl                            {completion}
    "|#StringQuotedPart1|"               -> StringQuotedPart1               {completion}
    "|#Dollar1|"                         -> Dollar1                         {completion}
    "|#StringQuotedPart2|"               -> StringQuotedPart2               {completion}
    "|#Dollar2|"                         -> Dollar2                         {completion}
    "|#StringQuotedPart3|"               -> StringQuotedPart3               {completion}
    "|#Dollar3|"                         -> Dollar3                         {completion}
    "|#StringQuotation|"                 -> StringQuotation                 {completion}
    "|#StringQuotedPart4|"               -> StringQuotedPart4               {completion}
    "|#Dollar4|"                         -> Dollar4                         {completion}
    "|#String|"                          -> String                          {completion}
    "|#Char|"                            -> Char                            {completion}
    "|#ModName|"                         -> ModName                         {completion}
    "|#LId|"                             -> LId                             {completion}
    "|#Id|"                              -> Id                              {completion}
    "|#Keyword|"                         -> Keyword                         {completion}
    "|#ShortCom|"                        -> ShortCom                        {completion}
    "|#LongCom|"                         -> LongCom                         {completion}
    "|#Asterisk|"                        -> Asterisk                        {completion}

  lexical restrictions
    WATERTOKEN -/- [A-Za-z0-9\_]
    WATERTOKENSTAR -/- [\/]

  context-free syntax
    WATER -> LAYOUT {cons("WATER")}

  (

  sorts WATEREOF

  lexical restrictions
    WATEREOF -/- ~[]

  lexical syntax
    %% Lexical insertion recovery rules                                     
                                                -> "derivebodyelem"         {recover, cons("INSERTION")}
                                                -> "stsec"                  {recover, cons("INSERTION")}
                                                -> "stsec*"                 {recover, cons("INSERTION")}
                                                -> "stdef"                  {recover, cons("INSERTION")}
                                                -> "stdef*"                 {recover, cons("INSERTION")}
                                                -> "ststat"                 {recover, cons("INSERTION")}
                                                -> "ststat*"                {recover, cons("INSERTION")}
                                                -> "stsel"                  {recover, cons("INSERTION")}
                                                -> "stssel"                 {recover, cons("INSERTION")}
                                                -> "stcomb"                 {recover, cons("INSERTION")}
                                                -> "stprop"                 {recover, cons("INSERTION")}
                                                -> "stprop*"                {recover, cons("INSERTION")}
                                                -> "stval"                  {recover, cons("INSERTION")}
                                                -> "stval*"                 {recover, cons("INSERTION")}
                                                -> "acrule"                 {recover, cons("INSERTION")}
                                                -> "acdef"                  {recover, cons("INSERTION")}
                                                -> "margs"                  {recover, cons("INSERTION")}
                                                -> "pexp"                   {recover, cons("INSERTION")}
                                                -> "recommend"              {recover, cons("INSERTION")}
                                                -> "recommenderStaticOrder" {recover, cons("INSERTION")}
                                                -> "char filter"            {recover, cons("INSERTION")}
                                                -> "tokenizer"              {recover, cons("INSERTION")}
                                                -> "token filter"           {recover, cons("INSERTION")}
                                                -> "namespace"              {recover, cons("INSERTION")}
                                                -> "lucene"                 {recover, cons("INSERTION")}
                                                -> "matching"               {recover, cons("INSERTION")}
                                                -> "searchmapping"          {recover, cons("INSERTION")}
                                                -> "charfilter"             {recover, cons("INSERTION")}
                                                -> "tokenfilter"            {recover, cons("INSERTION")}
                                                -> "service"                {recover, cons("INSERTION")}
                                                -> "invoke"                 {recover, cons("INSERTION")}
                                                -> "type"                   {recover, cons("INSERTION")}
                                                -> "native"                 {recover, cons("INSERTION")}
                                                -> "constructor"            {recover, cons("INSERTION")}
                                                -> "minlength"              {recover, cons("INSERTION")}
                                                -> "maxlength"              {recover, cons("INSERTION")}
                                                -> "pattern"                {recover, cons("INSERTION")}
                                                -> "range"                  {recover, cons("INSERTION")}
                                                -> "minrange"               {recover, cons("INSERTION")}
                                                -> "maxrange"               {recover, cons("INSERTION")}
                                                -> "digits"                 {recover, cons("INSERTION")}
                                                -> "size"                   {recover, cons("INSERTION")}
                                                -> "minsize"                {recover, cons("INSERTION")}
                                                -> "maxsize"                {recover, cons("INSERTION")}
                                                -> "procedure"              {recover, cons("INSERTION")}
                                                -> "auto"                   {recover, cons("INSERTION")}
                                                -> "who"                    {recover, cons("INSERTION")}
                                                -> "when"                   {recover, cons("INSERTION")}
                                                -> "do"                     {recover, cons("INSERTION")}
                                                -> "done"                   {recover, cons("INSERTION")}
                                                -> "enabled"                {recover, cons("INSERTION")}
                                                -> "disabled"               {recover, cons("INSERTION")}
                                                -> "view"                   {recover, cons("INSERTION")}
                                                -> "process"                {recover, cons("INSERTION")}
                                                -> "processed"              {recover, cons("INSERTION")}
    "'"                                         -> INSERTOPENQUOTE          {recover}
    INSERTOPENQUOTE ~[\"\n]* "\n"               -> String                   {cons("INSERTEND")}
    INSERTOPENQUOTE ~[\"\n]* WATEREOF           -> String                   {cons("INSERTEND")}
                                                -> "theme"                  {recover, cons("INSERTION")}
                                                -> "url"                    {recover, cons("INSERTION")}
                                                -> "#"                      {recover, cons("INSERTION")}
                                                -> "float"                  {recover, cons("INSERTION")}
                                                -> "|"                      {recover, cons("INSERTION")}
                                                -> "enum"                   {recover, cons("INSERTION")}
                                                -> "/"                      {recover, cons("INSERTION")}
                                                -> "}?"                     {recover, cons("INSERTION")}
                                                -> "}+"                     {recover, cons("INSERTION")}
                                                -> "\\E"                    {recover, cons("INSERTION")}
                                                -> "\\0"                    {recover, cons("INSERTION")}
                                                -> "\\x"                    {recover, cons("INSERTION")}
                                                -> "\\u"                    {recover, cons("INSERTION")}
                                                -> "\\c"                    {recover, cons("INSERTION")}
                                                -> "/>"                     {recover, cons("INSERTION")}
                                                -> "principal"              {recover, cons("INSERTION")}
                                                -> "predicate"              {recover, cons("INSERTION")}
                                                -> "pointcut"               {recover, cons("INSERTION")}
                                                -> "validatecreate"         {recover, cons("INSERTION")}
                                                -> "validateupdate"         {recover, cons("INSERTION")}
                                                -> "validatedelete"         {recover, cons("INSERTION")}
                                                -> "globals"                {recover, cons("INSERTION")}
                                                -> "entity"                 {recover, cons("INSERTION")}
                                                -> "session"                {recover, cons("INSERTION")}
                                                -> "inverse"                {recover, cons("INSERTION")}
                                                -> "inverseSlave"           {recover, cons("INSERTION")}
                                                -> "allowed"                {recover, cons("INSERTION")}
                                                -> "length"                 {recover, cons("INSERTION")}
                                                -> "format"                 {recover, cons("INSERTION")}
                                                -> "collation"              {recover, cons("INSERTION")}
                                                -> "iderror"                {recover, cons("INSERTION")}
                                                -> "idemptyerror"           {recover, cons("INSERTION")}
                                                -> "delete"                 {recover, cons("INSERTION")}
                                                -> "object"                 {recover, cons("INSERTION")}
                                                -> "outer"                  {recover, cons("INSERTION")}
                                                -> "properties"             {recover, cons("INSERTION")}
                                                -> "'"                      {recover, cons("INSERTION")}
                                                -> "."                      {recover, cons("INSERTION")}
    "'"                                         -> INSERTOPENQUOTE          {recover}
    INSERTOPENQUOTE ( ~[\'] | "\\'" )* "\n"     -> QuotedString             {cons("INSERTEND")}
    INSERTOPENQUOTE ( ~[\'] | "\\'" )* WATEREOF -> QuotedString             {cons("INSERTEND")}
                                                -> "function."              {recover, cons("INSERTION")}
                                                -> ";"                      {recover, cons("INSERTION")}
                                                -> "requires"               {recover, cons("INSERTION")}
    "\""                                        -> INSERTOPENQUOTE          {recover}
    INSERTOPENQUOTE StringChar* "\n"            -> String                   {cons("INSERTEND")}
    INSERTOPENQUOTE StringChar* WATEREOF        -> String                   {cons("INSERTEND")}
    "/*"                                        -> INSERTSTART              {recover}
    INSERTSTART CommentChar* WATEREOF           -> LAYOUT                   {cons("INSERTEND")}
                                                -> "description"            {recover, cons("INSERTION")}
                                                -> "note"                   {recover, cons("INSERTION")}
                                                -> "webdsl*"                {recover, cons("INSERTION")}
                                                -> "def"                    {recover, cons("INSERTION")}
                                                -> "def*"                   {recover, cons("INSERTION")}
                                                -> "fun"                    {recover, cons("INSERTION")}
                                                -> "fun*"                   {recover, cons("INSERTION")}
                                                -> "sdef"                   {recover, cons("INSERTION")}
                                                -> "sdef*"                  {recover, cons("INSERTION")}
                                                -> "tdef"                   {recover, cons("INSERTION")}
                                                -> "farg"                   {recover, cons("INSERTION")}
                                                -> "farg*"                  {recover, cons("INSERTION")}
                                                -> "procelem"               {recover, cons("INSERTION")}
                                                -> "procelem*"              {recover, cons("INSERTION")}
                                                -> "elem"                   {recover, cons("INSERTION")}
                                                -> "elem*"                  {recover, cons("INSERTION")}
                                                -> "call*"                  {recover, cons("INSERTION")}
                                                -> "exp"                    {recover, cons("INSERTION")}
                                                -> "passign"                {recover, cons("INSERTION")}
                                                -> "passign*"               {recover, cons("INSERTION")}
                                                -> "stat"                   {recover, cons("INSERTION")}
                                                -> "webdsl"                 {recover, cons("INSERTION")}
                                                -> "webdsl:e"               {recover, cons("INSERTION")}
                                                -> "]|"                     {recover, cons("INSERTION")}
                                                -> "|["                     {recover, cons("INSERTION")}
                                                -> "|}"                     {recover, cons("INSERTION")}
                                                -> ">"                      {recover, cons("INSERTION")}
                                                -> "\\"                     {recover, cons("INSERTION")}
                                                -> "]"                      {recover, cons("INSERTION")}
                                                -> "sorts"                  {recover, cons("INSERTION")}
                                                -> "constructors"           {recover, cons("INSERTION")}
                                                -> "*"                      {recover, cons("INSERTION")}
                                                -> "end"                    {recover, cons("INSERTION")}
                                                -> "}"                      {recover, cons("INSERTION")}
                                                -> ","                      {recover, cons("INSERTION")}
                                                -> ")"                      {recover, cons("INSERTION")}
                                                -> "imports"                {recover, cons("INSERTION")}
                                                -> "strategies"             {recover, cons("INSERTION")}
                                                -> "signature"              {recover, cons("INSERTION")}
                                                -> "overlays"               {recover, cons("INSERTION")}
    "\""                                        -> INSERTOPENQUOTE          {recover}
    INSERTOPENQUOTE StrChar* "\n"               -> String                   {cons("INSERTEND")}
    INSERTOPENQUOTE StrChar* WATEREOF           -> String                   {cons("INSERTEND")}
    "'"                                         -> INSERTOPENQUOTE          {recover}
    INSERTOPENQUOTE CharChar "\n"               -> Char                     {cons("INSERTEND")}
    INSERTOPENQUOTE CharChar WATEREOF           -> Char                     {cons("INSERTEND")}
    "/*"                                        -> INSERTSTART              {recover}
    INSERTSTART CommChar* WATEREOF              -> LongCom                  {cons("INSERTEND")}

  syntax
    %% Kernel syntax insertion recovery rules                          
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket1-LEX> "\n"     -> StringQuotedPart1 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket1-LEX> WATEREOF -> StringQuotedPart1 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket2-LEX> "\n"     -> StringQuotedPart2 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket2-LEX> WATEREOF -> StringQuotedPart2 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket3-LEX> "\n"     -> StringQuotedPart3 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket3-LEX> WATEREOF -> StringQuotedPart3 {cons("INSERTEND")}
    "$"                                           -> INSERTOPENQUOTE   {recover}
    INSERTOPENQUOTE <QuotedBracket4-LEX> "\n"     -> StringQuotedPart4 {cons("INSERTEND")}
    INSERTOPENQUOTE <QuotedBracket4-LEX> WATEREOF -> StringQuotedPart4 {cons("INSERTEND")}

  )

  (

  context-free syntax
    "derivebodyelem" "|[" DeriveBodyElement "]|" -> E {cons("ToMetaExpr")}

  variables
    "bodyelem" [0-9]*            -> DeriveBodyElement  {prefer}
    "bodyelem_" [A-Za-z0-9]+     -> DeriveBodyElement  {prefer}
    "bodyelem" [0-9]* "*"        -> DeriveBodyElement* {prefer}
    "bodyelem_" [A-Za-z0-9]+ "*" -> DeriveBodyElement* {prefer}

  )

module StylingMix
imports WebDSL-Styling

exports
  context-free syntax
    "stsec" "|[" StyleSection "]|"      -> E {cons("ToMetaExpr")}
    "|[" StyleSection "]|"              -> E {cons("ToMetaExpr")}
    "stsec*" "|[" StyleSection* "]|"    -> E {cons("ToMetaExpr")}
    "stdef" "|[" StyleDefinition "]|"   -> E {cons("ToMetaExpr")}
    "|[" StyleDefinition "]|"           -> E {cons("ToMetaExpr")}
    "stdef*" "|[" StyleDefinition* "]|" -> E {cons("ToMetaExpr")}
    "|[" StyleDefinition* "]|"          -> E {cons("ToMetaExpr")}
    "ststat" "|[" StyleStatement "]|"   -> E {cons("ToMetaExpr")}
    "|[" StyleStatement "]|"            -> E {cons("ToMetaExpr")}
    "ststat*" "|[" StyleStatement* "]|" -> E {cons("ToMetaExpr")}
    "|[" StyleStatement* "]|"           -> E {cons("ToMetaExpr")}

  variables
    "stsec" [0-9]*      -> StyleSection      {prefer}
    "stsec*" [0-9]* "*" -> StyleSection      {prefer}
    "stdef" [0-9]*      -> StyleDefinition   {prefer}
    "stdef" [0-9]* "*"  -> StyleDefinition*  {prefer}
    "ststat" [0-9]*     -> StyleStatement    {prefer}
    "ststat" [0-9]* "*" -> StyleStatement*   {prefer}
    "stdecl" [0-9]*     -> StyleDeclaration  {prefer}
    "stdecl" [0-9]* "*" -> StyleDeclaration* {prefer}

  context-free syntax
    "stsel" "|[" Selector "]|"                                 -> E {cons("ToMetaExpr")}
    "stssel" "|[" SimpleSelector "]|"                          -> E {cons("ToMetaExpr")}
    "stcomb" "|[" Combinator "]|"                              -> E {cons("ToMetaExpr")}
    "|[" ( Combinator SimpleSelector ) "]|"                    -> E {cons("ToMetaExpr")}
    "|[" ( Combinator SimpleSelector )* "]|"                   -> E {cons("ToMetaExpr")}
    "|[" ( Combinator SimpleSelector SelectorAttribute ) "]|"  -> E {cons("ToMetaExpr")}
    "|[" ( Combinator SimpleSelector SelectorAttribute )* "]|" -> E {cons("ToMetaExpr")}

  variables
    "stsel" [0-9]*         -> Selector                   {prefer}
    "stssel" [0-9]*        -> SimpleSelector             {prefer}
    "stcomb" [0-9]*        -> Combinator                 {prefer}
    "stcombsel" [0-9]*     -> (CombinatorSimpleSelector) {prefer}
    "stmargs" [0-9]*       -> MatchDefinitionArgs        {prefer}
    "stmid" [0-9]*         -> MatchIdent                 {prefer}
    [abc] "_" [A-Za-z0-9]+ -> MatchIdent                 {prefer}

  context-free syntax
    "stprop" "|[" StyleProperty "]|"        -> E {cons("ToMetaExpr")}
    "stprop*" "|[" StyleProperty* "]|"      -> E {cons("ToMetaExpr")}
    "stprop" "|[" StylePropertyValue "]|"   -> E {cons("ToMetaExpr")}
    "stprop*" "|[" StylePropertyValue* "]|" -> E {cons("ToMetaExpr")}
    "|[" StyleExpression "]|"               -> E {cons("ToMetaExpr")}
    "|[" StyleValueExtension "]|"           -> E {cons("ToMetaExpr")}
    "stval" "|[" StyleValue "]|"            -> E {cons("ToMetaExpr")}
    "stval*" "|[" StyleValue* "]|"          -> E {cons("ToMetaExpr")}

  variables
    "stprop" [0-9]*     -> StyleProperty       {prefer}
    "stprop" [0-9]* "*" -> StyleProperty*      {prefer}
    "stprop" [0-9]*     -> StylePropertyValue  {prefer}
    "stprop" [0-9]* "*" -> StylePropertyValue* {prefer}
    "stexpr" [0-9]      -> StyleExpression     {prefer}
    "stvalex" [0-9]     -> StyleValueExtension {prefer}
    "stval" [0-9]*      -> StyleValue          {prefer}
    "stval" [0-9]* "*"  -> StyleValue*         {prefer}

module AccessControlMix
imports WebDSL-AccessControl

exports
  context-free syntax
    "acrule" "|[" AccessControlRule "]|"      -> E {cons("ToMetaExpr")}
    "|[" AccessControlRule "]|"               -> E {cons("ToMetaExpr")}
    "acdef" "|[" AccessControlDefinition "]|" -> E {cons("ToMetaExpr")}
    "|[" AccessControlDefinition "]|"         -> E {cons("ToMetaExpr")}

  variables
    "acrule" [0-9]*     -> AccessControlRule        {prefer}
    "acrule" [0-9]* "*" -> AccessControlRule*       {prefer}
    "acdef" [0-9]*      -> AccessControlDefinition  {prefer}
    "acdef" [0-9]* "*"  -> AccessControlDefinition* {prefer}

  context-free syntax
    "margs" "|[" MatchArgs "]|" -> E {cons("ToMetaExpr")}
    "|[" MatchArgs "]|"         -> E {cons("ToMetaExpr")}

  variables
    "margs" [0-9]* -> MatchArgs {prefer}

  context-free syntax
    "pexp" "|[" PolicyExp "]|" -> E {cons("ToMetaExpr")}
    "|[" PolicyExp "]|"        -> E {cons("ToMetaExpr")}

  variables
    "pexp" [0-9]* -> PolicyExp {prefer}

  variables
    "mid" [0-9]*           -> MatchId {prefer}
    [xyz] "_" [A-Za-z0-9]+ -> MatchId {prefer}

module WebDSL-Recommend
imports WebDSL-Lexical

exports
  sorts Definition Annotation

  context-free syntax
    RecommendConfig                                                                                                                                                              -> Definition                 
    "recommend" Id "{" RecommendArgument* "}"                                                                                                                                    -> RecommendConfig            {cons("RecommendConfig")}
    RecommendKey "=" RecommendKeyValue                                                                                                                                           -> RecommendArgument          {cons("RecommendArgument")}
    RecommendConfigStaticOrder                                                                                                                                                   -> Definition                 
    "recommenderStaticOrder" Id "{" RecommendUser RecommendItem RecommendValue RecommendAlgorithm RecommendNeighborAlg RecommendNeighborSize RecommendType RecommendSchedule "}" -> RecommendConfigStaticOrder {cons("RecommendConfigStaticOrder")}
    Id                                                                                                                                                                           -> RecommendUser              {cons("RecommendUser")}
    Id                                                                                                                                                                           -> RecommendItem              {cons("RecommendItem")}
    Id                                                                                                                                                                           -> RecommendValue             {cons("RecommendValue")}
    Id                                                                                                                                                                           -> RecommendAlgorithm         {cons("RecommendAlgorithm")}
    Id                                                                                                                                                                           -> RecommendNeighborAlg       {cons("RecommendNeighborAlg")}
    Id                                                                                                                                                                           -> RecommendNeighborSize      {cons("RecommendNeighborSize")}
    Id                                                                                                                                                                           -> RecommendType              {cons("RecommendType")}
    Id                                                                                                                                                                           -> RecommendSchedule          {cons("RecommendSchedule")}

  lexical syntax
    "schedule"         -> RecommendKey 
    "type"             -> RecommendKey 
    "neighborhoodalg"  -> RecommendKey 
    "neighborhoodsize" -> RecommendKey 
    "algorithm"        -> RecommendKey 
    "user"             -> RecommendKey 
    "item"             -> RecommendKey 
    "value"            -> RecommendKey 

  context-free syntax
    Id           -> RecommendKeyValue 
    Int          -> RecommendKeyValue 
    TimeInterval -> RecommendKeyValue 

module WebDSL-Search
imports WebDSL-Lexical

exports
  sorts Definition Annotation Exp

  context-free syntax
    FullTextAnalyzer                                                                          -> Definition              
    DEFAULT? "analyzer" Id "{" FullTextAnalyzerBody "}"                                       -> FullTextAnalyzer        {cons("FullTextAnalyzer")}
    FullTextAnalyzerBodyDef                                                                   -> FullTextAnalyzerBody    
    INDEXORQUERY "{" FullTextAnalyzerBodyDef "}" INDEXORQUERY "{" FullTextAnalyzerBodyDef "}" -> FullTextAnalyzerBody    {cons("DualFullTextAnalyzerBodyDef")}
    CharFilter* Tokenizer TokenFilter*                                                        -> FullTextAnalyzerBodyDef {cons("FullTextAnalyzerBodyDef")}
    "char filter" "=" CHARFILTERNAME "(" {Argument ","}* ")"                                  -> CharFilter              {cons("CharFilter")}
    "char filter" "=" CHARFILTERNAME                                                          -> CharFilter              {cons("CharFilterNoArgs")}
    "tokenizer" "=" TOKENIZERNAME "(" {Argument ","}* ")"                                     -> Tokenizer               {cons("Tokenizer")}
    "tokenizer" "=" TOKENIZERNAME                                                             -> Tokenizer               {cons("TokenizerNoArgs")}
    "token filter" "=" TOKENFILTERNAME "(" {Argument ","}* ")"                                -> TokenFilter             {cons("TokenFilter")}
    "token filter" "=" TOKENFILTERNAME                                                        -> TokenFilter             {cons("TokenFilterNoArgs")}
    Id "=" String                                                                             -> Argument                {cons("Argument")}
    Id                                                                                        -> CHARFILTERNAME          
    Id                                                                                        -> TOKENIZERNAME           
    Id                                                                                        -> TOKENFILTERNAME         

  context-free syntax
    "searchable"                            -> SearchableAnno      {cons("SearchableAnno"), prefer}
    "searchable" "(" {SA-Argument ","}* ")" -> SearchableAnno      {cons("SearchableAnno")}
    "search" "namespace"                    -> SearchNamespaceAnno {cons("SearchNamespaceAnno"), prefer}
    SearchableAnno "^" Float                -> Annotation          {cons("SearchableAnnoBoost")}
    SearchableAnno                          -> Annotation          
    SearchNamespaceAnno                     -> Annotation          
    SA-Key "=" SA-Value                     -> SA-Argument         {cons("SA-Argument")}
    "autocomplete"                          -> SA-Argument         {cons("Autocomplete-Argument")}
    "spellcheck"                            -> SA-Argument         {cons("Spellcheck-Argument")}
    "numeric"                               -> SA-Argument         {cons("Numeric-Argument")}
    "default"                               -> SA-Argument         {cons("DefaultSF-Argument")}

  context-free syntax
    SearchMapping                                       -> Definition            
    SearchMappingEmbedded                               -> EntityBodyDeclaration 
    "search" "mapping" "{" SearchMappingContent* "}"    -> SearchMappingEmbedded {cons("SearchMappingEmbedded")}
    "search" "mapping" Id "{" SearchMappingContent* "}" -> SearchMapping         {cons("SearchMapping")}
    "namespace" "by" Id                                 -> SearchMappingContent  {cons("SearchNamespaceMapping"), prefer}
    "namespace" "by" Id ";"                             -> SearchMappingContent  {cons("SearchNamespaceMapping")}
    DEFAULTSF? KW MappingPart* ";"                      -> SearchMappingContent  {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart* ";"              -> SearchMappingContent  {cons("SearchFieldMapping")}
    DEFAULTSF? KW MappingPart*                          -> SearchMappingContent  {cons("SearchFieldMapping")}
    DEFAULTSF? "index" Id MappingPart*                  -> SearchMappingContent  {cons("SearchFieldMapping")}
    "as" Id                                             -> MappingPart           {cons("FieldName")}
    "using" Id                                          -> MappingPart           {cons("AnalyzerName")}
    "boosted" "to" Float                                -> MappingPart           {cons("Boost")}
    "for" "subclass" Id                                 -> MappingPart           {cons("TargetEntity")}
    "^" Float                                           -> MappingPart           {cons("Boost")}
    "(" {SearchMappingAnnoKW ","}* ")"                  -> MappingPart           {cons("SearchMappingAnno")}
    "depth" Int                                         -> MappingPart           {cons("EmbeddedDepth")}
    "with" "depth" Int                                  -> MappingPart           {cons("EmbeddedDepth")}
    Id                                                  -> KW                    
    "as"                                                -> KW                    {reject}
    "using"                                             -> KW                    {reject}
    "boosted"                                           -> KW                    {reject}
    "by"                                                -> KW                    {reject}
    "with"                                              -> KW                    {reject}
    "index"                                             -> KW                    {reject}
    "depth"                                             -> KW                    {reject}
    "for"                                               -> KW                    {reject}

  lexical syntax
    "analyzer"                 -> SA-Key              
    "name"                     -> SA-Key              
    "boost"                    -> SA-Key              
    "subclass"                 -> SA-Key              
    "depth"                    -> SA-Key              
    "default"                  -> DEFAULT             
    "default_builtin_analyzer" -> DEFAULT             
    "+"                        -> DEFAULTSF           
    Id                         -> SA-Value            
    Float                      -> SA-Value            
    Int                        -> SA-Value            
    "spellcheck"               -> SearchMappingAnnoKW 
    "autocomplete"             -> SearchMappingAnnoKW 
    "index"                    -> INDEXORQUERY        
    "query"                    -> INDEXORQUERY        

  context-free syntax
    SearcherDef                                                                -> Exp                 
    "search" ENTITY SearcherPart*                                              -> SearcherDef         {cons("SearcherInit")}
    "~" Exp SearcherPart+                                                      -> SearcherDef         {cons("SearcherRefMod")}
    ConstraintFilter                                                           -> SearcherPart        
    QueryDef                                                                   -> SearcherPart        
    Offset                                                                     -> SearcherPart        
    MaxResults                                                                 -> SearcherPart        
    SortBy                                                                     -> SearcherPart        
    FacetDef                                                                   -> SearcherPart        
    SearchAttributes                                                           -> SearcherPart        
    NamespaceConstraint                                                        -> SearcherPart        
    "matching" MatchGroup*                                                     -> QueryDef            {cons("QueryDef"), prefer}
    "offset" Exp                                                               -> Offset              {cons("Start")}
    "limit" Exp                                                                -> MaxResults          {cons("MaxResults")}
    "order" "by" {SortExp ","}+                                                -> SortBy              {cons("SortBy")}
    "with" "filter" {FilterConstraint ","}+                                    -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "filters" {FilterConstraint ","}+                                   -> ConstraintFilter    {cons("ConstraintFilter")}
    "with" "facet" {FacetExp ","}+                                             -> FacetDef            {cons("FacetDef")}
    "with" "facets" {FacetExp ","}+                                            -> FacetDef            {cons("FacetDef")}
    "[" {SearchAttribute ","}* "]"                                             -> SearchAttributes    {cons("SearchAttributes")}
    "in" "namespace" Exp                                                       -> NamespaceConstraint {cons("NamespaceConstraint")}
    "no" "lucene"                                                              -> SearchAttribute     {cons("NoLucene")}
    "lucene"                                                                   -> SearchAttribute     {cons("Lucene")}
    "strict" "matching"                                                        -> SearchAttribute     {cons("DefaultAnd")}
    "loose" "matching"                                                         -> SearchAttribute     {cons("DefaultOr")}
    "(" FIELD "," Exp ")"                                                      -> FacetExp            {cons("DiscreteFacetDef")}
    "(" FIELD ":" {Range ","}* ")"                                             -> FacetExp            {cons("RangeFacetDef")}
    FIELD ":" Exp                                                              -> FilterConstraint    {cons("FieldFilterConstraint")}
    {FIELD ","}+ ":"                                                           -> FieldsConstraint    {cons("FieldsConstraint")}
    {QueryExp ","}+                                                            -> QueryConstraint     {cons("QueryConstraint"), avoid}
    BoolOp? "(" MatchGroup+ ")"                                                -> MatchGroup          {cons("Clause"), avoid}
    FieldsConstraint? QueryConstraint                                          -> MatchGroup          {cons("Query"), avoid}
    BoolOp? "(" QueryExp+ ")"                                                  -> QueryExp            {cons("GroupDef"), prefer}
    BoolOp? QueryTerm Slop?                                                    -> QueryExp            {cons("TermDef"), avoid}
    BoolOp? Range                                                              -> QueryExp            {cons("RangeDef")}
    "~" Exp                                                                    -> Slop                {cons("Slop")}
    RangeOpen Exp? "to" Exp? RangeClose                                        -> Range               {cons("Range")}
    RangeOpen Exp? "TO" Exp? RangeClose                                        -> Range               {cons("Range")}
    "{"                                                                        -> RangeOpen           {cons("ExcludingOpen")}
    "}"                                                                        -> RangeClose          {cons("ExcludingClose")}
    "["                                                                        -> RangeOpen           {cons("IncludingOpen")}
    "]"                                                                        -> RangeClose          {cons("IncludingClose")}
    "+"                                                                        -> BoolOp              {cons("Must")}
    "-"                                                                        -> BoolOp              {cons("MustNot")}
    Exp                                                                        -> QueryTerm           
    FIELD Direction?                                                           -> SortExp             {cons("SortDef")}
    "asc"                                                                      -> Direction           {cons("Ascending")}
    "ascending"                                                                -> Direction           {cons("Ascending")}
    "desc"                                                                     -> Direction           {cons("Descending")}
    "descending"                                                               -> Direction           {cons("Descending")}
    "highlight" Exp "for" Exp "on" FIELD "surround" "with" "(" Exp "," Exp ")" -> RetrievalExp        {cons("HighlightTags")}
    "highlight" Exp "for" Exp "on" FIELD                                       -> RetrievalExp        {cons("Highlight")}
    "results" "from" Exp                                                       -> RetrievalExp        {cons("SearchResults")}
    FIELD "facets" "from" Exp                                                  -> RetrievalExp        {cons("FacetResults")}
    "all" FIELD "facets" "from" Exp                                            -> RetrievalExp        {cons("AllFacetResults")}
    "count" "from" Exp                                                         -> RetrievalExp        {cons("SearchResultsSize")}
    "searchtime" "from" Exp                                                    -> RetrievalExp        {cons("SearchTimeString")}
    "~" Exp                                                                    -> FIELD               {cons("SearchFieldRef")}
    ENTITY SuggestType SuggestionPart+                                         -> Exp                 {cons("Suggest")}
    "completions"                                                              -> SuggestType         {cons("AutoComplete")}
    "corrections"                                                              -> SuggestType         {cons("SpellCheck")}
    RetrievalExp                                                               -> Exp                 
    "similarity" Exp                                                           -> SuggestionPart      {cons("Similarity")}
    "matching" FieldsConstraint Exp                                            -> SuggestionPart      {cons("SuggestTerm")}
    NamespaceConstraint                                                        -> SuggestionPart      
    MaxResults                                                                 -> SuggestionPart      
    SearcherKW                                                                 -> QueryTerm           {reject}
    SearcherKW "(" Exp ")"                                                     -> QueryTerm           {reject}
    "[" {Exp ","}* "]"                                                         -> QueryTerm           {reject}

  context-free restrictions
    BoolOp -/- [0-9]
    QueryTerm -/- [\(]

  context-free priorities
    Exp -> QueryTerm >
    "(" Exp ")" -> Exp

  context-free priorities
    {QueryExp ","}+ -> QueryConstraint >
    { Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
      Exp "." Id "(" {Exp ","}* ")" -> Exp
      Exp "." Id -> Exp } >
    { RetrievalExp -> Exp
      SearcherDef -> Exp }

  lexical syntax
    Id           -> FIELD       
    Id "." FIELD -> FIELD       
    Id           -> ENTITY      
    Id           -> SEARCHERREF 
    "limit"      -> SearcherKW  
    "offset"     -> SearcherKW  
    "with"       -> SearcherKW  
    "order"      -> SearcherKW  
    "in"         -> SearcherKW  
    "matching"   -> SearcherKW  

  context-free restrictions
    "as" "asc" "ascending" "analyzer" "autocomplete" "boost" "boosted" "by"
    -/- [a-zA-Z0-9]
    "desc" "descending" "default" "default_builtin_analyzer" "depth" "extend"
    "for" -/- [a-zA-Z0-9]
    "facet" "facets" "from" "get" "highlight" "index" "limit" -/- [a-zA-Z0-9]
    "matching" "name" "namespace" "nolucene" "on" "query" -/- [a-zA-Z0-9]
    "results" "search" "sort" "spellcheck" "start" "subclass" -/- [a-zA-Z0-9]
    "using" "with" "where" -/- [a-zA-Z0-9]

  context-free syntax
    "searchmapping" "{" SearchMappingContent* "}"             -> SearchMappingEmbedded {cons("SearchMappingEmbedded"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "searchmapping" Id "{" SearchMappingContent* "}"          -> SearchMapping         {cons("SearchMapping"), deprecated("keyword `searchmapping` is replaced with `search mapping`")}
    "charfilter" "=" CHARFILTERNAME "(" {Argument ","}* ")"   -> CharFilter            {cons("CharFilter"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "charfilter" "=" CHARFILTERNAME                           -> CharFilter            {cons("CharFilterNoArgs"), deprecated("keyword `charfilter` is replaced with `char filter`")}
    "tokenfilter" "=" TOKENFILTERNAME "(" {Argument ","}* ")" -> TokenFilter           {cons("TokenFilter"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}
    "tokenfilter" "=" TOKENFILTERNAME                         -> TokenFilter           {cons("TokenFilterNoArgs"), deprecated("keyword `tokenfilter` is replaced with `token filter`")}

module WebDSL-Service
exports
  context-free syntax
    "service" Id "(" {FormalArg ","}* ")" Block -> Definition {cons("ServiceFunction")}

module WebDSL-TimeInterval
imports WebDSL-Lexical WebDSL-Action

exports
  context-free syntax
    Exp "weeks"        -> TimeIntervalPart {cons("Weeks")}
    Exp "days"         -> TimeIntervalPart {cons("Days")}
    Exp "hours"        -> TimeIntervalPart {cons("Hours")}
    Exp "minutes"      -> TimeIntervalPart {cons("Minutes")}
    Exp "seconds"      -> TimeIntervalPart {cons("Seconds")}
    Exp "milliseconds" -> TimeIntervalPart {cons("Milliseconds")}
    TimeIntervalPart*  -> TimeInterval     {cons("TimeInterval")}

  context-free syntax
    "invoke" Exp "every" TimeInterval -> Definition {cons("InvokeEvery")}

module WebDSL-Test
exports
  context-free syntax
    "test" Id Block -> Definition {cons("Test")}
    "test" Block    -> Definition {ast("Test(\"\",<1>)")}

module WebDSL-Type
exports
  context-free syntax
    "type" Id "{" TypeProperty* "}" -> Definition   {cons("TypeDef")}
    Annotation                      -> TypeProperty {cons("TypeDefAnno")}
    NativeClassFunction             -> TypeProperty 
    "static"                        -> TypeProperty {reject}
    QId "as" NativeClassFunction    -> TypeProperty {cons("NativeClassFunctionFromStatic")}

module WebDSL-Exception
exports
  context-free syntax
    "throw" {Exp ","}+ ";"            -> Statement    {cons("ThrowStatement"), prefer}
    "throw" {Exp ","}+                -> TemplateCall {cons("ThrowTemplate"), prefer}
    "try" Block Catch+                -> Statement    {cons("TryStatement"), prefer}
    "try" Block Catch+                -> TemplateCall {cons("TryTemplate"), prefer}
    "catch" "(" Id ":" Sort ")" Block -> Catch        {cons("Catch")}

module WebDSL-Dispatch
exports
  sorts DispatchEntry DispatchBody DispatchArg

  context-free syntax
    "dispatch" "{" DispatchEntry* DispatchEntryDefault "}"                    -> TemplateElement        {cons("Dispatch")}
    "dispatch" "{" TemplateElement* "}"                                       -> TemplateCall           {reject}
    Id "(" {FormalArg ","}* ")" "{" TemplateElement* "}"                      -> DispatchEntry          {cons("DispatchEntry")}
    Id "{" TemplateElement* "}"                                               -> DispatchEntry          {cons("DispatchEntryNoArg")}
    Id ":" Sort "{" TemplateElement* "}"                                      -> DispatchEntry          {cons("DispatchEntity")}
    "default" "{" TemplateElement* "}"                                        -> DispatchEntryDefault   {cons("DispatchDefault")}
                                                                              -> DispatchEntryDefault   {cons("None")}
    "default" "(" {FormalArg ","}* ")" "{" TemplateElement* "}"               -> DispatchEntry          {reject}
    "default" "{" TemplateElement* "}"                                        -> DispatchEntry          {reject}
    "navigate" "(" {DispatchNavigateCall "/"}+ ")" "{" TemplateElement* "}"   -> DispatchNavigate       {cons("DispatchNavigate")}
    "navigate" "(" Exp "," {DispatchNavigateCall "/"}+ ")"                    -> DispatchNavigateButton {cons("DispatchNavigateButton")}
    DispatchNavigate                                                          -> TemplateElement        
    DispatchNavigateButton                                                    -> TemplateElement        
    "navigate" "(" Id "(" {Exp ","}* ")" ")" "{" TemplateElement* "}"         -> DispatchNavigate       {reject}
    "navigate" "(" Exp "," Id "(" {Exp ","}* ")" ")" "{" TemplateElement* "}" -> DispatchNavigateButton {reject}
    "navigate" "(" Exp "/" Exp ")" TemplateBody                               -> TemplateCall           {reject}
    "navigate" "(" Exp "," Exp "/" Exp ")" TemplateBody                       -> TemplateCall           {reject}
    Id "(" {Exp ","}* ")"                                                     -> DispatchNavigateCall   {cons("DispatchNavigateCall")}
    Id                                                                        -> DispatchNavigateCall   {cons("DispatchNavigateCallNoArg")}

module WebDSL-Native
imports WebDSL-Lexical

exports
  sorts Derive DeriveType DeriveProperty

  context-free syntax
    "native" "function" Id "(" {FormalArg ","}* ")" ":" Sort ";" -> NativeFunctionDeclaration {cons("NativeFunction")}

  context-free syntax
    "native" "class" QId NativeClassAlias NativeClassSuper "{" NativeClassElement* "}" -> NativeClassDeclaration {cons("NativeClass")}
    "as" Id                                                                            -> NativeClassAlias       {cons("NativeClassAlias"), prefer}
                                                                                       -> NativeClassAlias       {cons("None")}
    ":" Id                                                                             -> NativeClassSuper       {cons("NativeClassSuper"), prefer}
                                                                                       -> NativeClassSuper       {cons("None")}

  context-free syntax
    Id ":" NativeType -> NativeClassElement {cons("NativeClassProperty")}

  context-free syntax
    NativeClassFunction                                                              -> NativeClassElement        
    NativeClassFunctionStatic Id "(" {NativeType ","}* ")" NativeClassFunctionReturn -> NativeClassFunction       {cons("NativeClassFunction")}
    "constructor" "(" {NativeType ","}* ")" NativeClassFunctionReturn                -> NativeClassElement        {reject}
    ":" NativeType                                                                   -> NativeClassFunctionReturn {cons("NativeClassFunctionReturn"), prefer}
                                                                                     -> NativeClassFunctionReturn {cons("None")}
    "static"                                                                         -> NativeClassFunctionStatic {cons("NativeClassFunctionStatic"), prefer}
                                                                                     -> NativeClassFunctionStatic {cons("None")}
    QId "as" NativeClassFunction                                                     -> NativeClassElement        {cons("NativeClassFunctionFromStatic")}
    "constructor" "(" {NativeType ","}* ")"                                          -> NativeClassElement        {cons("NativeClassConstructor")}
    Id "<" {NativeType ","}* ">"                                                     -> NativeType                {cons("NativeGenericType")}
    Id                                                                               -> NativeType                {cons("NativeSimpleType")}

module WebDSL-ValidationAnnos
exports
  sorts Annotation PatternFlag

  context-free syntax
    "length" "(" Int "," Int ")"              -> Annotation  {cons("ValidationAnnoLength"), prefer}
    "minlength" "(" Int ")"                   -> Annotation  {cons("ValidationAnnoMinLength"), prefer}
    "maxlength" "(" Int ")"                   -> Annotation  {cons("ValidationAnnoMaxLength"), prefer}
    "notempty"                                -> Annotation  {cons("ValidationAnnoNotEmpty"), prefer}
    "email"                                   -> Annotation  {cons("ValidationAnnoEmail"), prefer}
    "creditcardnumber"                        -> Annotation  {cons("ValidationAnnoCreditCardNumber"), prefer}
    "EAN"                                     -> Annotation  {cons("ValidationAnnoEAN"), prefer}
    "pattern" "(" String ")"                  -> Annotation  {cons("ValidationAnnoPattern"), prefer}
    "pattern" "(" String "," PatternFlag* ")" -> Annotation  {cons("ValidationAnnoPatternWithFlags"), prefer}
    "canonicalequivalence"                    -> PatternFlag {cons("FlagCanonEq")}
    "caseinsensitive"                         -> PatternFlag {cons("FlagCaseInsensitive")}
    "comments"                                -> PatternFlag {cons("FlagComments")}
    "dotall"                                  -> PatternFlag {cons("FlagDotAll")}
    "literal"                                 -> PatternFlag {cons("FlagLiteral")}
    "multiline"                               -> PatternFlag {cons("FlagMultiline")}
    "unicodecase"                             -> PatternFlag {cons("FlagUnicodeCase")}
    "unixlines"                               -> PatternFlag {cons("FlagUnixLines")}
    "max" "(" Int ")"                         -> Annotation  {cons("ValidationAnnoMax"), prefer}
    "min" "(" Int ")"                         -> Annotation  {cons("ValidationAnnoMin"), prefer}
    "range" "(" Int "," Int ")"               -> Annotation  {cons("ValidationAnnoRange"), prefer}
    "minrange" "(" Int ")"                    -> Annotation  {cons("ValidationAnnoMinRange"), prefer}
    "maxrange" "(" Int ")"                    -> Annotation  {cons("ValidationAnnoMaxRange"), prefer}
    "digits" "(" Int "," Int ")"              -> Annotation  {cons("ValidationAnnoDigits"), prefer}
    "past"                                    -> Annotation  {cons("ValidationAnnoPast"), prefer}
    "future"                                  -> Annotation  {cons("ValidationAnnoFuture"), prefer}
    "size" "(" Int "," Int ")"                -> Annotation  {cons("ValidationAnnoSize"), prefer}
    "minsize" "(" Int ")"                     -> Annotation  {cons("ValidationAnnoMinSize"), prefer}
    "maxsize" "(" Int ")"                     -> Annotation  {cons("ValidationAnnoMaxSize"), prefer}
    "notnull"                                 -> Annotation  {cons("ValidationAnnoNotNull"), prefer}
    "asserttrue"                              -> Annotation  {cons("ValidationAnnoAssertTrue"), prefer}
    "assertfalse"                             -> Annotation  {cons("ValidationAnnoAssertFalse"), prefer}
    "valid"                                   -> Annotation  {cons("ValidationAnnoValid"), prefer}

module WebDSL-Procedures
imports WebDSL-AccessControl WebDSL-UI WebDSL-DataModel WebDSL-Action
        WebDSL-Lexical

exports
  sorts Section Definition

  context-free syntax
    "procedure" Id "(" FormalArg ")" "{" ProcedureElement* "}"          -> Procedure        {cons("Procedure")}
    "auto" "procedure" Id "(" FormalArg ")" "{" ProcedureElement* "}"   -> Procedure        {cons("AutoProcedure")}
    "extend" "procedure" Id "(" FormalArg ")" "{" ProcedureElement* "}" -> Definition       {cons("ExtendProcedure")}
    Procedure                                                           -> Definition       
    "who" "{" Exp "}"                                                   -> ProcedureElement {cons("ProcedureWho")}
    "when" "{" Exp "}"                                                  -> ProcedureElement {cons("ProcedureWhen")}
    "do" Block                                                          -> ProcedureElement {cons("ProcedureDo")}
    "done" Block                                                        -> ProcedureElement {cons("ProcedureDone")}
    "enabled" Block                                                     -> ProcedureElement {cons("ProcedureEnabled")}
    "disabled" Block                                                    -> ProcedureElement {cons("ProcedureDisabled")}
    "view" "{" TemplateElement* "}"                                     -> ProcedureElement {cons("ProcedureView")}
    "process" "{" ProcessExp "}"                                        -> ProcedureElement {cons("ProcedureProcess")}
    "processed" Block                                                   -> ProcedureElement {cons("ProcedureProcessed")}

  sorts ProcessExp

  context-free syntax
    Id "(" Exp ")"                                                -> CallProcessExp {cons("ProcCall")}
    CallProcessExp                                                -> ProcessExp     
    ProcessExp ";" ProcessExp                                     -> ProcessExp     {cons("ProcSeq"), left}
    "while" "(" Exp ")" "{" ProcessExp "}"                        -> ProcessExp     {cons("ProcWhile")}
    "repeat" "{" ProcessExp "}" "until" CallProcessExp            -> ProcessExp     {cons("ProcRepeatUntil")}
    "if" "(" Exp ")" "{" ProcessExp "}"                           -> ProcessExp     {cons("ProcIfNoElse")}
    "if" "(" Exp ")" "{" ProcessExp "}" "else" "{" ProcessExp "}" -> ProcessExp     {cons("ProcIf")}
    ProcessExp "xor" ProcessExp                                   -> ProcessExp     {cons("ProcXor"), left}
    ProcessExp "and" ProcessExp                                   -> ProcessExp     {cons("ProcAnd"), left}
    ProcessExp "+" ProcessExp                                     -> ProcessExp     {cons("ProcPlus"), left}
    "(" ProcessExp ")"                                            -> ProcessExp     {bracket}

  context-free priorities
    {left:
      ProcessExp "and" ProcessExp -> ProcessExp
    } >
    {left:
      ProcessExp "xor" ProcessExp -> ProcessExp
      ProcessExp "+" ProcessExp -> ProcessExp
    } >
    {left:
      ProcessExp ";" ProcessExp -> ProcessExp {cons("ProcSeq"), left}
    }

module WebDSL-Derive
imports WebDSL-UI WebDSL-Lexical

exports
  sorts Derive DeriveType DeriveProperty

  context-free syntax
    "derive" Id "from" Exp "for" "(" {DeriveProperty ","}* ")"            -> TemplateElement   {cons("Derive"), prefer}
    "derive" Id "from" Exp                                                -> TemplateElement   {cons("Derive"), prefer}
    "derive" Id "from" Exp "for" "(" {DeriveProperty ","}* ")" DeriveBody -> TemplateElement   {cons("Derive"), prefer}
    "derive" Id "from" Exp DeriveBody                                     -> TemplateElement   {cons("Derive"), prefer}
    "derive" Id DeriveBody                                                -> TemplateElement   {cons("Derive"), prefer}
    Id                                                                    -> DeriveProperty    {cons("DeriveDefault")}
    Id "(" Id ")"                                                         -> DeriveProperty    {cons("DeriveMode")}
    "{" DeriveBodyElement* "}"                                            -> DeriveBody        {cons("DeriveBody")}
    Id "{" TemplateElement* "}"                                           -> DeriveBodyElement {cons("DeriveBodyElement")}
    "derive"                                                              -> TemplateCall      {reject}
    "derive" "crud" Id                                                    -> Definition        {cons("DeriveCrud")}
    "derive" "CRUD" Id                                                    -> Definition        {cons("DeriveCrud")}

module WebDSL-PagedFor
imports WebDSL-UI

exports
  sorts TemplateElement

  context-free syntax
    "for" "(" Id ":" Sort Filter "per" Exp ")" "{" TemplateElement* "}"          -> TemplateElement {cons("PagedForAll")}
    "for" "(" Id ":" Sort "per" Exp ")" "{" TemplateElement* "}"                 -> TemplateElement {cons("PagedForAllNoFilter")}
    "for" "(" Id ":" Sort "in" Exp Filter "per" Exp ")" "{" TemplateElement* "}" -> TemplateElement {cons("PagedFor")}
    "for" "(" Id ":" Sort "in" Exp "per" Exp ")" "{" TemplateElement* "}"        -> TemplateElement {cons("PagedForNoFilter")}

module WebDSL-Styling
imports WebDSL-UI WebDSL-Lexical

exports
  sorts Name StNum String UnaryOperator

  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\_\-]*          -> Identifier 
    [a-zA-Z] [a-zA-Z\-\_]+               -> ValueName  
    [a-z] [a-z\-]+                       -> Value      
    [a-f0-9] [a-f0-9] [a-f0-9] [a-f0-9]* -> Hex        
    [a-z\%]+                             -> Unit       
    "'" ~[\"\n]* "'"                     -> String     

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]* -> MatchIdent 

  lexical restrictions
    ValueName -/- [a-zA-Z\-\_]
    Value -/- [a-z\-]
    Unit -/- [a-z\%]
    Hex -/- [a-f0-9]

exports
  sorts StNumber

  lexical syntax
    Float         -> StNum      
    SignedInteger -> StNum      
    StNum         -> StNumber   
    StNum "%"     -> Percentage {prefer}
    StNum "em"    -> Ems        {prefer}
    StNum "ex"    -> Exs        {prefer}
    StNum "px"    -> Length     {prefer}
    StNum "cm"    -> Length     {prefer}
    StNum "mm"    -> Length     {prefer}
    StNum "in"    -> Length     {prefer}
    StNum "pt"    -> Length     {prefer}
    StNum "pc"    -> Length     {prefer}
    StNum "deg"   -> Angle      {prefer}
    StNum "rad"   -> Angle      {prefer}
    StNum "grad"  -> Angle      {prefer}
    StNum "ms"    -> Time       {prefer}
    StNum "s"     -> Time       {prefer}
    StNum "hz"    -> Freq       {prefer}
    StNum "khz"   -> Freq       {prefer}

  context-free syntax
    "theme" Modifier Id "(" ")" "{" StyleDeclaration* "}" -> Definition {cons("ThemeDefinition"), prefer}

  context-free syntax
    "style" Id StyleDefinition*      -> Section         {cons("StyleSection"), prefer}
    Selector "{" StyleStatement* "}" -> StyleDefinition {cons("StyleDefinition")}

  context-free syntax
    SimpleSelector ( Combinator SimpleSelector SelectorAttribute? )* -> Selector            {cons("Selector")}
    Id MatchDefinition                                               -> SimpleSelector      {cons("SimpleSelector")}
    "#" Identifier                                                   -> SimpleSelector      {cons("IdSimpleSelector")}
    Id                                                               -> SimpleSelector      {cons("ElemSimpleSelector")}
    Id SelectorAttribute+                                            -> SimpleSelector      {cons("ElemSimpleAttrSelector"), prefer}
    Id "." Identifier SelectorAttribute+                             -> SimpleSelector      {cons("ElemClassAttrSelector"), prefer}
    "." Identifier                                                   -> SimpleSelector      {cons("ClassSimpleSelector")}
    MatchDefinition                                                  -> SimpleSelector      {cons("SimpleSelector")}
    "*"                                                              -> SimpleSelector      {cons("UniversalSimpleSelector")}
    ":" ValueName                                                    -> SelectorAttribute   {cons("SelectorAttribute")}
    ">"                                                              -> Combinator          {cons("ChildCombinator")}
    ">>"                                                             -> Combinator          {cons("DescendantCombinator"), prefer}
    MatchIdent "(" MatchDefinitionArgs ")"                           -> MatchDefinition     {cons("MatchDefinition")}
    {FormalArg ","}*                                                 -> MatchDefinitionArgs 
    "const" Id ":" StyleSort ";"                                     -> StyleVarDecl        {cons("StyleVarDecl")}
    "const" Id ":" StyleSort ":=" StyleExpression ";"                -> StyleVarDecl        {cons("StyleVarDeclInit")}
    StyleVarDecl                                                     -> StyleDefinition     
    StyleProperty ":=" StyleExpression ";"                           -> StyleStatement      {cons("StyleDeclaration")}
    ValueName                                                        -> StyleProperty       {cons("StyleProperty")}
    MatchDefinition "." StyleProperty                                -> StyleExpression     {cons("StylePropertyValue")}
    Id                                                               -> StyleExpression     {cons("StyleVar")}
    StyleValue                                                       -> StyleExpression     
    "(" Selector ")" "." StyleProperty                               -> StyleExpression     {cons("StyleValueExpression")}
    StyleExpression "+" StyleExpression                              -> StyleExpression     {cons("StyleAdd"), assoc}
    StyleExpression "-" StyleExpression                              -> StyleExpression     {cons("StyleSub"), assoc}
    StyleExpression "*" StyleExpression                              -> StyleExpression     {cons("StyleMul"), assoc}
    StyleExpression "/" StyleExpression                              -> StyleExpression     {cons("StyleDiv"), assoc}
    StNumber Unit                                                    -> StyleValue          {cons("StyleValue")}
    StNumber                                                         -> StyleValue          {cons("StyleValue")}
    StyleSort StyleValueExtension+                                   -> StyleValue          {cons("StyleValue")}
    Uri                                                              -> StyleValue          {cons("StyleValue")}
    Hash                                                             -> StyleValue          {cons("StyleValue")}
    Value                                                            -> StyleValue          {cons("StyleValue"), prefer}
    String                                                           -> StyleValue          {cons("StyleValue")}
    "." ValueName                                                    -> StyleValueExtension {cons("StyleValueExtension")}
    Id Unit                                                          -> StyleSort           {cons("StyleSort")}
    Id                                                               -> StyleSort           {cons("StyleSort")}
    "url" "(" String ")"                                             -> Uri                 {cons("Uri")}
    "#" Hex                                                          -> Hash                {cons("Hash")}
    "const"                                                          -> Id                  {reject}

  context-free priorities
    {left:
      StyleExpression "*" StyleExpression -> StyleExpression
      StyleExpression "/" StyleExpression -> StyleExpression
    } >
    {left:
      StyleExpression "+" StyleExpression -> StyleExpression
      StyleExpression "-" StyleExpression -> StyleExpression
    }

  context-free syntax
    "layout" LayoutDefinition*                  -> Section           {cons("LayoutSection"), prefer}
    Id MatchDefinition "{" LayoutStatement* "}" -> LayoutDefinition  {cons("LayoutDefinition")}
    MatchDefinition "{" LayoutStatement* "}"    -> LayoutDefinition  {cons("LayoutDefinition")}
    StyleDefinition                             -> LayoutDefinition  
    "float" "{" MatchDefinition* "}" ";"        -> LayoutStatement   {cons("FloatStatement")}
    LayoutExpression ";"                        -> LayoutStatement   {cons("LayoutStatement")}
    Id ":" "[" LayoutExpressions "]"            -> LayoutExpression  {cons("NamedLayoutExpression")}
    {LayoutExpression "|"}+                     -> LayoutExpressions 
    Id                                          -> LayoutExpression  {cons("LayoutExpression")}
    MatchDefinition                             -> LayoutExpression  {cons("LayoutExpression")}

module WebDSL-Enums
imports WebDSL-DataModel WebDSL-Lexical

exports
  sorts Defintion EnumValue

  context-free syntax
    "enum" Id "{" {EnumValue ","}* "}" -> Definition {cons("Enum")}
    Id "(" String ")"                  -> EnumValue  {cons("EnumValue")}

module WebDSL-Regex
exports
  sorts Pattern PatternDecl Exp

  context-free syntax
    RegexExp "." Id "(" {Exp ","}* ")" -> Exp      {cons("Call")}
    "/" Pattern "/"                    -> RegexExp {cons("RegexPattern")}
    Branche                            -> Pattern  {cons("SingleBranch")}
    Pattern "|" Pattern                -> Pattern  {cons("TupleBranch"), right, prefer}

  sorts Branche

  context-free syntax
    Piece+ -> Branche {cons("Pieces")}

  sorts Piece

  context-free syntax
    Atom            -> Piece {cons("SingleAtom")}
    Atom Quantifier -> Piece {cons("QuantifiedAtom")}

  sorts Quantifier

  context-free syntax
    "{" Integer "}"              -> Quantifier {cons("GreedyExactBound")}
    "{" Integer "," "}"          -> Quantifier {cons("GreedyLowerBound")}
    "{" Integer "," Integer "}"  -> Quantifier {cons("GreedyLowerUpperBound")}
    "?"                          -> Quantifier {cons("GreedyOnceOrNot")}
    "*"                          -> Quantifier {cons("GreedyZeroOrMore")}
    "+"                          -> Quantifier {cons("GreedyOneOrMore")}
    "{" Integer "}?"             -> Quantifier {cons("ReluctantExactBound")}
    "{" Integer "," "}?"         -> Quantifier {cons("ReluctantLowerBound")}
    "{" Integer "," Integer "}?" -> Quantifier {cons("ReluctantLowerUpperBound")}
    "??"                         -> Quantifier {cons("ReluctantOnceOrNot")}
    "*?"                         -> Quantifier {cons("ReluctantZeroOrMore")}
    "+?"                         -> Quantifier {cons("ReluctantOneOrMore")}
    "{" Integer "}+"             -> Quantifier {cons("PossessiveExactBound")}
    "{" Integer "," "}+"         -> Quantifier {cons("PossessiveLowerBound")}
    "{" Integer "," Integer "}+" -> Quantifier {cons("PossessiveLowerUpperBound")}
    "?+"                         -> Quantifier {cons("PossessiveOnceOrNot")}
    "*+"                         -> Quantifier {cons("PossessiveZeroOrMore")}
    "++"                         -> Quantifier {cons("PossessiveOneOrMore")}

  sorts Atom

  context-free syntax
    "(" Pattern ")"                -> Atom {cons("Capture")}
    "(?:" Pattern ")"              -> Atom {cons("NonCapture")}
    "(?=" Pattern ")"              -> Atom {cons("PositiveLookahead")}
    "(?!" Pattern ")"              -> Atom {cons("NegativeLookahead")}
    "(?<=" Pattern ")"             -> Atom {cons("PositiveLookbehind")}
    "(?<!" Pattern ")"             -> Atom {cons("NegativeLookbehind")}
    "(?P<" RegexId ">" Pattern ")" -> Atom {cons("PythonCapture")}
    "(" Pattern ")@{" RegexId "}"  -> Atom {cons("RegexCapture")}
    "()"                           -> Atom {cons("Empty")}
    "."                            -> Atom {cons("SingleCharacter")}
    "^"                            -> Atom {cons("LineStart")}
    "$"                            -> Atom {cons("LineEnd")}
    CharacterClass                 -> Atom {cons("CharacterClass")}
    AtomLiteral                    -> Atom {cons("AtomLiteral")}
    AtomCharacter                  -> Atom {cons("AtomCharacter")}
    "\\Q" AllChars "\\E"           -> Atom {cons("QuotedAtom")}

  sorts CharacterClass BracketItem

  context-free syntax
    "[" BracketItem+ "]"                                                    -> CharacterClass {cons("BracketList")}
    "[^" BracketItem+ "]"                                                   -> CharacterClass {cons("NegatedBracketList")}
    BracketLiteral | BracketCharacter "-" BracketLiteral | BracketCharacter -> BracketItem    {cons("Range")}
    CharacterClass                                                          -> BracketItem    {cons("Union")}
    BracketLiteral                                                          -> BracketItem    {cons("BracketLiteral")}
    BracketCharacter                                                        -> BracketItem    {cons("BracketCharacter")}

  sorts ClassKeyword

  context-free syntax
    "Lower"          -> ClassKeyword {cons("LowerClass")}
    "Upper"          -> ClassKeyword {cons("UpperClass")}
    "ASCII"          -> ClassKeyword {cons("ASCIIClass")}
    "Alpha"          -> ClassKeyword {cons("AlphaClass")}
    "Digit"          -> ClassKeyword {cons("DigitClass")}
    "Alnum"          -> ClassKeyword {cons("AlnumClass")}
    "Punct"          -> ClassKeyword {cons("PunctClass")}
    "Graph"          -> ClassKeyword {cons("GraphClass")}
    "Print"          -> ClassKeyword {cons("PrintClass")}
    "Blank"          -> ClassKeyword {cons("BlankClass")}
    "Cntrl"          -> ClassKeyword {cons("CntrlClass")}
    "XDigit"         -> ClassKeyword {cons("XDigitClass")}
    "Space"          -> ClassKeyword {cons("WhiteSpace")}
    "javaLowerCase"  -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaUpperCase"  -> ClassKeyword {cons("JavaIsLowerCase")}
    "javaWhitespace" -> ClassKeyword {cons("JavaIsWhitespace")}
    "javaMirrored"   -> ClassKeyword {cons("JavaIsMirrored")}
    "InGreek"        -> ClassKeyword {cons("GreekBlock")}
    "Lu"             -> ClassKeyword {cons("UppercaseLetter")}
    "Sc"             -> ClassKeyword {cons("CurrencySymbol")}

  sorts BracketLiteral AtomLiteral AllChars

  lexical syntax
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\$\*\+\?\.\}\|]                          -> BracketLiteral 
    "/"                                                                            -> BracketLiteral 
    [\&\]\-]                                                                       -> BracketLiteral {reject}
    [a-zA-Z0-9\!\#\%\'\,\:\;\<\=\>\@\_\`\~\&\]\-]                                  -> AtomLiteral    
    "/"                                                                            -> AtomLiteral    
    [\}\)\|\[]                                                                     -> AtomLiteral    {reject}
    [\\\|\$\*\+\?\.\{\}\(\)\&\]\-\[\^\!\#\%\'\,\:\;\<\=\>\@\_\`\~a-zA-Z0-9\t\n\r]* -> AllChars       
    "/"                                                                            -> AllChars       
    "\""                                                                           -> AllChars       {cons("DoubleQuote")}

  sorts BracketCharacter AtomCharacter

  context-free syntax
    "\"" -> BracketCharacter {cons("DoubleQuote")}
    "\"" -> AtomCharacter    {cons("DoubleQuote")}

  context-free syntax
    "\\0" OctalValue   -> BracketCharacter {cons("OctalChar")}
    "\\x" TwoHexValue  -> BracketCharacter {cons("HexHexChar")}
    "\\u" FourHexValue -> BracketCharacter {cons("DecHexChar")}
    "\\t"              -> BracketCharacter {cons("Tab")}
    "\\n"              -> BracketCharacter {cons("Newline")}
    "\\r"              -> BracketCharacter {cons("Return")}
    "\\f"              -> BracketCharacter {cons("Formfeed")}
    "\\a"              -> BracketCharacter {cons("Alarm")}
    "\\e"              -> BracketCharacter {cons("Escape")}
    "\\w"              -> BracketCharacter {cons("WordChar")}
    "\\W"              -> BracketCharacter {cons("NonWordChar")}
    "\\s"              -> BracketCharacter {cons("WhiteSpaceChar")}
    "\\S"              -> BracketCharacter {cons("NonWhiteSpaceChar")}
    "\\d"              -> BracketCharacter {cons("DigitChar")}
    "\\D"              -> BracketCharacter {cons("NonDigitChar")}
    "\\c" ControlValue -> BracketCharacter {cons("ControlCharacter")}
    "\\b"              -> BracketCharacter {cons("WordBoundry")}
    "\\B"              -> BracketCharacter {cons("NonWordBoundry")}
    "\\A"              -> BracketCharacter {cons("InputBeginBoundry")}
    "\\G"              -> BracketCharacter {cons("PrevMatchEndBoundry")}
    "\\Z"              -> BracketCharacter {cons("EndInputBoundry")}
    "\\z"              -> BracketCharacter {cons("EndInputFinalBoundry")}
    "\\" BackReference -> BracketCharacter {cons("BackReference")}
    "\\ "              -> BracketCharacter {cons("Space")}
    "\\\t"             -> BracketCharacter {cons("Tab")}
    "\\\n"             -> BracketCharacter {cons("Newline")}
    "\\0" OctalValue   -> AtomCharacter    {cons("OctalChar")}
    "\\x" TwoHexValue  -> AtomCharacter    {cons("HexHexChar")}
    "\\u" FourHexValue -> AtomCharacter    {cons("DecHexChar")}
    "\\t"              -> AtomCharacter    {cons("Tab")}
    "\\n"              -> AtomCharacter    {cons("Newline")}
    "\\r"              -> AtomCharacter    {cons("Return")}
    "\\f"              -> AtomCharacter    {cons("Formfeed")}
    "\\a"              -> AtomCharacter    {cons("Alarm")}
    "\\e"              -> AtomCharacter    {cons("Escape")}
    "\\w"              -> AtomCharacter    {cons("WordChar")}
    "\\W"              -> AtomCharacter    {cons("NonWordChar")}
    "\\s"              -> AtomCharacter    {cons("WhiteSpaceChar")}
    "\\S"              -> AtomCharacter    {cons("NonWhiteSpaceChar")}
    "\\d"              -> AtomCharacter    {cons("DigitChar")}
    "\\D"              -> AtomCharacter    {cons("NonDigitChar")}
    "\\c" ControlValue -> AtomCharacter    {cons("ControlCharacter")}
    "\\b"              -> AtomCharacter    {cons("WordBoundry")}
    "\\B"              -> AtomCharacter    {cons("NonWordBoundry")}
    "\\A"              -> AtomCharacter    {cons("InputBeginBoundry")}
    "\\G"              -> AtomCharacter    {cons("PrevMatchEndBoundry")}
    "\\Z"              -> AtomCharacter    {cons("EndInputBoundry")}
    "\\z"              -> AtomCharacter    {cons("EndInputFinalBoundry")}
    "\\" BackReference -> AtomCharacter    {cons("BackReference")}
    "\\ "              -> AtomCharacter    {cons("Space")}
    "\\\t"             -> AtomCharacter    {cons("Tab")}
    "\\\n"             -> AtomCharacter    {cons("Newline")}

  sorts QuotablePatternSymbol

  context-free syntax
    "\\" QuotablePatternSymbol -> AtomCharacter    {cons("Quoted")}
    "\\" QuotablePatternSymbol -> BracketCharacter {cons("Quoted")}

  lexical syntax
    [\|\$\*\+\?\.\{\}\(\)\&\]\[\-\^\\\!\#\%\'\,\:\;\<\=\>\@\_\`\~\/] -> QuotablePatternSymbol 

  context-free syntax
    "\"" -> QuotablePatternSymbol {cons("DoubleQuote")}
    "\"" -> QuotablePatternSymbol {cons("DoubleQuote")}

  sorts Integer OctalValue TwoHexValue FourHexValue BackReference ControlValue

  lexical syntax
    [0-9]+                                          -> Integer       
    [1-9] [0-9]*                                    -> BackReference 
    [0-7]                                           -> OctalValue    
    [0-7] [0-7]                                     -> OctalValue    
    [0-3] [0-7] [0-7]                               -> OctalValue    
    [0-9A-Fa-f] [0-9A-Fa-f]                         -> TwoHexValue   
    [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f] [0-9A-Fa-f] -> FourHexValue  
    [0-9]                                           -> ControlValue  
    [0-9] [0-9]                                     -> ControlValue  

exports
  sorts RegexId RegexID

  context-free syntax
    RegexID -> RegexId {cons("RegexId")}

  lexical syntax
    [A-Za-z\_\$] [A-Za-z0-9\_\$]* -> RegexID 
    "true"                        -> RegexID {reject}
    "false"                       -> RegexID {reject}
    "null"                        -> RegexID {reject}

  lexical restrictions
    RegexID -/- [a-zA-Z0-9\_\$]

module WebDSL-JavaScript
exports
  sorts TemplateElement

  context-free syntax
    "<" "script" Attribute* ">" JSPart* "</" "script" ">" -> TemplateElement {cons("JSElement"), prefer}
    JSString                                              -> JSPart          {cons("JSString")}
    "~" Exp                                               -> JSPart          {cons("JSExp"), prefer}
    "\\~"                                                 -> JSPart          {cons("JSTilde"), prefer}

  sorts JSChar JSString

  lexical syntax
    JSChar+     -> JSString    
    ~[\<\~]     -> JSChar      
    SmallerThan -> JSChar      
    [\<]        -> SmallerThan 

  lexical restrictions
    SmallerThan -/- [\/]
    JSString -/- [\ \t\n\r]
    JSString -/- ~[\<\~]

module WebDSL-XML
exports
  context-free syntax
    "<" QualName Attribute* "/>"                                   -> TemplateElement {cons("XMLEmptyElement")}
    "<" QualName Attribute* ">" TemplateElement* "</" QualName ">" -> TemplateElement {cons("XMLElement")}

  context-free syntax
    "if" "(" Exp ")" "{" Attribute* "}"                           -> Attribute {cons("XMLAttributesIf")}
    "if" "(" Exp ")" "{" Attribute* "}" "else" "{" Attribute* "}" -> Attribute {cons("XMLAttributesIfElse")}

  context-free syntax
    QualName "=" Exp            -> Attribute       {cons("Attribute")}
    CommonAttribute             -> Attribute       
    "all attributes"            -> CommonAttribute {cons("AllAttributes")}
    "all attributes except" Exp -> CommonAttribute {cons("AllAttributeExceptExp")}
    "attributes" Exp            -> CommonAttribute {cons("AttributesExp")}
    "attributes"                -> KEYWORD         

exports
  lexical syntax
    Qualifier? NCName             -> QualName  
    NCName ":"                    -> Qualifier 
    [A-Za-z\_] [A-Za-z0-9\.\-\_]* -> NCName    

  lexical restrictions
    NCName -/- [A-Za-z0-9\.\-\_]

module WebDSL-AccessControl
imports WebDSL-UI WebDSL-Action WebDSL-DataModel WebDSL-Lexical

exports
  sorts MatchId

  lexical syntax
    [a-zA-Z] [a-zA-Z0-9\_]* [\*]? -> MatchId     
    [\*]                          -> MatchId     
    [\*]                          -> WildCardArg 

  context-free syntax
    "access" "control" "rules" Id? AccessControlDefinition*                            -> Section                      {cons("AccessControlDefinition")}
    "access" "control" "rules" "{" Id? AccessControlDefinition* "}"                    -> Section                      {cons("AccessControlDefinition")}
    "principal" "is" Id "with" "credentials" {Id ","}+                                 -> Definition                   {cons("AccessControlPrincipal")}
    "principal" "is" Id "with" "credentials" {Id ","}+                                 -> AccessControlDefinition      {cons("AccessControlPrincipal")}
    AccessControlRule                                                                  -> AccessControlDefinition      
    "rule" Id MatchId "(" MatchArgs ")" "{" AccessControlCheck AccessControlRule* "}"  -> AccessControlRule            {cons("AccessControlRule")}
    "rules" Id MatchId "(" MatchArgs ")" "{" AccessControlCheck AccessControlRule* "}" -> AccessControlRule            {cons("AccessControlRule")}
    {FormalArg ","}* WildCardArg?                                                      -> MatchArgs                    {cons("MatchArgs"), prefer}
    {Exp ","}* WildCardArg?                                                            -> MatchArgs                    {cons("MatchArgs")}
    "rules"                                                                            -> Exp                          {reject}
    Exp                                                                                -> AccessControlCheck           
    "rule" Id "{" AccessControlCheck "}"                                               -> AccessControlRule            {cons("SpecialAccessControlRule")}
    "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"                                -> Definition                   {cons("Predicate")}
    "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"                                -> AccessControlDefinition      {cons("Predicate")}
    "predicate" Id "(" {FormalArg ","}* ")" "{" Exp "}"                                -> EntityBodyDeclaration        {cons("PredicateInEntity")}
    Id MatchId "(" {Id ","}* WildCardArg? ")"                                          -> AccessControlPointcutElement {cons("AccessControlPointcutElement")}
    "pointcut" Id "(" {FormalArg ","}* ")" "{" {AccessControlPointcutElement ","}* "}" -> AccessControlPointcut        {cons("AccessControlPointcut")}
    AccessControlPointcut                                                              -> AccessControlDefinition      
    "apply ac rules" Id "(" {AccessControlImportRulesArg ","}* ")"                     -> TemplateElement              {cons("AccessControlImportRules"), prefer}
    Id                                                                                 -> AccessControlImportRulesArg  {cons("Var")}

  context-free syntax
    "access" "control" "policy" PolicyExp -> Section   {cons("ACPolicy")}
    Id                                    -> PolicyExp {cons("Name")}
    "(" PolicyExp ")"                     -> PolicyExp {bracket}
    PolicyExp "AND" PolicyExp             -> PolicyExp {cons("PolicyAnd"), assoc}
    PolicyExp "OR" PolicyExp              -> PolicyExp {cons("PolicyOr"), assoc}

  context-free priorities
    {left:
      PolicyExp "AND" PolicyExp -> PolicyExp
    } >
    {left:
      PolicyExp "OR" PolicyExp -> PolicyExp
    }

  context-free priorities
    Exp "in" Exp -> Exp >
    Exp -> AccessControlCheck

  context-free syntax
    "ignore-access-control" -> Modifier {cons("IgnoreAccessControl")}

module WebDSL-DataValidation
exports
  context-free syntax
    "validatecreate" "(" Exp "," Exp ")"         -> Annotation            {cons("ValidateCreateAnno"), prefer}
    "validateupdate" "(" Exp "," Exp ")"         -> Annotation            {cons("ValidateUpdateAnno"), prefer}
    "validatedelete" "(" Exp "," Exp ")"         -> Annotation            {cons("ValidateDeleteAnno"), prefer}
    "validate" "(" Exp "," Exp ")"               -> Annotation            {cons("ValidateAnno"), prefer}
    Id ":" "validate" "(" Exp "," Exp ")"        -> Annotation            {cons("NamedValidateAnno"), prefer}
    ValidateEntity                               -> EntityBodyDeclaration 
    "validate" "(" Exp "," Exp ")"               -> ValidateEntity        {cons("ValidateEntity"), prefer}
    "validate" "(" Exp "," Exp ")" ";"           -> Statement             {cons("ValidateStatement"), prefer}
    Id ":" "validate" "(" Exp "," Exp ")" ";"    -> Statement             {cons("NamedValidateStatement"), prefer}
    "validationErrors" "(" Id ")"                -> TemplateCall          {cons("ValidationErrors"), prefer}
    "validationErrors" "(" ")"                   -> TemplateCall          {cons("ValidationErrors"), prefer}
    "validationContext" "{" TemplateElement* "}" -> TemplateCall          {cons("ValidationContext"), prefer}
    "validationContext" "{" TemplateElement* "}" -> TemplateCall          {reject}

module WebDSL-DataModel
imports WebDSL-Action WebDSL-Lexical

exports
  context-free syntax
    "globals" "{" GlobalsDef* "}"                        -> Definition            {prefer, cons("GlobalsDefinition"), deprecated("'globals{ }' block is no longer necessary around global variables and functions")}
    "entity" Id ":" Id "{" EntityBodyDeclaration* "}"    -> Entity                {cons("Entity")}
    "entity" Id "{" EntityBodyDeclaration* "}"           -> Entity                {cons("EntityNoSuper")}
    "session" Id "{" EntityBodyDeclaration* "}"          -> Entity                {cons("SessionEntity")}
    Property                                             -> EntityBodyDeclaration 
    Function                                             -> EntityBodyDeclaration 
    StaticEntityFunction                                 -> EntityBodyDeclaration 
    "cache"                                              -> EntityBodyDeclaration {cons("CachedEntity")}
    Entity                                               -> Definition            
    "extend" "entity" Id "{" EntityBodyDeclaration* "}"  -> Definition            {cons("ExtendEntity")}
    "extend" "session" Id "{" EntityBodyDeclaration* "}" -> Definition            {cons("ExtendSessionEntity")}

  context-free restrictions
    "cache" -/- [a-zA-Z0-9\_]

exports
  sorts Entity Property Sort Annotation

  context-free syntax
    "request" VarDecl -> Definition {cons("RequestScope")}
    VarDecl           -> GlobalsDef 
    VarDeclStat       -> GlobalsDef 
    Function          -> GlobalsDef 
    GlobalsDef        -> Definition 
    InitAction        -> Definition 

exports
  sorts Property Annotation

  context-free syntax
    Id PropKind Sort "(" {Annotation ","}* ")"          -> Property {cons("Property")}
    Id PropKind Sort                                    -> Property {cons("PropertyNoAnno")}
    Id PropKind Sort "(" {Annotation ","}* ")" ":=" Exp -> Property {cons("DerivedProperty")}
    Id PropKind Sort ":=" Exp                           -> Property {cons("DerivedPropertyNoAnno")}
    "::"                                                -> PropKind {cons("Simple")}
    "->"                                                -> PropKind {cons("Ref")}
    "<>"                                                -> PropKind {cons("Comp")}

  sorts Sort

  context-free syntax
    Id                           -> Annotation {cons("SimpleAnno")}
    "inverse" "=" Id "." Id      -> Annotation {cons("InverseAnno")}
    "inverse" "=" Id             -> Annotation {cons("IncompleteInverseAnno")}
    "inverseSlave" "=" Id "." Id -> Annotation {cons("InverseSlaveAnno")}
    "inline" "(" {Id ","}* ")"   -> Annotation {cons("InlineAnno")}
    "select" "=" Id              -> Annotation {cons("SelectAnno")}
    "not null"                   -> Annotation {cons("NotNullAnno")}
    "not empty"                  -> Annotation {cons("NotEmptyAnno")}
    "allowed" "=" Exp            -> Annotation {cons("AllowedAnno")}
    "default" "=" Exp            -> Annotation {cons("DefaultAnno")}
    "length" "=" Int             -> Annotation {cons("LengthAnno")}
    "format" "=" String          -> Annotation {cons("FormatAnno")}
    "index" "(" ")"              -> Annotation {cons("IndexAnno")}
    "index" "(" Int ")"          -> Annotation {cons("IndexAnno")}
    "collation" "(" Id ")"       -> Annotation {cons("CollationAnno")}
    "iderror" "=" String         -> Annotation {cons("IdErrorAnno")}
    "idemptyerror" "=" String    -> Annotation {cons("IdEmptyErrorAnno")}

module HQL
hiddens
  context-free start-symbols
    QueryRule Statement

exports
  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\_]* -> Identifier 

  lexical restrictions
    Identifier -/- [a-zA-Z0-9\_]
    "from" -/- [a-zA-Z0-9\_]
    "select" -/- [a-zA-Z0-9\_]

  context-free syntax
    "from" | "select" | "by" | "order" -> Identifier {reject}

exports
  sorts Statement UpdateStatement DeleteStatement SelectStatement
        InsertStatement

  context-free syntax
    "delete" FromClause WhereClause?                                 -> DeleteStatement                 {cons("DeleteStatement")}
    SelectStatement                                                  -> Statement                       
    QueryRule                                                        -> SelectStatement                 
    QueryRule "union" QueryRule                                      -> Union                           {cons("QueryUnion")}
    SelectFrom WhereClause? GroupByClause? OrderByClause?            -> QueryRule                       {cons("QueryRule")}
    SelectClause? FromClause                                         -> SelectFrom                      {cons("SelectFrom")}
    "select" Distinct? Selection                                     -> SelectClause                    {cons("Select")}
    "distinct"                                                       -> Distinct                        {cons("Distinct")}
    SelectedPropertiesList                                           -> Selection                       
    NewExpression                                                    -> Selection                       
    SelectObject                                                     -> Selection                       
    QueryRule                                                        -> Expression                      {avoid}
    "new" Path "(" SelectedPropertiesList ")"                        -> NewExpression                   {cons("NewExpression")}
    "object" "(" Identifier ")"                                      -> SelectObject                    {cons("SelectObject")}
    "from" {FromRangeJoin ","}+                                      -> FromClause                      {cons("FromClause")}
    FromRange FromJoin*                                              -> FromRangeJoin                   {cons("FromRangeJoin")}
    "left"                                                           -> JoinType                        {cons("LeftJoin")}
    "right"                                                          -> JoinType                        {cons("RightJoin")}
    "left" "outer"                                                   -> JoinType                        {cons("LeftOuterJoin")}
    "right" "outer"                                                  -> JoinType                        {cons("RightOuterJoin")}
    "full"                                                           -> JoinType                        {cons("FullJoin")}
    "inner"                                                          -> JoinType                        {cons("InnerJoin")}
    JoinType? "join" Fetch? Path AsAlias? PropertyFetch? WithClause? -> FromJoin                        {cons("FromJoin")}
    "fetch"                                                          -> Fetch                           {cons("Fetch")}
    "with" Expression                                                -> WithClause                      {cons("WithClause")}
    FromClassOrOuterQueryPath                                        -> FromRange                       
    InClassDeclaration                                               -> FromRange                       
    InCollectionDeclaration                                          -> FromRange                       
    InCollectionElementsDeclaration                                  -> FromRange                       
    Path AsAlias? PropertyFetch?                                     -> FromClassOrOuterQueryPath       {cons("FromClass")}
    Alias "in" "class" Path                                          -> InClassDeclaration              {cons("InClassDeclaration")}
    "in" "(" Path ")" Alias                                          -> InCollectionDeclaration         {cons("InCollection")}
    Alias "in" "elements" "(" Path ")"                               -> InCollectionElementsDeclaration {cons("InCollectionElements")}
    "as" Alias                                                       -> AsAlias                         {cons("AsAlias")}
    Identifier                                                       -> Alias                           {cons("Alias")}
    "fetch" "all" "properties"                                       -> PropertyFetch                   {cons("PropertyFetch")}
    "group" "by" {Expression ","}+ HavingClause?                     -> GroupByClause                   {cons("GroupBy")}
    "order" "by" {OrderElement ","}+                                 -> OrderByClause                   {cons("OrderByClause")}
    Expression AscendingOrDescending?                                -> OrderElement                    {cons("OrderElement")}
    "asc"                                                            -> AscendingOrDescending           {cons("Ascending")}
    "ascending"                                                      -> AscendingOrDescending           {cons("Ascending")}
    "desc"                                                           -> AscendingOrDescending           {cons("Descending")}
    "descending"                                                     -> AscendingOrDescending           {cons("Descending")}
    "having" Expression                                              -> HavingClause                    {cons("HavingClause")}
    "where" Expression                                               -> WhereClause                     {cons("WhereClause")}
    {AliasedExpression ","}+                                         -> SelectedPropertiesList          {cons("SelectedPropertiesList")}
    "'" Expression AsAlias? "'"                                      -> QuotedAliasedExpression         {cons("QuotedAliasedExpression")}
    Expression AsAlias?                                              -> AliasedExpression               {cons("AliasedExpression")}
    Expression "or" Expression                                       -> Expression                      {cons("QueryOr")}
    Expression "and" Expression                                      -> Expression                      {cons("QueryAnd")}
    "not" Expression                                                 -> Expression                      {cons("QueryNot")}
    Expression "=" Expression                                        -> Expression                      {cons("EQ")}
    Expression "is" Expression                                       -> Expression                      {cons("IS")}
    Expression "!=" Expression                                       -> Expression                      {cons("NE")}
    Expression "<>" Expression                                       -> Expression                      {cons("SQLNE")}
    Expression "like" Expression                                     -> Expression                      {cons("LIKE")}
    Expression "not" "like" Expression                               -> Expression                      {cons("NOTLIKE")}
    Expression "<" Expression                                        -> Expression                      {cons("LT")}
    Expression "<=" Expression                                       -> Expression                      {cons("LE")}
    Expression ">" Expression                                        -> Expression                      {cons("GT")}
    Expression ">=" Expression                                       -> Expression                      {cons("GE")}
    Expression "in" Expression                                       -> Expression                      {cons("In")}
    Expression "not" "in" Expression                                 -> Expression                      {cons("NotIn")}
    Expression "member" "of" Expression                              -> Expression                      {cons("MemberOf")}
    Expression "not" "member" "of" Expression                        -> Expression                      {cons("NotMemberOf")}
    Expression "||" Expression                                       -> Expression                      {cons("Concat")}
    Expression "+" Expression                                        -> Expression                      {cons("Plus")}
    Expression "-" Expression                                        -> Expression                      {cons("Minus")}
    Expression "*" Expression                                        -> Expression                      {cons("Multiply")}
    Expression "/" Expression                                        -> Expression                      {cons("Divide")}
    Expression "%" Expression                                        -> Expression                      {cons("Modulo")}
    "-" Expression                                                   -> Expression                      {cons("UMinus")}
    "current_date" "(" ")"                                           -> Expression                      {cons("HQLFunCurDate")}
    "current_time" "(" ")"                                           -> Expression                      {cons("HQLFunCurTime")}
    "current_timestamp" "(" ")"                                      -> Expression                      {cons("HQLFunCurTimestamp")}
    "second" "(" Expression ")"                                      -> Expression                      {cons("HQLFunSecond")}
    "minute" "(" Expression ")"                                      -> Expression                      {cons("HQLFunMinute")}
    "hour" "(" Expression ")"                                        -> Expression                      {cons("HQLFunHour")}
    "day" "(" Expression ")"                                         -> Expression                      {cons("HQLFunDay")}
    "month" "(" Expression ")"                                       -> Expression                      {cons("HQLFunMonth")}
    "year" "(" Expression ")"                                        -> Expression                      {cons("HQLFunYear")}

  lexical syntax
    ":" Identifier -> IdParameter  
    "?" NumInt     -> NumParameter 

  context-free syntax
    IdParameter                -> Expression {cons("IdParam")}
    NumParameter               -> Expression {cons("NumParam")}
    "avg" "(" Expression ")"   -> Expression {cons("Avg")}
    "sum" "(" Expression ")"   -> Expression {cons("Sum")}
    "min" "(" Expression ")"   -> Expression {cons("Min")}
    "max" "(" Expression ")"   -> Expression {cons("Max")}
    "count" "(" "*" ")"        -> Expression {cons("CountStar")}
    "count" "(" Expression ")" -> Expression {cons("Count")}
    "elements" "(" Path ")"    -> Expression {cons("Elements")}
    "indices" "(" Path ")"     -> Expression {cons("Indices")}
    Path                       -> Expression 
    "(" {Expression ","}+ ")"  -> Expression {cons("Paren")}
    "(" QueryRule ")"          -> Expression {cons("Paren"), prefer}
    Constant                   -> Expression 
    "true"                     -> Constant   {cons("True")}
    "false"                    -> Constant   {cons("False")}
    "empty"                    -> Constant   {cons("Empty")}
    "null"                     -> Constant   {cons("Null")}
    "true"                     -> Identifier {reject}
    "false"                    -> Identifier {reject}
    "empty"                    -> Identifier {reject}
    "null"                     -> Identifier {reject}
    {Identifier "."}+          -> Path       {cons("Path")}

  context-free syntax
    QuotedString -> Constant {cons("String")}

  lexical syntax
    "'" ( ~[\'] | "\\'" )* "'" -> QuotedString 

  lexical syntax
    [0-9]+ -> NumInt 

  context-free syntax
    NumInt -> Constant 

  context-free priorities
    { {Identifier "."}+ -> Path
      "(" {Expression ","}+ ")" -> Expression
      "avg" "(" Expression ")" -> Expression
      "sum" "(" Expression ")" -> Expression
      "min" "(" Expression ")" -> Expression
      "max" "(" Expression ")" -> Expression
      "count" "(" "*" ")" -> Expression
      "count" "(" Expression ")" -> Expression
      "elements" "(" Path ")" -> Expression
      "indices" "(" Path ")" -> Expression
      "-" Expression -> Expression } >
    {left:
      Expression "*" Expression -> Expression
      Expression "/" Expression -> Expression
      Expression "%" Expression -> Expression
      Expression "||" Expression -> Expression
    } >
    {left:
      Expression "+" Expression -> Expression
      Expression "-" Expression -> Expression
    } >
    {left:
      Expression "<" Expression -> Expression
      Expression "<=" Expression -> Expression
      Expression ">" Expression -> Expression
      Expression ">=" Expression -> Expression
      Expression "like" Expression -> Expression
      Expression "not" "like" Expression -> Expression
      Expression "in" Expression -> Expression
      Expression "not" "in" Expression -> Expression
      Expression "member" "of" Expression -> Expression
      Expression "not" "member" "of" Expression -> Expression
    } >
    {left:
      Expression "=" Expression -> Expression
      Expression "is" Expression -> Expression
      Expression "!=" Expression -> Expression
      Expression "<>" Expression -> Expression
    } >
    "not" Expression -> Expression >
    {left:
      Expression "and" Expression -> Expression
    } >
    {left:
      Expression "or" Expression -> Expression
    }

module MixHQL[Ctx0]
imports 
        HQL
          [ Constant                        => Constant[[Ctx0]]
            AliasedExpression               => AliasedExpression[[Ctx0]]
            QuotedAliasedExpression         => QuotedAliasedExpression[[Ctx0]]
            SelectedPropertiesList          => SelectedPropertiesList[[Ctx0]]
            WhereClause                     => WhereClause[[Ctx0]]
            HavingClause                    => HavingClause[[Ctx0]]
            AscendingOrDescending           => AscendingOrDescending[[Ctx0]]
            OrderElement                    => OrderElement[[Ctx0]]
            OrderByClause                   => OrderByClause[[Ctx0]]
            GroupByClause                   => GroupByClause[[Ctx0]]
            PropertyFetch                   => PropertyFetch[[Ctx0]]
            Alias                           => Alias[[Ctx0]]
            AsAlias                         => AsAlias[[Ctx0]]
            InCollectionElementsDeclaration => InCollectionElementsDeclaration[[Ctx0]]
            InCollectionDeclaration         => InCollectionDeclaration[[Ctx0]]
            InClassDeclaration              => InClassDeclaration[[Ctx0]]
            FromClassOrOuterQueryPath       => FromClassOrOuterQueryPath[[Ctx0]]
            FromRange                       => FromRange[[Ctx0]]
            WithClause                      => WithClause[[Ctx0]]
            Fetch                           => Fetch[[Ctx0]]
            FromJoin                        => FromJoin[[Ctx0]]
            JoinType                        => JoinType[[Ctx0]]
            FromRangeJoin                   => FromRangeJoin[[Ctx0]]
            FromClause                      => FromClause[[Ctx0]]
            SelectObject                    => SelectObject[[Ctx0]]
            NewExpression                   => NewExpression[[Ctx0]]
            Selection                       => Selection[[Ctx0]]
            Distinct                        => Distinct[[Ctx0]]
            SelectClause                    => SelectClause[[Ctx0]]
            SelectFrom                      => SelectFrom[[Ctx0]]
            QueryRule                       => QueryRule[[Ctx0]]
            Union                           => Union[[Ctx0]]
            SelectStatement                 => SelectStatement[[Ctx0]]
            Statement                       => Statement[[Ctx0]]
            DeleteStatement                 => DeleteStatement[[Ctx0]]
            NumInt                          => NumInt[[Ctx0]]
            QuotedString                    => QuotedString[[Ctx0]]
            NumParameter                    => NumParameter[[Ctx0]]
            IdParameter                     => IdParameter[[Ctx0]]
            Identifier                      => Identifier[[Ctx0]]
            Path                            => Path[[Ctx0]]
            Expression                      => Expression[[Ctx0]] ]

module WebDSL-Action
imports WebDSL-Lexical MixHQL[HQL]

exports
  context-free syntax
    "function" -> Keyword 
    "return"   -> Keyword 

  context-free syntax
    "function" Id "(" {FormalArg ","}* ")" FunctionReturn Block      -> Function             {cons("Function")}
                                                                     -> FunctionReturn       {ast("SimpleSort(\"Void\")")}
    ":" Sort                                                         -> FunctionReturn       {ast("<1>")}
    "extend" Function                                                -> Function             {cons("ExtendFunction")}
    "static" "function" Id "(" {FormalArg ","}* ")" ReturnType Block -> StaticEntityFunction {cons("StaticEntityFunction")}
    ":" Sort                                                         -> ReturnType           {cons("ReturnType")}
                                                                     -> ReturnType           {ast("ReturnType(SimpleSort(\"Void\"))")}

  context-free syntax
    FunctionExp                                       -> Exp               
    "function" FunctionExpParams FunctionReturn Block -> FunctionExp       {cons("FunctionExp")}
                                                      -> FunctionExpParams {ast("[]")}
    "(" {FormalArg ","}* ")"                          -> FunctionExpParams {ast("<1>")}
    FunctionRef                                       -> Exp               
    "function." Id "(" {Sort ","}* ")" FunctionReturn -> FunctionRef       {cons("FunctionRef")}
    FunctionRef "(" {Exp ","}* ")"                    -> Exp               {cons("FunctionRefCall")}
    FunctionRef "(" "*" "," {Exp ","}* ")"            -> Exp               {cons("FunctionRefCallPartial")}

  context-free syntax
    "{" Statements "}"           -> Block          {cons("Block")}
    Block                        -> Statement      
    Exp ";"                      -> Statement      {cons("Stat")}
    "return" Exp ";"             -> Statement      {cons("Return")}
    "return" ";"                 -> Statement      {cons("ReturnEmpty")}
    "goto" PageCall ";"          -> Statement      {cons("GoTo"), prefer}
    "goto" "(" PageCall ")" ";"  -> Statement      {cons("GoTo"), prefer}
    "goto"                       -> TemplateCallId {reject}
    "schedule" Exp "for" Exp ";" -> Statement      {cons("Schedule")}
    "schedule" Exp ";"           -> Statement      {cons("ScheduleNoFor")}

  context-free syntax
    "var" Id ":" Sort ";"          -> VarDeclStat {cons("VarDecl")}
    "var" Id ":" Sort              -> VarDecl     {cons("VarDecl")}
    "var" Id ":" Sort ":=" Exp ";" -> VarDeclStat {cons("VarDeclInit")}
    "var" Id ":=" Exp ";"          -> VarDeclStat {cons("VarDeclInitInferred")}
    "var" Id ":" Sort ":=" Exp     -> VarDecl     {cons("VarDeclInit")}
    "var" Id ":=" Exp              -> VarDecl     {cons("VarDeclInitInferred")}
    VarDeclStat                    -> Statement   

  context-free syntax
    "if" "(" Exp ")" Block "else" Block -> Statement {cons("If")}
    "if" "(" Exp ")" Block              -> Statement {cons("IfNoElse")}
    "case" "(" Exp ")" "{" Case* "}"    -> Statement {cons("Case")}
    ConstValue Block                    -> Case      {cons("CaseAlt")}
    "default" Block                     -> Case      {cons("CaseDefault")}

  context-free syntax
    "if" "(" Exp ")" Exp "else" Exp -> Exp {cons("IfExp")}

  context-free syntax
    "for" "(" Id ":" Sort "in" Exp Filter ")" Block      -> Statement {cons("ForStmt")}
    "for" "(" Id ":" Sort "in" Exp ")" Block             -> Statement {cons("ForStmtNoFilter")}
    "for" "(" Id ":" Sort Filter ")" Block               -> Statement {cons("ForAllStmt")}
    "for" "(" Id ":" Sort ")" Block                      -> Statement {cons("ForAllStmtNoFilter")}
    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" Block -> Statement {cons("ForCountStmt")}
    "while" "(" Exp ")" Block                            -> Statement {cons("WhileStmt")}

exports
  sorts ConstValue Exp

  context-free syntax
    Int                                          -> ConstValue               {cons("Int")}
    Long                                         -> ConstValue               {cons("Long")}
    Float                                        -> ConstValue               {cons("Float")}
    String                                       -> ConstValue               {cons("String")}
    ConstValue                                   -> Exp                      
    Id                                           -> Exp                      {cons("Var")}
    "in"                                         -> Exp                      {reject}
    "externalscope" "." Id                       -> Exp                      {cons("ExternalScopeVar")}
    "global" "." Id                              -> Exp                      {cons("GlobalVar")}
    "global"                                     -> Id                       {reject}
    Exp "." Id                                   -> Exp                      {cons("FieldAccess"), prefer}
    Exp "[" Exp "]"                              -> Exp                      {cons("CollectionIndex"), prefer}
    Sort "{" ObjectPropertyAssignment* "}"       -> ObjectCreation           {cons("ObjectCreation")}
    Sort "{" {ObjectPropertyAssignment ","}* "}" -> ObjectCreation           {cons("ObjectCreation"), prefer}
    ObjectCreation                               -> Exp                      
    Id ":=" Exp                                  -> ObjectPropertyAssignment {cons("ObjectPropertyAssignment")}
    Id                                           -> ObjectPropertyAssignment {cons("IncompleteObjectPropertyAssignment")}
    Exp ":=" Exp                                 -> Assignment               {cons("Assignment")}
    Assignment                                   -> Exp                      
    "[" Mapping* "]"                             -> Exp                      {cons("MapCreation"), avoid}
    Exp "->" Exp                                 -> Mapping                  {cons("Mapping")}
    "[" {Exp ","}* "]"                           -> Exp                      {cons("ListCreation")}
    "{" {Exp ","}* "}"                           -> Exp                      {cons("SetCreation")}
    "List" "<" Sort ">" "(" {Exp ","}* ")"       -> Exp                      {cons("TypedListCreation"), prefer}
    "Set" "<" Sort ">" "(" {Exp ","}* ")"        -> Exp                      {cons("TypedSetCreation"), prefer}
    Id "(" {Exp ","}* ")"                        -> Exp                      {cons("ThisCall")}
    "!" "(" {Exp ","}* ")"                       -> Exp                      {reject}
    Exp "." Id "(" {Exp ","}* ")"                -> Exp                      {cons("Call")}
    Exp "is" "a" Sort                            -> Exp                      {cons("IsA")}
    Exp "as" Sort                                -> Exp                      {cons("Cast"), avoid}
    "as"                                         -> Keyword                  

  context-free restrictions
    "as" -/- [a-zA-Z0-9\_]

  context-free syntax
    Exp "in" Exp -> Exp {non-assoc, cons("InColl")}

  context-free restrictions
    "in" -/- [a-zA-Z0-9\_]

  context-free syntax
    Exp "==" Exp                                          -> Exp    {cons("Eq")}
    Exp "!=" Exp                                          -> Exp    {cons("NotEq")}
    Exp ">" Exp                                           -> Exp    {cons("LargerThan")}
    Exp ">=" Exp                                          -> Exp    {cons("LargerThanOrEqual")}
    Exp "<" Exp                                           -> Exp    {cons("SmallerThan")}
    Exp "<=" Exp                                          -> Exp    {cons("SmallerThanOrEqual")}
    "true"                                                -> Exp    {prefer, cons("True")}
    "false"                                               -> Exp    {prefer, cons("False")}
    "null"                                                -> Exp    {prefer, cons("Null")}
    Exp "&&" Exp                                          -> Exp    {cons("And"), assoc}
    Exp "||" Exp                                          -> Exp    {cons("Or"), assoc}
    "!" Exp                                               -> Exp    {cons("Not")}
    "(" Exp ")"                                           -> Exp    {bracket}
    "[" Exp "for" "(" Id ":" Sort "in" Exp Filter ")" "]" -> ForExp {cons("ForExp")}
    "[" Exp "for" "(" Id ":" Sort "in" Exp ")" "]"        -> ForExp {cons("ForExpNoFilter")}
    "[" Exp "|" Id ":" Sort "in" Exp Filter "]"           -> ForExp {cons("ForExp")}
    "[" Exp "|" Id ":" Sort "in" Exp "]"                  -> ForExp {cons("ForExpNoFilter")}
    ForExp                                                -> Exp    
    "And" ForExp                                          -> Exp    {cons("AndForExp")}
    "Or" ForExp                                           -> Exp    {cons("OrForExp")}
    Exp "*" Exp                                           -> Exp    {cons("Mul"), assoc}
    Exp "/" Exp                                           -> Exp    {cons("Div"), assoc}
    Exp "%" Exp                                           -> Exp    {cons("Mod"), assoc}
    Exp "+" Exp                                           -> Exp    {cons("Add"), assoc}
    Exp "-" Exp                                           -> Exp    {cons("Sub"), assoc}

  context-free priorities
    {left:
      Exp "." Id "(" {Exp ","}* ")" -> Exp
      Exp "." Id -> Exp
      Exp "[" Exp "]" -> Exp
    } >
    {non-assoc:
      Exp "is" "a" Sort -> Exp
      Exp "as" Sort -> Exp
    } >
    "!" Exp -> Exp >
    {left:
      Exp "*" Exp -> Exp
      Exp "%" Exp -> Exp
      Exp "/" Exp -> Exp
    } >
    {left:
      Exp "+" Exp -> Exp
      Exp "-" Exp -> Exp
    } >
    Exp "in" Exp -> Exp >
    {left:
      Exp "==" Exp -> Exp
      Exp "!=" Exp -> Exp
      Exp ">" Exp -> Exp
      Exp ">=" Exp -> Exp
      Exp "<" Exp -> Exp
      Exp "<=" Exp -> Exp
    } >
    {left:
      Exp "&&" Exp -> Exp
    } >
    {left:
      Exp "||" Exp -> Exp
    } >
    Assignment -> Exp >
    HqlExp -> Exp >
    "if" "(" Exp ")" Exp "else" Exp -> Exp

exports
  context-free syntax
    QueryRule[[HQL]]                                         -> HqlExp            {cons("HqlQuery")}
    QueryRule[[HQL]] "limit" LimitValueExp                   -> HqlExp            {cons("HqlQueryLimit")}
    QueryRule[[HQL]] "limit" LimitValueExp "," LimitValueExp -> HqlExp            {cons("HqlQueryLimitOffset")}
    Exp                                                      -> LimitValueExp     
    DslExp                                                   -> LimitValueExp     
    DslExp                                                   -> Expression[[HQL]] 
    "~" Exp                                                  -> DslExp            {cons("DslExp")}
    DeleteStatement[[HQL]] ";"                               -> Statement         {cons("HqlStatement")}

  context-free syntax
    QueryRule[[HQL]] "." Id -> Exp {reject}

  context-free syntax
    Id "(" {Exp ","}* ")"           -> EmailCall {cons("EmailCall")}
    "renderemail" "(" EmailCall ")" -> Exp       {cons("RenderEmailFunctionCall"), prefer}
    "email" "(" EmailCall ")"       -> Exp       {cons("EmailFunctionCall"), prefer}
    "email" EmailCall               -> Exp       {cons("EmailFunctionCall"), prefer}
    "sendemail" "(" EmailCall ")"   -> Exp       {cons("SendEmailFunctionCall"), prefer}

  context-free syntax
    "rendertemplate" "(" TemplateCall ")"   -> Exp {cons("RenderTemplateFunctionCall"), prefer}
    "validatetemplate" "(" TemplateCall ")" -> Exp {cons("ValidateTemplateFunctionCall"), prefer}

module WebDSL-Ajax
exports
  sorts Statement Exp InlineTemplate AjaxStatement

  context-free syntax
    "event" "(" Id "," "[" {EventArg ","}* "]" ")" -> Exp             {cons("EventCall")}
    "event" "(" Id "," "[" {EventArg ","}* "]" ")" -> TemplateElement {cons("EventCallElement")}
    Id ":=" Exp                                    -> EventArg        {cons("EventArg")}
    AjaxStatement ";"                              -> Statement       {cons("AjaxStatement"), prefer}
    "replace" "(" Id "," TemplateCall ")"          -> AjaxStatement   {cons("AjaxReplace"), prefer}
    "replace" "(" Exp "," TemplateCall ")"         -> AjaxStatement   {cons("AjaxReplace")}
    "append" "(" Id "," TemplateCall ")"           -> AjaxStatement   {cons("AjaxAppend"), prefer}
    "append" "(" Exp "," TemplateCall ")"          -> AjaxStatement   {cons("AjaxAppend")}
    "visibility" "(" Id "," AjaxVisibility ")"     -> AjaxStatement   {cons("AjaxVisibility"), prefer}
    "visibility" "(" Exp "," AjaxVisibility ")"    -> AjaxStatement   {cons("AjaxVisibility")}
    "show"                                         -> AjaxVisibility  {cons("Show")}
    "toggle"                                       -> AjaxVisibility  {cons("Toggle")}
    "hide"                                         -> AjaxVisibility  {cons("Hide")}
    "relocate" "(" PageCall ")"                    -> AjaxStatement   {cons("AjaxRelocate")}
    "restyle" "(" Id "," Exp ")"                   -> AjaxStatement   {cons("AjaxRestyle"), prefer}
    "restyle" "(" Exp "," Exp ")"                  -> AjaxStatement   {cons("AjaxRestyle")}
    "clear" "(" Id ")"                             -> AjaxStatement   {cons("AjaxClear"), prefer}
    "clear" "(" Exp ")"                            -> AjaxStatement   {cons("AjaxClear")}
    "refresh" "(" ")"                              -> AjaxStatement   {cons("AjaxRefresh")}
    "runscript" "(" Exp ")"                        -> AjaxStatement   {cons("AjaxRunScript"), prefer}
    "placeholder" Id "{" TemplateElement* "}"      -> TemplateElement {cons("Placeholder"), prefer}
    "placeholder" Exp "{" TemplateElement* "}"     -> TemplateElement {cons("Placeholder")}
    "placeholder" Id TemplateCall                  -> TemplateElement {cons("PlaceholderWithAjaxCall"), prefer}
    "placeholder" PHExp TemplateCall               -> TemplateElement {cons("PlaceholderWithAjaxCall")}
    "placeholder"                                  -> TemplateCallId  {reject}
    Id "(" {Exp ","}* ")"                          -> PHExp           {cons("ThisCall")}
    Exp "." Id "(" {Exp ","}* ")"                  -> PHExp           {cons("Call")}
    Exp "." Id                                     -> PHExp           {cons("FieldAccess"), prefer}
    Exp "[" Exp "]"                                -> PHExp           {cons("CollectionIndex"), prefer}
    Exp "+" Exp                                    -> PHExp           {cons("Add")}
    ConstValue                                     -> PHExp           

module WebDSL-UI
imports WebDSL-Action WebDSL-Lexical

exports
  sorts TemplateDefinition Modifier Exp

  context-free syntax
    "define" -> Keyword 
    "for"    -> Keyword 

  context-free syntax
    TemplateDefinition                                                                           -> Definition              
    "define" Modifier* Id "(" {FormalArg ","}* ")" TemplateArgs "{" TemplateElement* "}"         -> TemplateDefinition      {cons("Define")}
    "requires" {TemplateArg ","}*                                                                -> TemplateArgs            {cons("TemplateArgs"), prefer}
    Id "(" {Sort ","}* ")"                                                                       -> TemplateArg             {cons("TemplateArg")}
                                                                                                 -> TemplateArgs            {cons("None")}
    "define" Modifier* Id "(" {FormalArg ","}* ")" "=" Id OptLocalRedefineArgs                   -> TemplateDefinition      {cons("LocalRedefine")}
                                                                                                 -> OptLocalRedefineArgs    {cons("None")}
    "(" "*" "," {LocalRedefineArg ","}+ ")"                                                      -> OptLocalRedefineArgs    {cons("LocalRedefineArgs")}
    Id                                                                                           -> LocalRedefineArg        {cons("Var")}
    Modifier* "page" Id "(" {FormalArg ","}* ")" TemplateArgs "{" TemplateElement* "}"           -> TemplateDefinition      {cons("DefinePage")}
    Modifier* "template" Id "(" {FormalArg ","}* ")" TemplateArgs "{" TemplateElement* "}"       -> TemplateDefinition      {cons("DefineTemplate")}
    "page"                                                                                       -> Modifier                {cons("Page")}
    "email"                                                                                      -> Modifier                {cons("Email")}
    "ajax"                                                                                       -> Modifier                {cons("AjaxTemplate")}
    "template"                                                                                   -> Modifier                {cons("Template")}
    "feed"                                                                                       -> Modifier                {cons("Feed")}
    "local"                                                                                      -> Modifier                {cons("Local")}
    "no-span"                                                                                    -> Modifier                {cons("NoSpan")}
    "span"                                                                                       -> Modifier                {cons("TemplateModSpan")}
    "inline"                                                                                     -> Modifier                {cons("TemplateModInline")}
    "secure"                                                                                     -> Modifier                {cons("TempateModSecure")}
    "not-secure"                                                                                 -> Modifier                {cons("TemplateModNotSecure")}
    "override"                                                                                   -> Modifier                {cons("TemplateModOverride")}
    "deprecated"                                                                                 -> Modifier                {cons("TemplateDeprecated")}
    InitAction                                                                                   -> TemplateElement         
    Action                                                                                       -> TemplateElement         
    VarDecl                                                                                      -> TemplateElement         
    VarDeclStat                                                                                  -> TemplateElement         
    "request" VarDecl                                                                            -> TemplateElement         {cons("RequestScopeTemplate")}
    "request"                                                                                    -> TemplateCallId          {reject}
    "local" VarDecl                                                                              -> TemplateElement         {cons("LocalScopeTemplate")}
    "local"                                                                                      -> TemplateCallId          {reject}
    TemplateDefinition                                                                           -> TemplateElement         
    TemplateCall                                                                                 -> TemplateElement         {avoid}
    String                                                                                       -> TemplateElement         {cons("Text")}
    "where" Exp                                                                                  -> Filter                  {cons("FilterNoOrderByNoLimit")}
    "order" "by" OrderExp                                                                        -> Filter                  {cons("FilterNoWhereNoLimit")}
    "where" Exp "order" "by" OrderExp                                                            -> Filter                  {cons("FilterNoLimit")}
    "where" Exp Limit                                                                            -> Filter                  {cons("FilterNoOrderBy")}
    "order" "by" OrderExp Limit                                                                  -> Filter                  {cons("FilterNoWhere")}
    Limit                                                                                        -> Filter                  {cons("FilterNoWhereNoOrderBy")}
    "where" Exp "order" "by" OrderExp Limit                                                      -> Filter                  {cons("Filter")}
    Exp                                                                                          -> OrderExp                {cons("OrderNonSpecific")}
    Exp "asc"                                                                                    -> OrderExp                {cons("OrderAscending")}
    Exp "desc"                                                                                   -> OrderExp                {cons("OrderDescending")}
    "limit" Exp "offset" Exp                                                                     -> Limit                   {cons("Limit")}
    "limit" Exp                                                                                  -> Limit                   {cons("LimitNoOffset")}
    "offset" Exp                                                                                 -> Limit                   {cons("LimitNoLimit")}
    "for" "(" Id ":" Sort "in" Exp Filter ")" "{" TemplateElement* "}" ForSeparator              -> TemplateElement         {cons("For")}
    "for" "(" Id ":" Sort "in" Exp ")" "{" TemplateElement* "}" ForSeparator                     -> TemplateElement         {cons("ForNoFilter"), prefer}
    "for" "(" Id ":" Sort Filter ")" "{" TemplateElement* "}" ForSeparator                       -> TemplateElement         {cons("ForAll")}
    "for" "(" Id ":" Sort ")" "{" TemplateElement* "}" ForSeparator                              -> TemplateElement         {cons("ForAllNoFilter")}
    "for" "(" Id ":" "Int" "from" Exp "to" Exp ")" "{" TemplateElement* "}" ForSeparator         -> TemplateElement         {cons("ForCount")}
    "separated-by" "{" TemplateElement* "}"                                                      -> ForSeparator            {cons("ForSeparator")}
                                                                                                 -> ForSeparator            {cons("None")}
    "select" "(" Exp "from" Exp ")"                                                              -> TemplateElement         {cons("SelectFromListNoPropsNoElems")}
    "select" "(" Exp "from" Exp ")" "[" {PropertyAssignment ","}* "]"                            -> TemplateElement         {cons("SelectFromListNoElems")}
    "select" "(" Exp "from" Exp ")" "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"   -> TemplateElement         {cons("SelectFromList")}
    "select" "(" Exp "from" Exp ")" "{" TemplateElement* "}"                                     -> TemplateElement         {cons("SelectFromListNoProps")}
    "if" "(" Exp ")" "{" TemplateElement* "}" "else" "{" TemplateElement* "}"                    -> TemplateElement         {cons("IfTempl"), prefer}
    "if" "(" Exp ")" "{" TemplateElement* "}"                                                    -> TemplateElement         {cons("IfNoElseTempl")}
    "if" "(" Exp ")" "{" TemplateElement* "}" ElseIfTempl+ ElseTempl?                            -> TemplateElement         {cons("IfElseIfTempl"), prefer}
    "else" "if" "(" Exp ")" "{" TemplateElement* "}"                                             -> ElseIfTempl             {cons("ElseIfTempl"), prefer}
    "else" "{" TemplateElement* "}"                                                              -> ElseTempl               {cons("ElseTempl"), prefer}
    "case" "(" {Exp ","}* ")" "{" TemplateCaseAlt* "}"                                           -> TemplateElement         {cons("TemplateCase")}
    {ConstValue ","}* "{" TemplateElement* "}"                                                   -> TemplateCaseAlt         {cons("TemplateCaseAlt")}
    "default" "{" TemplateElement* "}"                                                           -> TemplateCaseAlt         {cons("TemplateCaseAltDefault")}
    TemplateCallId "(" {Exp ","}* ")" "[" {PropertyAssignment ","}* "]" TemplateBody             -> TemplateCall            {cons("TemplateCall")}
    TemplateCallNoArgs                                                                           -> TemplateCall            
    TemplateCallNoBody                                                                           -> TemplateCall            
    TemplateCallNoAssigns                                                                        -> TemplateCall            
    TemplateCallPropsNoBody                                                                      -> TemplateCall            
    TemplateCallProps                                                                            -> TemplateCall            
    TemplateCallPropsNoArgs                                                                      -> TemplateCall            
    TemplateCallBody                                                                             -> TemplateCall            
    TemplateCallId                                                                               -> TemplateCallNoArgs      {cons("TemplateCallNoArgs")}
    TemplateCallId "(" {Exp ","}* ")"                                                            -> TemplateCallNoBody      {cons("TemplateCallNoBody")}
    TemplateCallId "(" {Exp ","}* ")" TemplateBody                                               -> TemplateCallNoAssigns   {cons("TemplateCallNoAssigns")}
    TemplateCallId "(" {Exp ","}* ")" "[" {PropertyAssignment ","}* "]"                          -> TemplateCallPropsNoBody {cons("TemplateCallPropsNoBody")}
    TemplateCallId "[" {PropertyAssignment ","}* "]"                                             -> TemplateCallProps       {cons("TemplateCallProps")}
    TemplateCallId "[" {PropertyAssignment ","}* "]" TemplateBody                                -> TemplateCallPropsNoArgs {cons("TemplateCallPropsNoArgs")}
    TemplateCallId TemplateBody                                                                  -> TemplateCallBody        {cons("TemplateCallBody")}
    "{" TemplateElement* "}"                                                                     -> TemplateBody            {cons("TemplateBody")}
    "with" "{" ArgDefine* "}"                                                                    -> TemplateBody            {cons("TemplateWith")}
    TemplateCallId "(" {FormalArg ","}* ")" "{" TemplateElement* "}"                             -> ArgDefine               {cons("ArgDefine")}
    "with" "{" TemplateElement* "}"                                                              -> TemplateCall            {reject}
    "define"                                                                                     -> TemplateCallId          {reject}
    "for"                                                                                        -> TemplateCallId          {reject}
    "placeholder"                                                                                -> TemplateCallId          {reject}
    "navigate" "(" PageCall ")" UNDEFINED* "{" TemplateElement* "}"                              -> TemplateElement         {cons("NavigateCall"), prefer}
    "navigate" "(" PageCall ")" "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"       -> TemplateElement         {cons("NavigateCall"), prefer}
    "navigate" PageCall UNDEFINED* "{" TemplateElement* "}"                                      -> TemplateElement         {cons("NavigateCall"), prefer}
    "navigate" PageCall "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"               -> TemplateElement         {cons("NavigateCall"), prefer}
    Id "(" {Exp ","}* ")"                                                                        -> PageCall                {cons("PageCall")}
    "navigate"                                                                                   -> TemplateCallId          {reject}
    "action" "(" Exp "," ActionCallOrInline ")" UNDEFINED*                                       -> TemplateElement         {cons("Submit"), prefer}
    "action" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]"                -> TemplateElement         {cons("Submit"), prefer}
    "actionLink" "(" Exp "," ActionCallOrInline ")" UNDEFINED*                                   -> TemplateElement         {cons("SubmitLink"), prefer}
    "actionLink" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]"            -> TemplateElement         {cons("SubmitLink"), prefer}
    "submit" "(" Exp "," ActionCallOrInline ")" UNDEFINED*                                       -> TemplateElement         {cons("Submit"), prefer}
    "submit" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]"                -> TemplateElement         {cons("Submit"), prefer}
    "submitlink" "(" Exp "," ActionCallOrInline ")" UNDEFINED*                                   -> TemplateElement         {cons("SubmitLink"), prefer}
    "submitlink" "(" Exp "," ActionCallOrInline ")" "[" {PropertyAssignment ","}* "]"            -> TemplateElement         {cons("SubmitLink"), prefer}
    "submit" ActionCallOrInline UNDEFINED* "{" TemplateElement* "}"                              -> TemplateElement         {cons("SubmitElem"), prefer}
    "submit" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"       -> TemplateElement         {cons("SubmitElem"), prefer}
    "submitlink" ActionCallOrInline UNDEFINED* "{" TemplateElement* "}"                          -> TemplateElement         {cons("SubmitLinkElem"), prefer}
    "submitlink" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"   -> TemplateElement         {cons("SubmitLinkElem"), prefer}
    "downloadlink" ActionCallOrInline UNDEFINED* "{" TemplateElement* "}"                        -> TemplateElement         {cons("DownloadLink"), prefer}
    "downloadlink" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}" -> TemplateElement         {cons("DownloadLink"), prefer}
    "outputimage" ActionCallOrInline UNDEFINED* "{" TemplateElement* "}"                         -> TemplateElement         {cons("OutputImage"), prefer}
    "outputimage" ActionCallOrInline "[" {PropertyAssignment ","}* "]" "{" TemplateElement* "}"  -> TemplateElement         {cons("OutputImage"), prefer}
    ActionCall                                                                                   -> ActionCallOrInline      
    InlineAction                                                                                 -> ActionCallOrInline      
    Id "(" {Exp ","}* ")"                                                                        -> ActionCall              {cons("ActionCall")}
    "action"                                                                                     -> TemplateCallId          {reject}
    "actionLink"                                                                                 -> TemplateCallId          {reject}
    "submit"                                                                                     -> TemplateCallId          {reject}
    "submitlink"                                                                                 -> TemplateCallId          {reject}
    "downloadlink"                                                                               -> TemplateCallId          {reject}
    "outputimage"                                                                                -> TemplateCallId          {reject}
    "action" Block                                                                               -> InlineAction            {cons("InlineAction")}
    "action"                                                                                     -> Sort                    {reject}
    "action"                                                                                     -> TemplateCall            {reject}
    "action"                                                                                     -> Exp                     {reject}
    "action"                                                                                     -> PropertyValue           {reject}
    SubmitProp ":" ActionCallOrInline                                                            -> PropertyAssignment      {cons("PropertySubmit"), prefer}
    SubmitProp ":=" ActionCallOrInline                                                           -> PropertyAssignment      {cons("PropertySubmit"), prefer}
    SubmitProp "=" ActionCallOrInline                                                            -> PropertyAssignment      {cons("PropertySubmit"), prefer}
    Id ":" PropertyValue                                                                         -> PropertyAssignment      {cons("PropertyAssignment")}
    Id ":=" PropertyValue                                                                        -> PropertyAssignment      {cons("PropertyAssignment")}
    Id "=" PropertyValue                                                                         -> PropertyAssignment      {cons("PropertyAssignment")}
    Exp                                                                                          -> PropertyValue           
    "ajax"                                                                                       -> PropertyAssignment      {cons("TemplateCallPropertyAjax"), prefer}
    "secure"                                                                                     -> PropertyAssignment      {cons("TemplateCallPropertySecure"), prefer}
    "ignore-validation"                                                                          -> PropertyAssignment      {cons("TemplateCallPropertyIgnoreValidation"), prefer}
    "not-secure"                                                                                 -> PropertyAssignment      {cons("TemplateCallPropertyNotSecure"), prefer}
    "not null"                                                                                   -> PropertyAssignment      {cons("TemplateCallPropertyNotNull"), prefer}
    CommonAttribute                                                                              -> PropertyAssignment      

  lexical syntax
    "onabort"     -> SubmitProp 
    "onblur"      -> SubmitProp 
    "onchange"    -> SubmitProp 
    "onclick"     -> SubmitProp 
    "ondblclick"  -> SubmitProp 
    "onerror"     -> SubmitProp 
    "onfocus"     -> SubmitProp 
    "onkeydown"   -> SubmitProp 
    "onkeypress"  -> SubmitProp 
    "onkeyup"     -> SubmitProp 
    "onload"      -> SubmitProp 
    "onmousedown" -> SubmitProp 
    "onmousemove" -> SubmitProp 
    "onmouseout"  -> SubmitProp 
    "onmouseover" -> SubmitProp 
    "onmouseup"   -> SubmitProp 
    "onreset"     -> SubmitProp 
    "onresize"    -> SubmitProp 
    "onselect"    -> SubmitProp 
    "onsubmit"    -> SubmitProp 
    "onunload"    -> SubmitProp 

  context-free syntax
    "if" "(" Exp ")" "{" TemplateElement* "}"                  -> TemplateCall    {reject}
    "else" "{" TemplateElement* "}"                            -> TemplateCall    {reject}
    "separated-by" "{" TemplateElement* "}"                    -> TemplateCall    {reject}
    "init" Block                                               -> InitAction      {cons("InitAction"), prefer}
    "init"                                                     -> TemplateCallId  {reject}
    "databind" Block                                           -> TemplateElement {cons("DataBindAction"), prefer}
    "databind"                                                 -> TemplateCallId  {reject}
    "render" Block                                             -> TemplateElement {cons("RenderAction"), prefer}
    "validate" Block                                           -> TemplateElement {cons("ValidateAction"), prefer}
    "action" ActionModifier* Id "(" {FormalArg ","}* ")" Block -> Action          {cons("Action")}
    "ignore-validation"                                        -> ActionModifier  {cons("ActionModifierIgnoreValidation")}

  context-free syntax
    Id ".elements" -> TemplateCallId {cons("QualifiedElementsCall"), prefer}

module WebDSL-Lexical
exports
  lexical syntax
    Id                      -> TemplateCallId 
    [a-zA-Z] [a-zA-Z0-9\_]* -> Id             
    [a-zA-Z0-9\-\_\.]+      -> FileName       
    {FileName "/"}+         -> ModuleName     
    ~[\n\r]*                -> SectionName    

  lexical restrictions
    Id -/- [a-zA-Z0-9\_]
    ModuleName -/- [a-zA-Z0-9\/]

  lexical syntax
    "-"? [0-9]+     -> Int  
    "-"? [0-9]+ "L" -> Long 

  lexical syntax
    "-"? FloatDigits ExponentPart? [fFdD]? -> Float         
    [0-9]* "." [0-9]*                      -> FloatDigits   
    [0-9]+                                 -> FloatDigits   
    [eE] SignedInteger                     -> ExponentPart  
    [\+\-]? [0-9]+                         -> SignedInteger 
    "-"? [0-9]+                            -> Float         {reject}
    "."                                    -> FloatDigits   {reject}

  lexical restrictions
    Int -/- [0-9]
    FloatDigits -/- [0-9]
    SignedInteger -/- [0-9]

  lexical syntax
    "\"" StringChar* "\"" -> String     
    ~[\"\n]               -> StringChar 
    "\\\""                -> StringChar 

  lexical syntax
    [\ \t\n\r]                 -> LAYOUT      
    "//" ~[\n\r]* [\n\r] | Eof -> LAYOUT      
    "/*" CommentChar* "*/"     -> LAYOUT      
                               -> Eof         
    ~[\*]                      -> CommentChar 
    Asterisk                   -> CommentChar 
    [\*]                       -> Asterisk    

  lexical restrictions
    Asterisk -/- [\/]
    Eof -/- ~[]

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\/]
    LAYOUT? -/- [\/] . [\*]
    SectionName -/- ~[\n\r]

  lexical syntax
    ~[\ \t\n\r\}]+ -> Word 

  lexical restrictions
    Word -/- ~[\ \t\n\r\}]

  context-free restrictions
    "page" "local" "email" "feed" "template" "schedule" -/- [a-zA-Z0-9]

module WebDSL
imports WebDSL-Lexical WebDSL-UI WebDSL-Ajax WebDSL-Action WebDSL-DataModel
        WebDSL-DataValidation WebDSL-AccessControl WebDSL-XML WebDSL-JavaScript
        WebDSL-Regex WebDSL-Enums WebDSL-Styling WebDSL-PagedFor WebDSL-Derive
        WebDSL-Procedures WebDSL-ValidationAnnos WebDSL-Native WebDSL-Dispatch
        WebDSL-Exception WebDSL-Type WebDSL-Test WebDSL-TimeInterval
        WebDSL-Service WebDSL-Search WebDSL-Recommend

hiddens
  context-free start-symbols
    Unit

exports
  sorts Id QId Int ModuleName SectionHeader Float FloatDigits ExponentPart
        SignedInteger String UNDEFINED Eof

  context-free syntax
    Id         -> QId 
    QId "." Id -> QId {cons("Qualified")}
    Keyword    -> Id  {reject}

  context-free syntax
    SimpleSort                                       -> Sort               
    GenericSort                                      -> Sort               
    RefSort                                          -> Sort               
    FunctionSort                                     -> Sort               
    Id                                               -> SimpleSort         {cons("SimpleSort")}
    Id "<" {Sort ","}+ ">"                           -> GenericSort        {cons("GenericSort")}
    "Ref" "<" Sort ">"                               -> RefSort            {cons("RefSort")}
    "Ref" "<" Sort ">"                               -> GenericSort        {reject}
    "function" FunctionSortParams FunctionSortReturn -> FunctionSort       {cons("FunctionSort")}
                                                     -> FunctionSortParams {ast("[]")}
    "(" {FunctionSortParam ","}* ")"                 -> FunctionSortParams {ast("<1>")}
    Sort                                             -> FunctionSortParam  {cons("UnnamedArg")}
    Id ":" Sort                                      -> FunctionSortParam  {cons("Arg")}
                                                     -> FunctionSortReturn {ast("SimpleSort(\"Void\")")}
    ":" Sort                                         -> FunctionSortReturn {ast("<1>")}
    "function"                                       -> SimpleSort         {reject}
    Id ":" Sort                                      -> FormalArg          {cons("Arg")}

exports
  sorts Application Module Unit

  syntax
    "section" <SectionName-CF> <LAYOUT?-CF> <Definition*-CF> -> <Section-CF> {cons("Section")}

  context-free syntax
    "application" QId Definition+ Section*   -> Application {cons("ApplicationDefs")}
    "application" QId Section*               -> Application {cons("Application")}
    "description" "{" Word* "}"              -> Description {cons("Description")}
    "note" "{" Word* "}"                     -> Description {cons("Note")}
    Description                              -> Definition  
    "module" ModuleName Section*             -> Module      {cons("Module")}
    "module" ModuleName Definition+ Section* -> Module      {cons("ModuleDefs")}
    "imports" ModuleName                     -> Definition  {cons("Imports")}
    Application                              -> Unit        
    Module                                   -> Unit        

exports
  sorts Action Statements Statement Exp

  context-free syntax
    Action                    -> Definition 
    Statement*                -> Statements 
    NativeFunctionDeclaration -> Definition 
    NativeClassDeclaration    -> Definition 

module WebDslMix[E]
imports WebDSL AccessControlMix StylingMix DeriveMix

exports
  lexical syntax
    [0-9]*               -> MetaVarSuffix 
    "_" [A-Za-z0-9\_\-]+ -> MetaVarSuffix 

  context-free syntax
    "webdsl" "|[" Application "]|"        -> E {cons("ToMetaExpr")}
    "|[" Application "]|"                 -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Section "]|"            -> E {cons("ToMetaExpr")}
    "|[" Section "]|"                     -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Section* "]|"           -> E {cons("ToMetaExpr")}
    "|[" Section* "]|"                    -> E {cons("ToMetaExpr")}
    "webdsl" "|[" TemplateElement "]|"    -> E {cons("ToMetaExpr")}
    "webdsl*" "|[" TemplateElement* "]|"  -> E {cons("ToMetaExpr")}
    "def" "|[" Definition "]|"            -> E {cons("ToMetaExpr")}
    "def*" "|[" Definition* "]|"          -> E {cons("ToMetaExpr")}
    "fun" "|[" Function "]|"              -> E {cons("ToMetaExpr")}
    "fun*" "|[" Function* "]|"            -> E {cons("ToMetaExpr")}
    "sdef" "|[" SecurityDefinition "]|"   -> E {cons("ToMetaExpr")}
    "sdef*" "|[" SecurityDefinition* "]|" -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Description "]|"        -> E {cons("ToMetaExpr")}
    "|[" Description "]|"                 -> E {cons("ToMetaExpr")}

  variables
    "app" [0-9]*                 -> Application       {prefer}
    "sec" [0-9]*                 -> Section           {prefer}
    "sec" [0-9]* "*"             -> Section*          {prefer}
    "def" [0-9]*                 -> Definition        {prefer}
    "def" [0-9]* "*"             -> Definition*       {prefer}
    "procelem" [0-9]*            -> ProcedureElement  {prefer}
    "procelem" [0-9]* "*"        -> ProcedureElement* {prefer}
    "procelem_" [A-Za-z0-9]+     -> ProcedureElement  {prefer}
    "procelem_" [A-Za-z0-9]+ "*" -> ProcedureElement* {prefer}
    "processexp" [0-9]*          -> ProcessExp        {prefer}
    "processexp" [0-9]* "*"      -> ProcessExp*       {prefer}
    "desc" [0-9]*                -> Description       {prefer}
    "mod" [0-9]*                 -> Modifier          {prefer}
    "mod" [0-9]* "*"             -> Modifier*         {prefer}

  context-free syntax
    "webdsl" "|[" Entity "]|"                 -> E {cons("ToMetaExpr")}
    "|[" Entity "]|"                          -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration "]|"  -> E {cons("ToMetaExpr")}
    "|[" EntityBodyDeclaration "]|"           -> E {cons("ToMetaExpr")}
    "webdsl" "|[" EntityBodyDeclaration* "]|" -> E {cons("ToMetaExpr")}
    "|[" EntityBodyDeclaration* "]|"          -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Sort "]|"                   -> E {cons("ToMetaExpr")}
    "|[" Sort "]|"                            -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Sort ","}* "]|"            -> E {cons("ToMetaExpr")}
    "|[" {Sort ","}* "]|"                     -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Annotation "]|"             -> E {cons("ToMetaExpr")}
    "|[" Annotation "]|"                      -> E {cons("ToMetaExpr")}
    "webdsl" "|[" {Annotation ","}* "]|"      -> E {cons("ToMetaExpr")}
    "|[" {Annotation ","}* "]|"               -> E {cons("ToMetaExpr")}

  variables
    "ent" [0-9]*            -> Entity                {prefer}
    "prop" [0-9]*           -> Property              {prefer}
    "prop" [0-9]* "*"       -> Property*             {prefer}
    "srt" MetaVarSuffix     -> Sort                  {prefer}
    "srt" MetaVarSuffix "*" -> {Sort ","}*           {prefer}
    "ann" [0-9]*            -> Annotation            {prefer}
    "ann" [0-9]* "*"        -> {Annotation ","}*     {prefer}
    "k" [0-9]*              -> PropKind              {prefer}
    "dprop" [0-9]*          -> DeriveProperty        {prefer}
    "dprop" [0-9]* "*"      -> {DeriveProperty ","}* {prefer}

  context-free syntax
    "tdef" "|[" TemplateDefinition "]|"      -> E {cons("ToMetaExpr")}
    "farg" "|[" FormalArg "]|"               -> E {cons("ToMetaExpr")}
    "farg*" "|[" {FormalArg ","}* "]|"       -> E {cons("ToMetaExpr")}
    "procelem" "|[" ProcedureElement "]|"    -> E {cons("ToMetaExpr")}
    "procelem*" "|[" ProcedureElement* "]|"  -> E {cons("ToMetaExpr")}
    "elem" "|[" TemplateElement "]|"         -> E {cons("ToMetaExpr")}
    "elem*" "|[" TemplateElement* "]|"       -> E {cons("ToMetaExpr")}
    "call" "|[" TemplateCall "]|"            -> E {cons("ToMetaExpr")}
    "call*" "|[" TemplateCall* "]|"          -> E {cons("ToMetaExpr")}
    "exp" "|[" Exp "]|"                      -> E {cons("ToMetaExpr")}
    "passign" "|[" PropertyAssignment "]|"   -> E {cons("ToMetaExpr")}
    "passign*" "|[" PropertyAssignment* "]|" -> E {cons("ToMetaExpr")}

  variables
    "tdef" [0-9]*                 -> TemplateDefinition        {prefer}
    "farg" [0-9]*                 -> FormalArg                 {prefer}
    "farg" MetaVarSuffix "*"      -> {FormalArg ","}*          {prefer}
    "elem" [0-9]+                 -> TemplateElement           {prefer}
    "elem" [0-9]* "*"             -> TemplateElement*          {prefer}
    "elem_" [A-Za-z0-9]+          -> TemplateElement           {prefer}
    "elem_" [A-Za-z0-9]+ "*"      -> TemplateElement*          {prefer}
    "call" [0-9]*                 -> TemplateCall              {prefer}
    "call" [0-9]* "*"             -> TemplateCall*             {prefer}
    "passign" MetaVarSuffix       -> PropertyAssignment        {prefer}
    "passign" MetaVarSuffix "*"   -> {PropertyAssignment ","}* {prefer}
    "req" MetaVarSuffix "*"       -> TemplateArgs              {prefer}
    "template-body" MetaVarSuffix -> TemplateBody              {prefer}
    "withblock" MetaVarSuffix     -> TemplateWith              {prefer}
    "withdef" MetaVarSuffix       -> ArgDefine                 {prefer}
    "withdef" MetaVarSuffix "*"   -> {ArgDefine ","}*          {prefer}
    "talt" [0-9]*                 -> TemplateCaseAlt           {prefer}
    "talt" [0-9]* "*"             -> TemplateCaseAlt*          {prefer}

  context-free syntax
    "webdsl" "|[" Action "]|"     -> E {cons("ToMetaExpr")}
    "|[" Action "]|"              -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement "]|"  -> E {cons("ToMetaExpr")}
    "|[" Statement "]|"           -> E {cons("ToMetaExpr")}
    "stat" "|[" Statement "]|"    -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Statement* "]|" -> E {cons("ToMetaExpr")}
    "|[" Statement* "]|"          -> E {cons("ToMetaExpr")}
    "webdsl" "|[" Case "]|"       -> E {cons("ToMetaExpr")}
    "|[" Case "]|"                -> E {cons("ToMetaExpr")}

  variables
    "_act" [0-9]*            -> Action     {prefer}
    "stat" [0-9]*            -> Statement  {prefer}
    "stat" [0-9]* "*"        -> Statement* {prefer}
    "stat_" [A-Za-z0-9]*     -> Statement  {prefer}
    "stat_" [A-Za-z0-9]* "*" -> Statement* {prefer}
    "block" [0-9]*           -> Block      {prefer}
    "alt" [0-9]*             -> Case       {prefer}
    "alt" [0-9]* "*"         -> Case*      {prefer}

  context-free syntax
    "webdsl:e" "|[" Exp "]|" -> E {cons("ToMetaExpr")}
    "|[" Exp "]|"            -> E {cons("ToMetaExpr")}
    "|[" Assignment "]|"     -> E {cons("ToMetaExpr")}
    "|[" Assignment* "]|"    -> E {cons("ToMetaExpr")}

  variables
    "e" [0-9\']*            -> Exp                    {prefer}
    "e_" [A-Za-z0-9\']+     -> Exp                    {prefer}
    "e" [0-9\']* "*"        -> {Exp ","}*             {prefer}
    "e_" [A-Za-z0-9\']+ "*" -> {Exp ","}*             {prefer}
    "fltr" [0-9]*           -> Filter                 {prefer}
    "asgn" [0-9]*           -> Assignment             {prefer}
    "asgn" [0-9]* "*"       -> Assignment*            {prefer}
    "fun" [0-9]*            -> Function               {prefer}
    "fun" [0-9]* "*"        -> Function*              {prefer}
    "ebd" [0-9]*            -> EntityBodyDeclaration  {prefer}
    "ebd" [0-9]* "*"        -> EntityBodyDeclaration* {prefer}

  variables
    "qid" [0-9]*           -> QId               {prefer}
    [xyz] [0-9]*           -> Id                {prefer}
    [xyz] "_" [A-Za-z0-9]+ -> Id                {prefer}
    [xyz] [0-9]*           -> TemplateCallId    {prefer}
    [xyz] "_" [A-Za-z0-9]+ -> TemplateCallId    {prefer}
    [xyz] MetaVarSuffix    -> Identifier[[HQL]] {prefer}
    [xyz] [0-9]*           -> MatchId           {prefer}
    [xyz] "_" [A-Za-z0-9]+ -> MatchId           {prefer}
    "str" [0-9]*           -> String            {prefer}
    "const" [0-9]*         -> ConstValue        {prefer}

  lexical syntax
    [\$] [A-Za-z0-9]* -> IdVar              
    [\$] [A-Za-z0-9]* -> Id[[StrategoHost]] 

  lexical restrictions
    IdVar -/- [A-Za-z0-9]

  variables
    IdVar -> Id {prefer}

module Stratego-Sugar-Overlays
imports Stratego-Core-Identifiers Stratego-Sugar-Terms

exports
  sorts Overlay

  context-free syntax
    Id "=" Term                   -> Overlay {cons("OverlayNoArgs")}
    Id "(" {Id ","}* ")" "=" Term -> Overlay {cons("Overlay")}

module Stratego-Sugar-DynamicRules
imports Stratego-Core-Identifiers Stratego-Sugar-Strategies Stratego-Sugar-Rules

exports
  sorts ScopeLabels

  context-free syntax
    "{|" ScopeLabels ":" Strategy "|}" -> Strategy    {cons("DynRuleScope")}
    {DynRuleScopeId ","}*              -> ScopeLabels 
    "~" Term                           -> ScopeLabels {cons("ScopeLabels")}

  sorts DynRuleDef DynRuleId DynRuleScopeId RuleDec

  context-free syntax
    "rules" "(" DynRuleDef* ")"            -> Strategy       {cons("GenDynRules")}
    Id "+" Term                            -> DynRuleDef     {cons("AddScopeLabel")}
    DynRuleId ":-" Term                    -> DynRuleDef     {cons("UndefineDynRule")}
    DynRuleId ":" Rule                     -> DynRuleDef     {cons("SetDynRule")}
    DynRuleId ":+" Rule                    -> DynRuleDef     {cons("AddDynRule")}
    DynRuleId ":" Term                     -> DynRuleDef     {cons("SetDynRuleMatch")}
    DynRuleId ":=" Term                    -> DynRuleDef     {cons("DynRuleAssign")}
    DynRuleId ":+=" Term                   -> DynRuleDef     {cons("DynRuleAssignAdd")}
    DynRuleId ":" Rule "depends" "on" Term -> DynRuleDef     {cons("SetDynRuleDepends")}
    RuleDec "." Term                       -> DynRuleId      {cons("LabeledDynRuleId")}
    RuleDec "+" Term                       -> DynRuleId      {cons("AddLabelDynRuleId")}
    RuleDec                                -> DynRuleId      {cons("DynRuleId")}
    Id "." Term                            -> DynRuleScopeId {cons("LabeledDynRuleScopeId")}
    Id                                     -> DynRuleScopeId {cons("DynRuleScopeId")}

  context-free syntax
    Id                                           -> RuleDec {cons("RDecNoArgs")}
    Id "(" {Typedid ","}* ")"                    -> RuleDec {cons("RDec")}
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" -> RuleDec {cons("RDecT")}

  sorts RuleNames

  context-free syntax
    {Id ","}*                    -> RuleNames 
    "~" Term                     -> RuleNames {cons("RuleNames")}
    "/" RuleNames "\\*" Strategy -> Strategy  {cons("DynRuleIntersectFix")}

  syntax
    "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>                                               -> <Strategy-CF> {cons("DynRuleUnionFix")}
    "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>                                              -> <Strategy-CF> {cons("DynRuleUnionFix")}
    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>  -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
    "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}

  context-free syntax
    Strategy "/" RuleNames "\\" Strategy               -> Strategy {cons("DynRuleIntersect"), right}
    Strategy "\\" RuleNames "/" Strategy               -> Strategy {cons("DynRuleUnion"), right}
    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy {cons("DynRuleIntersectUnion"), right}

  priorities
    <StrategyAngle-CF> <LAYOUT?-CF> <Term-CF> -> <Strategy-CF> {cons("BA")} >
    { "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF> ->
      <Strategy-CF> {cons("DynRuleUnionFix")}
      "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF> ->
      <Strategy-CF> {cons("DynRuleUnionFix")}
      
      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> "/*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")}
      
      "/" <LAYOUT?-CF> <RuleNames-CF> <LAYOUT?-CF> "\\" <LAYOUT?-CF> <RuleNames-CF> " /*" <LAYOUT?-CF> <Strategy-CF>
      -> <Strategy-CF> {cons("DynRuleIntersectUnionFix")} } >
    <Strategy-CF> <LAYOUT?-CF> "=>" <LAYOUT?-CF> <Term-CF> -> <Strategy-CF>
    {cons("AM")}

  context-free priorities
    StrategyAngle Term -> Strategy {cons("BA")} >
    "/" RuleNames "\\*" Strategy -> Strategy {cons("DynRuleIntersectFix")} >
    Strategy "=>" Term -> Strategy {cons("AM")} >
    Strategy "/" RuleNames "\\" Strategy -> Strategy
    {cons("DynRuleIntersect"), right} >
    Strategy "\\" RuleNames "/" Strategy -> Strategy
    {cons("DynRuleUnion"), right} >
    Strategy "/" RuleNames "\\" RuleNames "/" Strategy -> Strategy
    {cons("DynRuleIntersectUnion"), right} >
    Strategy ";" Strategy -> Strategy {cons("Seq"), right}

module Stratego-Sugar-Rules
imports Stratego-Sugar-Strategies

exports
  sorts RuleDef

  context-free syntax
    Id ":" Rule                                           -> RuleDef {cons("RDefNoArgs")}
    Anno+ RuleDef                                         -> Def     {cons("AnnoDef")}
    Id "(" {Typedid ","}* ")" ":" Rule                    -> RuleDef {cons("RDef")}
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" ":" Rule -> RuleDef {cons("RDefT")}

  sorts Rule RuleCond

  context-free syntax
    Term "->" Term                  -> Rule     {cons("RuleNoCond")}
    Term "->" Term "where" Strategy -> Rule     {cons("Rule")}
    Term "->" Term RuleCond+        -> Rule     {cons("Rule"), avoid}
    "where" Strategy                -> RuleCond {cons("WhereClause")}
    "with" Strategy                 -> RuleCond {cons("WithClause")}

module Stratego-Sugar-Strategies
imports Stratego-Core-Strategies Stratego-Sugar-Terms Stratego-Sugar-Constants
        Stratego-Sugar-Signatures

exports
  context-free syntax
    Id "=" Strategy                        -> StrategyDef {cons("SDefNoArgs")}
    Id "(" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("SDef")}

  context-free syntax
    ID -> Typedid {cons("DefaultVarDec")}

  sorts Rule

  sorts StrategyParen StrategyCurly StrategyAngle

  context-free syntax
    SVar "(" {Strategy ","}* ")"          -> Strategy      {cons("Call")}
    "{" Strategy "}"                      -> Strategy      {cons("ScopeDefault")}
    StrategyAngle Term                    -> Strategy      {cons("BA")}
    "<" Strategy ">"                      -> StrategyAngle {bracket}
    Strategy "<+" Strategy                -> Strategy      {cons("LChoice"), right}
    "rec" Id "(" Strategy ")"             -> Strategy      {cons("Rec")}
    "not" "(" Strategy ")"                -> Strategy      {cons("Not")}
    "where" "(" Strategy ")"              -> Strategy      {cons("Where")}
    "with" "(" Strategy ")"               -> Strategy      {cons("With"), prefer}
    "test" "(" Strategy ")"               -> Strategy      {cons("Test")}
    "prim" "(" String ")"                 -> Strategy      {cons("PrimNoArgs")}
    "prim" "(" String "," {Term ","}* ")" -> Strategy      {cons("Prim")}
    String                                -> Strategy      {cons("StrCong")}
    Int                                   -> Strategy      {cons("IntCong")}
    Real                                  -> Strategy      {cons("RealCong")}
    Char                                  -> Strategy      {cons("CharCong")}
    String "(" {Strategy ","}* ")"        -> Strategy      {cons("CongQ")}
    Strategy StrategyCurly                -> Strategy      {cons("AnnoCong")}
    "{" Strategy "}"                      -> StrategyCurly {cons("StrategyCurly")}
    "(" ")"                               -> Strategy      {cons("EmptyTupleCong")}
    "(" Strategy ")"                      -> Strategy      {bracket}
    "(" Strategy "," {Strategy ","}+ ")"  -> Strategy      {cons("TupleCong")}
    "[" {Strategy ","}* "]"               -> Strategy      {cons("ListCongNoTail")}
    "[" {Strategy ","}* "|" Strategy "]"  -> Strategy      {cons("ListCong")}
    Strategy "#" StrategyParen            -> Strategy      {cons("ExplodeCong")}

  sorts SwitchCase

  context-free syntax
    SVar                                                         -> Strategy   {cons("CallNoArgs")}
    "\\" Rule "\\"                                               -> Strategy   {cons("LRule")}
    "(" Rule ")"                                                 -> Strategy   {cons("SRule")}
    Strategy "+" Strategy                                        -> Strategy   {cons("Choice"), right}
    Strategy "+>" Strategy                                       -> Strategy   {cons("RChoice"), right}
    "proceed"                                                    -> Strategy   {cons("ProceedNoArgs"), prefer}
    "proceed" "(" {Strategy ","}+ ")"                            -> Strategy   {cons("Proceed"), prefer}
    "if" Strategy "then" Strategy "else" Strategy "end"          -> Strategy   {cons("CondChoice")}
    "if" Strategy "then" Strategy "end"                          -> Strategy   {cons("IfThen")}
    "switch" Strategy SwitchCase* "end"                          -> Strategy   {cons("SwitchChoiceNoOtherwise")}
    "switch" Strategy SwitchCase* "otherwise" ":" Strategy "end" -> Strategy   {cons("SwitchChoice")}
    "case" Strategy ":" Strategy                                 -> SwitchCase {cons("SwitchCase")}
    Strategy "=>" Term                                           -> Strategy   {cons("AM")}
    Term ":=" Term                                               -> Strategy   {cons("Assign")}

  context-free priorities
    { Strategy StrategyCurly -> Strategy
      Strategy "#" StrategyParen -> Strategy } >
    { "!" Term -> Strategy
      "?" Term -> Strategy } >
    StrategyAngle Term -> Strategy >
    Strategy "=>" Term -> Strategy >
    Strategy ";" Strategy -> Strategy >
    {right:
      Strategy "+" Strategy -> Strategy
      Strategy "<+" Strategy -> Strategy
      Strategy "+>" Strategy -> Strategy
      Strategy "<" StrategyMid "+" Strategy -> Strategy
    }

  context-free priorities
    Strategy -> StrategyMid >
    Strategy "+" Strategy -> Strategy

  context-free priorities
    { Strategy StrategyCurly -> Strategy
      Strategy "#" StrategyParen -> Strategy } . >
    Term ":=" Term -> Strategy

module Stratego-Sugar-Terms
imports Stratego-Core-Terms Stratego-Sugar-Strategies

exports
  sorts LID

  context-free syntax
    LId -> LID {cons("ListVar")}
    LID -> Var {cons("Var")}
    LID -> ID  

  context-free syntax
    "_" PreTerm                  -> PreTerm {cons("BuildDefaultPT")}
    "_" Term                     -> Term    {cons("BuildDefault"), prefer}
    Char                         -> PreTerm {cons("Char")}
    PreTerm "{" {Term ","}* "}"  -> Term    {cons("AnnoList")}
    PreTerm                      -> Term    {cons("NoAnnoList")}
    "<" Strategy ">" Term        -> PreTerm {cons("App")}
    "<" Strategy ">" Term        -> Term    {cons("App"), prefer}
    StrategyAngle                -> PreTerm {cons("RootApp")}
    StrategyAngle                -> Term    {cons("RootApp"), prefer}
    "(" {Term ","}* ")"          -> PreTerm {cons("Tuple")}
    "[" {Term ","}* "]"          -> PreTerm {cons("List")}
    "[" {Term ","}* "|" Term "]" -> PreTerm {cons("ListTail")}

  context-free priorities
    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
    PreTerm "{" {Term ","}* "}" -> Term {cons("AnnoList")} >
    Var "@" Term -> Term {cons("As")}

module Stratego-Sugar-Signatures
imports Stratego-Core-Signatures Stratego-Sugar-Constants

exports
  sorts Sort

  context-free syntax
    "[" {Sort ","}* "]"          -> Sort {cons("SortList")}
    "[" {Sort ","}* "|" Sort "]" -> Sort {cons("SortListTl")}
    "(" {Sort ","}* ")"          -> Sort {cons("SortTuple")}

  sorts Kind

  context-free syntax
    "*"  -> Kind {cons("Star")}
    "**" -> Kind {cons("StarStar")}

module Stratego-Core-Signatures
imports Stratego-Core-Identifiers Stratego-Core-Constants

exports
  sorts Sdecl

  context-free syntax
    "sorts" Sort*          -> Sdecl {cons("Sorts")}
    "constructors" Opdecl* -> Sdecl {cons("Constructors")}

  sorts Sort

  context-free syntax
    LCID                   -> Sort {cons("SortVar")}
    UCID                   -> Sort {cons("SortNoArgs")}
    Id "(" {Sort ","}* ")" -> Sort {cons("Sort")}

  sorts Opdecl

  context-free syntax
    Id ":" Type     -> Opdecl {cons("OpDecl")}
    String ":" Type -> Opdecl {cons("OpDeclQ")}
    ":" Type        -> Opdecl {cons("OpDeclInj")}

  context-free syntax
    "external" Id ":" Type     -> Opdecl {cons("ExtOpDecl")}
    "external" String ":" Type -> Opdecl {cons("ExtOpDeclQ")}
    "external" ":" Type        -> Opdecl {cons("ExtOpDeclInj")}

  sorts Type ArgType ConstType FunType RetType

  context-free syntax
    Sort                        -> ConstType {cons("ConstType")}
    {ArgType "*"}+ "->" RetType -> FunType   {cons("FunType")}
    "(" Type ")"                -> ArgType   {bracket}
    ConstType                   -> ArgType   
    Type                        -> RetType   
    FunType                     -> RetType   {reject}
    FunType                     -> Type      
    ConstType                   -> Type      

  context-free restrictions
    Sort -/- [\(]

module Stratego-Core-Terms
imports Stratego-Core-Identifiers Stratego-Core-Constants

exports
  sorts ID Var Wld

  context-free syntax
    Id -> Var {cons("Var")}
    Id -> ID  

  sorts Term PreTerm

  context-free syntax
    Var                        -> PreTerm 
    Var                        -> Term    {prefer}
    "_"                        -> Wld     {cons("Wld")}
    Wld                        -> PreTerm 
    Wld                        -> Term    {prefer}
    Int                        -> PreTerm {cons("Int")}
    Real                       -> PreTerm {cons("Real")}
    String                     -> PreTerm {cons("Str")}
    Id "(" {Term ","}* ")"     -> PreTerm {cons("Op")}
    String "(" {Term ","}* ")" -> PreTerm {cons("OpQ")}
    Term "#" "(" Term ")"      -> PreTerm {cons("Explode")}
    PreTerm "{^" PreTerm "}"   -> Term    {cons("Anno")}
    Var "@" Term               -> Term    {cons("As"), prefer}
    Var "@" PreTerm            -> PreTerm {cons("As")}

  context-free priorities
    Term "#" "(" Term ")" -> PreTerm {cons("Explode")} >
    Var "@" Term -> Term {cons("As")}

module Stratego-Core-Strategies
imports Stratego-Core-Terms Stratego-Core-Constants Stratego-Core-Signatures

exports
  sorts Def

  context-free syntax
    StrategyDef                                             -> Def      
    Id                                                      -> SVar     {cons("SVar")}
    "let" Def* "in" Strategy "end"                          -> Strategy {cons("Let")}
    SVar "(" {Strategy ","}* "|" {Term ","}* ")"            -> Strategy {cons("CallT")}
    "call" "(" Term "|" {Strategy ","}* "|" {Term ","}* ")" -> Strategy {cons("CallDynamic")}

  sorts StrategyDef

  context-free syntax
    Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy            -> StrategyDef {cons("SDefT")}
    Anno+ StrategyDef                                                    -> Def         {cons("AnnoDef")}
    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")" "=" Strategy -> StrategyDef {cons("ExtSDefInl")}
    "external" Id "(" {Typedid ","}* "|" {Typedid ","}* ")"              -> StrategyDef {cons("ExtSDef")}
    "external" EmptyId "(" {Typedid ","}* "|" {Typedid ","}* ")"         -> StrategyDef {cons("ExtSDef")}

  sorts EmptyId

  lexical syntax
     -> EmptyId 

  sorts Anno

  context-free syntax
    "extend"   -> Anno {cons("Extend")}
    "override" -> Anno {cons("Override")}
    "internal" -> Anno {cons("Internal")}

  lexical syntax
    "extend"      -> Keyword 
    "override"    -> Keyword 
    "internal"    -> Keyword 
    "sealed"      -> Keyword 
    "extensible"  -> Keyword 
    "overridable" -> Keyword 

  lexical restrictions
    "extend" "override" "internal" "sealed" "extensible" "overridable"
    -/- [a-zA-Z0-9\'\-\_]

  sorts Typedid

  context-free syntax
    ID ":" Type -> Typedid {cons("VarDec")}

  sorts Strategy SVar StrategyParen StrategyMid

  context-free syntax
    "(" Strategy ")"                                          -> StrategyParen {cons("ParenStrat")}
    "fail"                                                    -> Strategy      {cons("Fail")}
    "id"                                                      -> Strategy      {cons("Id")}
    "proceed" "(" {Strategy ","}* "|" {Term ","}* ")"         -> Strategy      {cons("ProceedT"), prefer}
    "proceed"                                                 -> Strategy      {cons("ProceedNoArgs"), prefer}
    "?" Term                                                  -> Strategy      {cons("Match")}
    "!" Term                                                  -> Strategy      {cons("Build")}
    "{" {ID ","}* ":" Strategy "}"                            -> Strategy      {cons("Scope")}
    Strategy ";" Strategy                                     -> Strategy      {cons("Seq"), right}
    Strategy "<" StrategyMid "+" Strategy                     -> Strategy      {cons("GuardedLChoice"), right}
    Strategy                                                  -> StrategyMid   
    "prim" "(" String "," {Strategy ","}* "|" {Term ","}* ")" -> Strategy      {cons("PrimT")}
    "some" "(" Strategy ")"                                   -> Strategy      {cons("Some")}
    "one" "(" Strategy ")"                                    -> Strategy      {cons("One")}
    "all" "(" Strategy ")"                                    -> Strategy      {cons("All")}

  context-free priorities
    { "!" Term -> Strategy {cons("Build")}
      "?" Term -> Strategy {cons("Match")} } >
    Strategy ";" Strategy -> Strategy {cons("Seq"), right} >
    {right:
      Strategy "<" StrategyMid "+" Strategy -> Strategy
      {cons("GuardedLChoice"), right}
    }

  context-free syntax
    "import-term" "(" ModName ")" -> Strategy {cons("ImportTerm")}

module Stratego-Core-Modules
imports Stratego-Core-Identifiers Stratego-Core-Strategies
        Stratego-Core-Signatures

exports
  sorts Module

  context-free syntax
    "module" ModName Decl* -> Module {cons("Module")}
    "specification" Decl*  -> Module {cons("Specification")}

  sorts Decl

  context-free syntax
    "imports" ImportModName* -> Decl {cons("Imports")}
    "strategies" Def*        -> Decl {cons("Strategies")}
    "signature" Sdecl*       -> Decl {cons("Signature")}

  sorts ImportModName

  context-free syntax
    ModName -> ImportModName {cons("Import")}

  syntax
    <ModName-CF> "/" "-" -> <ImportModName-CF> {cons("ImportWildcard")}

module Stratego-Sugar-Modules
imports Stratego-Core-Modules Stratego-Sugar-Strategies
        Stratego-Sugar-Signatures Stratego-Sugar-Overlays Stratego-Sugar-Rules

exports
  sorts Decl Def

  context-free syntax
    "rules" Def*        -> Decl {cons("Rules")}
    "overlays" Overlay* -> Decl {cons("Overlays")}
    RuleDef             -> Def  

module Stratego-Sugar-StringQuotations
exports
  sorts StringQuotation StringQuotedPart1 StringQuotedChars1 DollarOpen1
        DollarClose1 QuotedBracket1 Dollar1 StringQuotedPart2 StringQuotedChars2
        DollarOpen2 DollarClose2 QuotedBracket2 Dollar2 StringQuotedPart3
        StringQuotedChars3 DollarOpen3 DollarClose3 QuotedBracket3 Dollar3
        StringQuotedPart4 StringQuotedChars4 DollarOpen4 DollarClose4
        QuotedBracket4 Dollar4 Padding

  context-free syntax
    StringQuotation -> PreTerm 

  syntax
    StringQuotation                                     -> <PreTerm-CF>             
    "$" "[" Padding StringQuotedPart1* "]"              -> StringQuotation          {cons("StringQuotation1")}
    Padding "[" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "]" -> StringQuotedPart1        {cons("StringEscape1")}
    <StringQuotedChars1-LEX>                            -> StringQuotedPart1        {cons("QStr")}
    <Dollar1-LEX>                                       -> StringQuotedPart1        {cons("QDollar")}
    "$" <QuotedBracket1-LEX> "$"                        -> StringQuotedPart1        {cons("QBr")}
    ~[\[\]\$]+                                          -> <StringQuotedChars1-LEX> 
    [\[\]]                                              -> <QuotedBracket1-LEX>     
    "$"                                                 -> <Dollar1-LEX>            
    "$" "{" Padding StringQuotedPart2* "}"              -> StringQuotation          {cons("StringQuotation2")}
    Padding "{" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> "}" -> StringQuotedPart2        {cons("StringEscape2")}
    <StringQuotedChars2-LEX>                            -> StringQuotedPart2        {cons("QStr")}
    <Dollar2-LEX>                                       -> StringQuotedPart2        {cons("QDollar")}
    "$" <QuotedBracket2-LEX> "$"                        -> StringQuotedPart2        {cons("QBr")}
    ~[\{\}\$]+                                          -> <StringQuotedChars2-LEX> 
    [\{\}]                                              -> <QuotedBracket2-LEX>     
    "$"                                                 -> <Dollar2-LEX>            
    "$" "(" Padding StringQuotedPart3* ")"              -> StringQuotation          {cons("StringQuotation3")}
    Padding "(" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ")" -> StringQuotedPart3        {cons("StringEscape3")}
    <StringQuotedChars3-LEX>                            -> StringQuotedPart3        {cons("QStr")}
    <Dollar3-LEX>                                       -> StringQuotedPart3        {cons("QDollar")}
    "$" <QuotedBracket3-LEX> "$"                        -> StringQuotedPart3        {cons("QBr")}
    ~[\(\)\$]+                                          -> <StringQuotedChars3-LEX> 
    [\(\)]                                              -> <QuotedBracket3-LEX>     
    "$"                                                 -> <Dollar3-LEX>            
    "$" "<" Padding StringQuotedPart4* ">"              -> StringQuotation          {cons("StringQuotation4")}
    Padding "<" <LAYOUT?-CF> <Term-CF> <LAYOUT?-CF> ">" -> StringQuotedPart4        {cons("StringEscape4")}
    <StringQuotedChars4-LEX>                            -> StringQuotedPart4        {cons("QStr")}
    <Dollar4-LEX>                                       -> StringQuotedPart4        {cons("QDollar")}
    "$" <QuotedBracket4-LEX> "$"                        -> StringQuotedPart4        {cons("QBr")}
    ~[\<\>\$]+                                          -> <StringQuotedChars4-LEX> 
    [\<\>]                                              -> <QuotedBracket4-LEX>     
    "$"                                                 -> <Dollar4-LEX>            
    <Padding-LEX>                                       -> Padding                  
                                                        -> <Padding-LEX>            {indentpadding}

  lexical restrictions
    StringQuotedChars1 -/- ~[\[\]\$]
    StringQuotedChars2 -/- ~[\{\}\$]
    StringQuotedChars3 -/- ~[\(\)\$]
    StringQuotedChars4 -/- ~[\<\>\$]
    Dollar1 -/- [\[\]] . [\$]
    Dollar2 -/- [\{\}] . [\$]
    Dollar3 -/- [\(\)] . [\$]
    Dollar4 -/- [\<\>] . [\$]

module Stratego-Core-Constants
exports
  sorts Int Real String StrChar

  lexical syntax
    [\-]? [0-9]+             -> Int     
    [\-]? [0-9]+ [\.] [0-9]+ -> Real    
    "\"" StrChar* "\""       -> String  
    ~[\"\\]                  -> StrChar 
    [\\] [\"tnr\\]           -> StrChar 

module Stratego-Sugar-Constants
imports Stratego-Core-Identifiers Stratego-Core-Constants
        Stratego-Sugar-StringQuotations

exports
  sorts Char CharChar

  lexical syntax
    "'" CharChar "'" -> Char     
    ~[\']            -> CharChar 
    [\\] [\'ntr\ ]   -> CharChar 
    Char             -> Id       {reject}

module Stratego-Core-Identifiers
exports
  sorts ModName ModNamePart

  lexical syntax
    {ModNamePart "/"}+                -> ModName     
    [a-zA-Z\.\_] [a-zA-Z0-9\'\.\-\_]* -> ModNamePart 

  lexical restrictions
    ModName -/- [a-zA-Z0-9\'\.\-\_]

  lexical syntax
    "imports"    -> ModName {reject}
    "overlays"   -> ModName {reject}
    "rules"      -> ModName {reject}
    "signature"  -> ModName {reject}
    "strategies" -> ModName {reject}

  sorts Id LId LCID UCID Wld

  lexical syntax
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]*     -> Id   
    [a-zA-Z\_] [a-zA-Z0-9\'\-\_]* "*" -> LId  
    [\'] [a-z]+                       -> Id   
    [a-z] [a-zA-Z0-9\'\-\_]*          -> LCID 
    [A-Z] [a-zA-Z0-9\'\-\_]*          -> UCID 

  lexical restrictions
    Id -/- [a-zA-Z0-9\'\-\_\*]
    LId -/- [a-zA-Z0-9\'\-\_]
    LCID -/- [a-zA-Z0-9\'\-\_]
    UCID -/- [a-zA-Z0-9\'\-\_]

  lexical syntax
    "_"     -> Id   {reject}
    "'"     -> Id   {reject}
    Keyword -> Id   {reject}
    Keyword -> LId  {reject}
    Keyword -> LCID {reject}
    Keyword -> UCID {reject}

  lexical restrictions
    "all" "case" "constructors" "else" "end" "external" "fail" "id" "if" "in"
    "imports" "let" "module" "not" "one" "overlays" "otherwise" "prim" "rec"
    "rules" "script" "signature" "some" "sorts" "strategies" "stratego" "switch"
    "test" "then" "where" "import-term" -/- [a-zA-Z0-9\'\-\_]

  context-free restrictions
    Wld -/- [a-zA-Z0-9\'\-\_]

  sorts Keyword

  lexical syntax
    "all"          -> Keyword 
    "constructors" -> Keyword 
    "fail"         -> Keyword 
    "id"           -> Keyword 
    "in"           -> Keyword 
    "let"          -> Keyword 
    "module"       -> Keyword 
    "not"          -> Keyword 
    "one"          -> Keyword 
    "overlays"     -> Keyword 
    "prim"         -> Keyword 
    "rules"        -> Keyword 
    "script"       -> Keyword 
    "signature"    -> Keyword 
    "some"         -> Keyword 
    "sorts"        -> Keyword 
    "strategies"   -> Keyword 
    "stratego"     -> Keyword 
    "test"         -> Keyword 
    "where"        -> Keyword 
    "import-term"  -> Keyword 

module Stratego-Core-Layout
exports
  sorts Ws ShortCom LongCom CommChar Asterisk Eof

  lexical syntax
    [\t\ \n\r]             -> Ws       
    "//" ~[\n]* [\n] | Eof -> ShortCom 
    "/*" CommChar* "*/"    -> LongCom  
                           -> Eof      
    ~[\*]                  -> CommChar 
    "*"                    -> Asterisk 
    Asterisk               -> CommChar 

  lexical restrictions
    Asterisk -/- [\/]
    Eof -/- ~[]

  lexical syntax
    ShortCom -> LAYOUT 
    LongCom  -> LAYOUT 
    Ws       -> LAYOUT 

  context-free restrictions
    LAYOUT? -/- [\ \t\n\r]
    LAYOUT? -/- [\/] . [\*]
    LAYOUT? -/- [\/] . [\/]

module Stratego-Sugar-Layout
imports Stratego-Core-Layout

module Stratego-Sugar
imports Stratego-Sugar-Layout Stratego-Core-Identifiers Stratego-Sugar-Constants
        Stratego-Sugar-Modules Stratego-Sugar-Signatures Stratego-Sugar-Terms
        Stratego-Sugar-Strategies Stratego-Sugar-Rules
        Stratego-Sugar-DynamicRules Stratego-Sugar-Overlays

hiddens
  context-free start-symbols
    Module

module Stratego
imports Stratego-Sugar

hiddens
  context-free start-symbols
    Module

module StrategoMix[Ctx0]
imports Stratego
          [ RuleNames          => RuleNames[[Ctx0]]
            RuleDec            => RuleDec[[Ctx0]]
            DynRuleScopeId     => DynRuleScopeId[[Ctx0]]
            DynRuleId          => DynRuleId[[Ctx0]]
            DynRuleDef         => DynRuleDef[[Ctx0]]
            ScopeLabels        => ScopeLabels[[Ctx0]]
            RuleCond           => RuleCond[[Ctx0]]
            Rule               => Rule[[Ctx0]]
            RuleDef            => RuleDef[[Ctx0]]
            Overlay            => Overlay[[Ctx0]]
            SwitchCase         => SwitchCase[[Ctx0]]
            StrategyCurly      => StrategyCurly[[Ctx0]]
            StrategyAngle      => StrategyAngle[[Ctx0]]
            Kind               => Kind[[Ctx0]]
            LID                => LID[[Ctx0]]
            ImportModName      => ImportModName[[Ctx0]]
            Decl               => Decl[[Ctx0]]
            Module             => Module[[Ctx0]]
            StrategyParen      => StrategyParen[[Ctx0]]
            Typedid            => Typedid[[Ctx0]]
            Anno               => Anno[[Ctx0]]
            EmptyId            => EmptyId[[Ctx0]]
            StrategyDef        => StrategyDef[[Ctx0]]
            SVar               => SVar[[Ctx0]]
            Def                => Def[[Ctx0]]
            Type               => Type[[Ctx0]]
            RetType            => RetType[[Ctx0]]
            ArgType            => ArgType[[Ctx0]]
            FunType            => FunType[[Ctx0]]
            ConstType          => ConstType[[Ctx0]]
            Opdecl             => Opdecl[[Ctx0]]
            Sort               => Sort[[Ctx0]]
            Sdecl              => Sdecl[[Ctx0]]
            Wld                => Wld[[Ctx0]]
            ID                 => ID[[Ctx0]]
            Var                => Var[[Ctx0]]
            CharChar           => CharChar[[Ctx0]]
            Char               => Char[[Ctx0]]
            Padding            => Padding[[Ctx0]]
            Dollar4            => Dollar4[[Ctx0]]
            QuotedBracket4     => QuotedBracket4[[Ctx0]]
            StringQuotedChars4 => StringQuotedChars4[[Ctx0]]
            StringQuotedPart4  => StringQuotedPart4[[Ctx0]]
            Dollar3            => Dollar3[[Ctx0]]
            QuotedBracket3     => QuotedBracket3[[Ctx0]]
            StringQuotedChars3 => StringQuotedChars3[[Ctx0]]
            StringQuotedPart3  => StringQuotedPart3[[Ctx0]]
            Dollar2            => Dollar2[[Ctx0]]
            QuotedBracket2     => QuotedBracket2[[Ctx0]]
            StringQuotedChars2 => StringQuotedChars2[[Ctx0]]
            StringQuotedPart2  => StringQuotedPart2[[Ctx0]]
            Dollar1            => Dollar1[[Ctx0]]
            QuotedBracket1     => QuotedBracket1[[Ctx0]]
            StringQuotedChars1 => StringQuotedChars1[[Ctx0]]
            StringQuotedPart1  => StringQuotedPart1[[Ctx0]]
            StringQuotation    => StringQuotation[[Ctx0]]
            StrChar            => StrChar[[Ctx0]]
            String             => String[[Ctx0]]
            Real               => Real[[Ctx0]]
            Int                => Int[[Ctx0]]
            Keyword            => Keyword[[Ctx0]]
            UCID               => UCID[[Ctx0]]
            LCID               => LCID[[Ctx0]]
            LId                => LId[[Ctx0]]
            Id                 => Id[[Ctx0]]
            ModNamePart        => ModNamePart[[Ctx0]]
            ModName            => ModName[[Ctx0]]
            PreTerm            => PreTerm[[Ctx0]]
            Term               => Term[[Ctx0]]
            StrategyMid        => StrategyMid[[Ctx0]]
            Strategy           => Strategy[[Ctx0]] ]

module Stratego-WebDSL
imports StrategoMix[StrategoHost] WebDslMix[Term[[StrategoHost]]]

hiddens
  context-free start-symbols
    Module[[StrategoHost]]